<!doctype html>
<html lang="ro">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Raluca Korean ‚Äî Exercises</title>

<style>
*{box-sizing:border-box}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto;
  background:#f7f3ff;
  color:#1b1630;
}
.app{
  max-width:900px;
  margin:0 auto;
  padding:16px;
}
.header{
  background:#fff;
  border-radius:18px;
  padding:16px;
  box-shadow:0 12px 30px rgba(0,0,0,.1);
  margin-bottom:16px;
}
.header h1{margin:0;font-size:20px}
.header p{margin:4px 0 0;font-size:13px;color:#666}

.exercise-type{
  background:#fff;
  border-radius:18px;
  padding:16px;
  box-shadow:0 12px 30px rgba(0,0,0,.1);
  margin-bottom:16px;
}
.exercise-type label{font-weight:700;font-size:14px}
select{
  width:100%;
  margin-top:8px;
  padding:10px;
  font-size:15px;
  border-radius:12px;
  border:1px solid #ccc;
}

.exercise-card{
  background:#fff;
  border-radius:18px;
  padding:18px;
  box-shadow:0 12px 30px rgba(0,0,0,.1);
}
.question{
  font-size:22px;
  font-weight:800;
  margin-bottom:6px;
}
.sub{
  font-size:13px;
  color:#666;
  margin-bottom:16px;
}
.answers{
  display:grid;
  grid-template-columns:1fr;
  gap:10px;
  margin-bottom:16px;
}
.answer{
  padding:12px;
  border-radius:14px;
  border:2px solid #ddd;
  background:#fafafa;
  font-weight:700;
  cursor:pointer;
}
.answer.correct{
  background:#d1fae5;
  border-color:#10b981;
}
.answer.wrong{
  background:#fee2e2;
  border-color:#ef4444;
}
.feedback{
  min-height:28px;
  font-weight:700;
  margin-bottom:12px;
}
.controls{
  display:flex;
  gap:10px;
}
button{
  padding:10px 14px;
  border-radius:999px;
  border:1px solid #ccc;
  background:#fff;
  font-weight:800;
  cursor:pointer;
}
.primary{
  background:#8b5cf6;
  color:#fff;
  border:none;
}
  .answer {
  padding: 10px 14px;
  border-radius: 14px;
  border: 1px solid #ddd;
  background: #fff;
  cursor: pointer;
  transition: 0.15s ease;
}

/* üîµ SELECTAT */
.answer.selected {
  background: #e8ddff;
  border-color: #9b7cff;
  box-shadow: 0 0 0 3px rgba(155,124,255,0.25);
}

/* ‚úÖ CORECT */
.answer.correct {
  background: #d4f7d4;
  border-color: #4caf50;
}

/* ‚ùå GRE»òIT */
.answer.wrong {
  background: #ffd6d6;
  border-color: #e53935;
}
</style>
</head>

<body>
<div class="app">

  <div class="header">
    <h1>Exerci»õii TOPIK</h1>
    <p>Tip 1 ¬∑ CoreeanƒÉ ‚Üí Rom√¢nƒÉ</p>
  </div>

  <div class="exercise-type">
    <label>Tip exerci»õiu</label>
    <select disabled>
      <option>KO ‚Üí RO (Quiz)</option>
    </select>
  </div>

  <div class="exercise-card">
    <div class="question" id="question"></div>
    <div class="sub">Alege traducerea corectƒÉ</div>

    <div class="answers" id="answers"></div>

    <div class="feedback" id="feedback"></div>

    <div class="controls">
      <button class="primary" id="checkBtn">VerificƒÉ</button>
      <button id="nextBtn">√éntrebare nouƒÉ</button>
    </div>
  </div>

</div>
<script>
/* ===========================
   EXERCI»öII: Router anti-blocaj
   - nu conteazƒÉ cum »õi-ai numit func»õiile
   - dacƒÉ un tip nu e implementat, NU blocheazƒÉ pagina
   =========================== */

(function(){
  // Elemente UI (trebuie sƒÉ existe √Æn HTML)
  const exerciseTypeEl     = document.getElementById("exerciseType");
  const exerciseTypeLabelEl= document.getElementById("exerciseTypeLabel");
  const exerciseSubtagEl   = document.getElementById("exerciseSubtag");
  const exerciseQuestionEl = document.getElementById("exerciseQuestion");
  const exerciseOptionsEl  = document.getElementById("exerciseOptions");
  const exerciseFeedbackEl = document.getElementById("exerciseFeedback");
  const nextQuestionBtn    = document.getElementById("nextQuestionBtn");
  const checkAnswerBtn     = document.getElementById("checkAnswerBtn");

  if(!exerciseTypeEl || !exerciseQuestionEl || !exerciseOptionsEl){
    // dacƒÉ lipse»ôte UI, ie»ôim fƒÉrƒÉ sƒÉ stricƒÉm restul paginii
    return;
  }

  // BƒÉnci (dacƒÉ existƒÉ √Æn paginƒÉ)
  const QUIZ_BANK      = Array.isArray(window.TOPIK4_QUIZ_500) ? window.TOPIK4_QUIZ_500 : [];
  const PARTICLES_BANK = Array.isArray(window.TOPIK4_PARTICLES_500) ? window.TOPIK4_PARTICLES_500 : [];

  // Puzzle din quiz (fallback)
  const PUZZLE_BANK = QUIZ_BANK.map(q=>{
    const clean = String(q.ko||"").trim().replace(/[.?!]/g,"");
    const words = clean.split(/\s+/).filter(Boolean);
    return { words, answer: clean, ro: q.ro || "" };
  }).filter(p => p.words.length >= 2);

  // State simplu (anti-blocaj)
  const state = window.__RK_EX_STATE__ || {
    quiz:{idx:0,correct:0,total:0},
    particles:{idx:0,correct:0,total:0},
    puzzle:{idx:0,correct:0,total:0},
    lastType: exerciseTypeEl.value || "verb"
  };
  window.__RK_EX_STATE__ = state;

  let current = null;

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }

  function setTypeLabel(type){
    const map = {
      verb: "Alege traducerea corectƒÉ (KO ‚Üí RO)",
      particle: "Alege particula corectƒÉ (1 spa»õiu)",
      particlePlus: "Particule multiple (4 spa»õii)",
      conjug: "Alege conjugarea corectƒÉ",
      puzzle: "Puzzle ‚Äî ordoneazƒÉ propozi»õia"
    };
    if(exerciseTypeLabelEl) exerciseTypeLabelEl.textContent = map[type] || "‚Äî";
  }

  function setEmpty(msg){
    exerciseQuestionEl.classList.add("empty");
    exerciseQuestionEl.textContent = msg;
    exerciseOptionsEl.innerHTML = "";
    if(exerciseFeedbackEl) exerciseFeedbackEl.textContent = "";
    if(exerciseSubtagEl) exerciseSubtagEl.textContent = "";
    current = null;
  }

  // ===== Implementate ACUM: verb / particle / puzzle =====
  function renderVerb(){
    setTypeLabel("verb");
    if(!QUIZ_BANK.length) return setEmpty("Nu existƒÉ √ÆntrebƒÉri √Æn banca QUIZ.");
    if(state.quiz.idx >= QUIZ_BANK.length) state.quiz.idx = 0;

    const q = QUIZ_BANK[state.quiz.idx];
    const correct = q.ro;

    const wrong = shuffle(QUIZ_BANK.filter(x=>x.ro!==correct)).slice(0,3).map(x=>x.ro);
    const opts = shuffle([correct, ...wrong]);

    exerciseQuestionEl.classList.remove("empty");
    exerciseQuestionEl.innerHTML = `<b>${escapeHtml(q.ko)}</b>`;
    exerciseOptionsEl.innerHTML = "";
    if(exerciseFeedbackEl) exerciseFeedbackEl.textContent = "";

    if(exerciseSubtagEl){
      exerciseSubtagEl.textContent = `√éntrebarea ${state.quiz.idx+1} / ${QUIZ_BANK.length} ¬∑ Scor ${state.quiz.correct}/${state.quiz.total}`;
    }

    opts.forEach(opt=>{
      const btn = document.createElement("button");
      btn.type="button";
      btn.className="ex-option";
      btn.textContent = opt;

      btn.addEventListener("click", ()=>{
        exerciseOptionsEl.querySelectorAll("button").forEach(b=>b.disabled=true);

        const ok = opt === correct;
        state.quiz.total += 1;
        if(ok) state.quiz.correct += 1;

        btn.classList.add(ok ? "good" : "bad");
        if(exerciseFeedbackEl){
          exerciseFeedbackEl.textContent = ok ? "‚úÖ Corect." : `‚ùå Gre»ôit. Corect: ${correct}`;
        }
        if(exerciseSubtagEl){
          exerciseSubtagEl.textContent = `√éntrebarea ${state.quiz.idx+1} / ${QUIZ_BANK.length} ¬∑ Scor ${state.quiz.correct}/${state.quiz.total}`;
        }
      });

      exerciseOptionsEl.appendChild(btn);
    });

    current = { type:"verb" };
  }

  function renderParticle(){
    setTypeLabel("particle");
    if(!PARTICLES_BANK.length) return setEmpty("Nu existƒÉ √ÆntrebƒÉri √Æn banca PARTICULE.");
    if(state.particles.idx >= PARTICLES_BANK.length) state.particles.idx = 0;

    const q = PARTICLES_BANK[state.particles.idx];

    exerciseQuestionEl.classList.remove("empty");
    exerciseQuestionEl.innerHTML = `<b>${escapeHtml(q.text)}</b>`;
    exerciseOptionsEl.innerHTML = "";
    if(exerciseFeedbackEl) exerciseFeedbackEl.textContent = "";

    if(exerciseSubtagEl){
      exerciseSubtagEl.textContent = `√éntrebarea ${state.particles.idx+1} / ${PARTICLES_BANK.length} ¬∑ Corecte ${state.particles.correct}`;
    }

    q.choices.forEach(ch=>{
      const btn = document.createElement("button");
      btn.type="button";
      btn.className="ex-option";
      btn.textContent = ch;

      btn.addEventListener("click", ()=>{
        exerciseOptionsEl.querySelectorAll("button").forEach(b=>b.disabled=true);

        const ok = ch === q.answer;
        state.particles.total += 1;
        if(ok) state.particles.correct += 1;

        btn.classList.add(ok ? "good" : "bad");
        if(exerciseFeedbackEl){
          exerciseFeedbackEl.textContent = ok ? `‚úÖ Corect. (${q.explain})` : `‚ùå Gre»ôit. Corect: ${q.answer} ‚Äî ${q.explain}`;
        }
        if(exerciseSubtagEl){
          exerciseSubtagEl.textContent = `√éntrebarea ${state.particles.idx+1} / ${PARTICLES_BANK.length} ¬∑ Corecte ${state.particles.correct}`;
        }
      });

      exerciseOptionsEl.appendChild(btn);
    });

    current = { type:"particle" };
  }

  function renderPuzzle(){
    setTypeLabel("puzzle");
    if(!PUZZLE_BANK.length) return setEmpty("Nu existƒÉ puzzle-uri √Æn bancƒÉ.");
    if(state.puzzle.idx >= PUZZLE_BANK.length) state.puzzle.idx = 0;

    const pz = PUZZLE_BANK[state.puzzle.idx];
    let built = [];

    exerciseQuestionEl.classList.remove("empty");
    exerciseQuestionEl.innerHTML = `<b>AranjeazƒÉ cuvintele:</b>`;
    if(exerciseFeedbackEl) exerciseFeedbackEl.textContent = "";

    if(exerciseSubtagEl){
      exerciseSubtagEl.textContent = `Puzzle ${state.puzzle.idx+1} / ${PUZZLE_BANK.length} ¬∑ Corecte ${state.puzzle.correct}`;
    }

    // UI puzzle
    exerciseOptionsEl.innerHTML = `
      <div class="ex-puzzle">
        <div class="ex-pz-row">
          <div class="ex-pz-title">Cuvinte</div>
          <div id="pzBank" class="ex-pz-bank"></div>
        </div>
        <div class="ex-pz-row" style="margin-top:10px;">
          <div class="ex-pz-title">Propozi»õia ta</div>
          <div id="pzLine" class="ex-pz-line"></div>
        </div>
        <div class="ex-pz-actions" style="margin-top:10px;">
          <button type="button" class="secondary" id="pzClear">CurƒÉ»õƒÉ</button>
        </div>
      </div>
    `;

    const bankEl  = document.getElementById("pzBank");
    const lineEl  = document.getElementById("pzLine");
    const clearBtn= document.getElementById("pzClear");

    function render(){
      bankEl.innerHTML = "";
      lineEl.innerHTML = "";

      const remaining = pz.words.filter(w => !built.includes(w));
      shuffle(remaining).forEach(w=>{
        const chip = document.createElement("button");
        chip.type="button";
        chip.className="ex-chip";
        chip.textContent = w;
        chip.addEventListener("click", ()=>{
          built.push(w);
          render();
        });
        bankEl.appendChild(chip);
      });

      built.forEach((w, idx)=>{
        const chip = document.createElement("button");
        chip.type="button";
        chip.className="ex-chip active";
        chip.textContent = w;
        chip.addEventListener("click", ()=>{
          built.splice(idx,1);
          render();
        });
        lineEl.appendChild(chip);
      });
    }

    clearBtn.addEventListener("click", ()=>{
      built = [];
      if(exerciseFeedbackEl) exerciseFeedbackEl.textContent = "";
      render();
    });

    render();

    current = {
      type:"puzzle",
      check: ()=> built.join(" ").trim() === pz.answer.trim(),
      answer: pz.answer,
      ro: pz.ro
    };
  }

  // ===== Router (aici NU se mai blocheazƒÉ) =====
  function renderByType(type){
    state.lastType = type;

    // IMPORTANT: tipuri neimplementate √ÆncƒÉ NU blocheazƒÉ pagina
    if(type === "particlePlus") return setEmpty("particlePlus nu e implementat √ÆncƒÉ (nu blocheazƒÉ pagina).");
    if(type === "conjug")       return setEmpty("conjug nu e implementat √ÆncƒÉ (nu blocheazƒÉ pagina).");

    if(type === "verb")     return renderVerb();
    if(type === "particle") return renderParticle();
    if(type === "puzzle")   return renderPuzzle();

    return setEmpty("SelecteazƒÉ un tip valid.");
  }

  function nextQuestion(){
    const type = exerciseTypeEl.value || "verb";
    if(type==="verb")     state.quiz.idx += 1;
    if(type==="particle") state.particles.idx += 1;
    if(type==="puzzle")   state.puzzle.idx += 1;

    renderByType(type);
  }

  function checkAnswer(){
    const type = exerciseTypeEl.value || "verb";
    if(type==="puzzle" && current && current.type==="puzzle"){
      const ok = current.check();
      state.puzzle.total += 1;
      if(ok) state.puzzle.correct += 1;

      if(exerciseFeedbackEl){
        exerciseFeedbackEl.textContent = ok
          ? `‚úÖ Corect! (${current.ro})`
          : `‚ùå Nu √ÆncƒÉ. Corect: ${current.answer}\nRO: ${current.ro}`;
      }
      if(exerciseSubtagEl){
        exerciseSubtagEl.textContent = `Puzzle ${state.puzzle.idx+1} / ${PUZZLE_BANK.length} ¬∑ Corecte ${state.puzzle.correct}`;
      }
      return;
    }

    // la celelalte, rƒÉspunsul se verificƒÉ la tap (»ôi nu avem ce "check" aici)
    if(exerciseFeedbackEl) exerciseFeedbackEl.textContent = "Alege o op»õiune (tap).";
  }

  // Wire UI
  exerciseTypeEl.addEventListener("change", ()=> renderByType(exerciseTypeEl.value));
  if(nextQuestionBtn) nextQuestionBtn.addEventListener("click", nextQuestion);
  if(checkAnswerBtn)  checkAnswerBtn.addEventListener("click", checkAnswer);

  // Start
  exerciseTypeEl.value = state.lastType || exerciseTypeEl.value || "verb";
  renderByType(exerciseTypeEl.value);
})();
</script>
</body>
</html>
