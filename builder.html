<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Raluca Korean ‚Äì Study App v2.0</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #f7f3ff;
      --card-bg: #ffffff;
      --accent: #c9b5ff;
      --accent-strong: #9b7cff;
      --text-main: #333333;
      --text-soft: #666666;
      --border: #e0d7ff;
      --dimmed-bg: #f2eefc;
      --overlay-bg: rgba(0, 0, 0, 0.2);
    }
    header{text-align:center;padding:4px 8px 4px;}
    header h1{font-size:18px;margin:2px 0;font-weight:700;color:var(--accent-strong);}
    header p{margin:0;font-size:11px;color:var(--text-soft);}
 
    .screen{display:none;flex-direction:column;gap:10px;flex:1;min-height:0;}
    .screen.active{display:flex;}
 
    .mode-panel{
      background:var(--card-bg);border-radius:12px;border:1px solid var(--border);
      padding:6px 8px;font-size:11px;display:flex;flex-direction:column;gap:4px;
      box-shadow:0 4px 12px rgba(120,96,190,0.08);
    }
    .mode-row{
      display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:space-between;
    }
    .mode-row label{font-size:11px;display:flex;align-items:center;gap:4px;}
    .part-toggles{display:flex;flex-wrap:wrap;gap:6px;}
    .chip{
      display:inline-flex;align-items:center;gap:3px;
      padding:3px 8px;border-radius:999px;background:#ede7ff;color:var(--accent-strong);
      font-size:10px;cursor:pointer;
    }
    .chip input{margin:0;}
    .section-label{font-size:11px;font-weight:600;color:var(--accent-strong);margin-top:2px;}
 
    .small-mode-btn{
      padding:3px 8px;
      font-size:10px;
    }
    .small-mode-btn.active{
      background:var(--accent-strong);
      color:#fff;
    }
 
    .table-block{
      background:var(--card-bg);border-radius:14px;padding:8px;
      box-shadow:0 6px 16px rgba(120,96,190,0.08);
      display:flex;flex-direction:column;gap:4px;
    }
    .table-title{
      display:flex;align-items:center;justify-content:space-between;
      font-size:11px;font-weight:600;color:var(--text-soft);
      margin-bottom:4px;
    }
    .page-indicator{font-weight:600;color:var(--accent-strong);}
    .table-horizontal{
      display:flex;flex-wrap:wrap;align-items:center;
      gap:6px;margin-bottom:4px;
    }
    .table-horizontal .cell{
      padding:4px 6px;border-radius:6px;border:1px solid var(--border);
      font-size:11px;color:var(--accent-strong);background:var(--dimmed-bg);
    }
    .table-horizontal .cell.highlight{background:var(--accent);}
 
    .controls{display:flex;align-items:center;justify-content:space-between;margin-top:6px;}
    .btn-group button{
      font-size:10px;
      border-radius:4px;
      padding:4px 6px;
      cursor:pointer;
      border:none;
      background:var(--accent-strong);
      color:#fff;
    }
    .btn-group button:disabled{opacity:0.5;}
 
    .builder-output{
      background:var(--card-bg);border-radius:12px;border:1px solid var(--border);
      padding:6px 8px;font-size:12px;display:flex;flex-direction:column;gap:2px;
      box-shadow:0 6px 16px rgba(120,96,190,0.08);
    }
    .output-line{display:flex;align-items:center;justify-content:space-between;}
    .output-line p{margin:0;line-height:1.4;}
    .output-line p+div{display:flex;align-items:center;gap:6px;}
    .output-line button{
      font-size:10px;
      padding:2px 6px;
      border-radius:4px;
      border:none;
      cursor:pointer;
    }
    #toggleTranslationBtn{background:#d0d5dd;color:#000;}
    #toggleTranslationBtn.hidden{background:var(--accent-strong);color:#fff;}
    #copyBtn{background:#d0d5dd;}
    #copyBtn.active{background:var(--accent-strong);color:#fff;}
 
    .fav-list{
      display:flex;flex-direction:column;gap:8px;
      max-height:300px;overflow:auto;
    }
    .fav-item{
      border:1px solid var(--border);border-radius:8px;
      padding:4px 6px;display:flex;flex-direction:column;gap:2px;
    }
    .fav-item p{margin:0;font-size:12px;}
    .fav-item p.tr{font-size:11px;color:var(--text-soft);}
    .fav-item .remove-btn{
      align-self:flex-start;
      font-size:10px;color:var(--text-soft);
      background:none;border:none;cursor:pointer;
    }
    .fav-item .remove-btn:hover{color:var(--accent-strong);}
 
    .overlay{
      position:fixed;top:0;left:0;width:100%;height:100%;
      background:var(--overlay-bg);display:flex;align-items:center;justify-content:center;
      z-index:100;display:none;
    }
    .overlay.show{display:flex;}
    .overlay-panel{
      background:var(--card-bg);padding:10px 12px;border-radius:12px;
      box-shadow:0 8px 20px rgba(0,0,0,0.2);max-width:90%;
    }
    .overlay-panel h3{
      margin:4px 0;font-size:14px;font-weight:600;
      color:var(--accent-strong);
    }
    .overlay-panel p{margin:4px 0;font-size:12px;color:var(--text-main);}
    .overlay-panel ul{
      padding-left:16px;margin:6px 0;
      max-height:200px;overflow:auto;
    }
    .overlay-panel li{
      font-size:12px;color:var(--text-main);
      margin:2px 0;
    }
    .overlay-panel button{
      font-size:12px;padding:4px 8px;border:none;
      border-radius:4px;
      background:var(--accent-strong);color:#fff;
      cursor:pointer;
    }
    .overlay-panel button.close-btn{
      background:none;color:var(--text-soft);
      position:absolute;top:6px;right:8px;
      font-size:16px;line-height:1;
    }
 
    /* EXERCI»öII & LEC»öII ‚Äì mod TOPIK */
    .quest-card{
      border:1px solid var(--border);background:var(--card-bg);
      box-shadow:0 4px 12px rgba(120,96,190,0.08);border-radius:8px;
      padding:6px 8px;display:flex;flex-direction:column;gap:6px;
      position:relative;
    }
    .quest-card:before{
      content:"";position:absolute;top:-6px;left:10px;
      background:#f0e5ff;padding:1px 6px;border-radius:4px;
      font-size:9px;color:var(--accent-strong);
    }
    .quest-card.type-syll:before{content:"SYLLABLES";}
    .quest-card.type-word:before{content:"WORDS";}
    .quest-card.type-sentence:before{content:"SENTENCE";}
    .quest-card h3{font-size:13px;margin:0;color:var(--accent-strong);}
    .quest-content{display:flex;align-items:center;gap:6px;}
    .quest-content p{margin:0;font-size:28px;color:var(--accent-strong);}
    .quest-content p.blank{
      background:var(--border);color:var(--border);border-radius:4px;
      min-width:40px;min-height:32px;
    }
    .quest-content .opts{
      display:flex;flex-wrap:wrap;gap:4px;
      font-size:12px;
    }
    .quest-content .opts button{
      border:1px solid var(--border);background:#fff;border-radius:4px;
      padding:2px 6px;cursor:pointer;
    }
    .quest-content .opts button.correct{background:rgba(87,255,110,0.2);}
    .quest-content .opts button.wrong{background:rgba(255,64,87,0.2);}
    .quest-content .opts button:disabled{opacity:0.5;}
    .quest-actions{display:flex;align-items:center;justify-content:space-between;}
    .quest-actions button{
      background:var(--accent-strong);color:#fff;
      border:none;border-radius:4px;
      font-size:11px;padding:3px 6px;
      cursor:pointer;
    }
    .quest-actions .btn-text{
      background:none;border:none;
      font-size:11px;color:var(--accent-strong);
      text-decoration:underline;cursor:pointer;
    }
 
    /* CARD GENERAL ‚Äì Rom√¢nƒÉ ‚Üí CoreeanƒÉ, Exerci»õii, Glosar */
    .card{
      background: linear-gradient(120deg, #ad92ff, #80b8ff);
      border-radius:12px;padding:8px 12px;
      color:#fff;display:flex;flex-direction:column;gap:6px;
    }
    .card h3{font-size:13px;margin:0;}
    .card p{margin:0;font-size:11px;}
    .ex-card{position:relative;}
    .ex-card .tag{
      position:absolute;top:-6px;right:8px;
      background:#fff;color:#000;font-size:9px;
      padding:1px 4px;border-radius:4px;
    }
    .gloss-card{
      background: linear-gradient(120deg, #ff7272, #ffb972);
      box-shadow:0 4px 12px rgba(255,88,88,0.2);
    }
    .gloss-card input{
      width:100%;padding:4px 6px;
      border-radius:4px;border:none;
      font-size:12px;
    }
    .gloss-card .results{
      display:flex;flex-direction:column;gap:4px;
      max-height:240px;overflow:auto;
    }
    .gloss-card .result-item{
      background:#fff;color:#000;
      border-radius:4px;padding:2px 4px;
      font-size:12px;
    }
    .gloss-card .result-item span{font-weight:600;}
 
    /* ANIMA»öIE BUBBLE */
    @keyframes pop {
      0% { transform: scale(1); }
      80% { transform: scale(1.6); }
      100% { transform: scale(1); opacity: 0; }
    }
    .bubble-msg {
      position: absolute;
      top: -4px;
      left: 50%;
      transform: translateX(-50%);
      background: #000;
      color: #fff;
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
    }
    .bubble-msg.show {
      animation: pop 0.6s forwards;
    }
 
    /* THEME */
    body { margin: 0; padding: 0; background: var(--bg); font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;}
    body.pastel-theme {
      background: radial-gradient(circle at top left, #ffe4ff 0%, #d7f0ff 40%, #f0e5ff 75%, #f3d4ff 100%);
      font-weight: 500;
    }
    /* header sus */
    body.pastel-theme .rk-header {
      background: linear-gradient(120deg, #6fb8ff, #a774ff, #ff7fd1);
      color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    body.pastel-theme .rk-header h1{color:#fff;}
    body.pastel-theme .nav-btn{
      background: rgba(255,255,255,0.3);
      color: #fff;
    }
    body.pastel-theme .nav-btn.active{background: #fff; color: var(--accent-strong);}
    body.pastel-theme #randomBtn {
      background: linear-gradient(135deg, #6cc9ff, #7af0ff);
    }
    body.pastel-theme #speakBtn {
      background: linear-gradient(135deg, #6cc9ff, #5be6c6);
    }
    body.pastel-theme #favBtn {
      background: linear-gradient(135deg, #ff9a6c, #ff5f8c);
    }
    body.pastel-theme #resetBtn {
      background: linear-gradient(135deg, #ff6b6b, #ff9a6c);
    }
    body.pastel-theme .quest-card.type-syll:before{background:#d7f0ff;}
    body.pastel-theme .quest-card.type-word:before{background:#c9b5ff;}
    body.pastel-theme .quest-card.type-sentence:before{background:#ffdee9;}
 
    /* Ascund traducerea √Æn rom√¢nƒÉ DOAR √Æn preview-ul Builder */
    .preview-line .ro-text.hidden{
      filter: blur(4px);
    }
    .preview-line .ro-text.hidden:after{
      content:"¬∑¬∑¬∑";
      color: var(--accent-strong);
      font-weight: 600;
      margin-left: 4px;
    }
  </style>
</head>
<body class="pastel-theme">
  <div class="app">
    <header class="rk-header">
      <h1>Raluca Korean</h1>
      <p>Aplica»õie de studiu ‚Äì versiunea 2.0</p>
    </header>
    <!-- Screens / Sections -->
    <div class="screens" style="flex:1; display:flex; flex-direction:column; overflow:auto;">
      <!-- BUILDER Screen -->
      <div id="screen-builder" class="screen active" style="padding:8px 12px;">
        <!-- Mode Panel (toggles, settings) -->
        <div class="mode-panel">
          <!-- Row 1: part toggles and randomize -->
          <div class="mode-row">
            <div class="part-toggles">
              <span class="chip"><input type="checkbox" data-part="subject" checked /> Subiect</span>
              <span class="chip"><input type="checkbox" data-part="time" /> Timp</span>
              <span class="chip"><input type="checkbox" data-part="place" /> Loc</span>
              <span class="chip"><input type="checkbox" data-part="mod" /> Mod</span>
              <span class="chip"><input type="checkbox" data-part="object" /> Obiect</span>
              <span class="chip"><input type="checkbox" data-part="verb" checked /> Predicat</span>
            </div>
            <button id="resetBtn">‚úñ Reset</button>
          </div>
          <!-- Row 2: mode toggles and random sentence -->
          <div class="mode-row">
            <label class="section-label">Mod:</label>
            <div>
              <button class="secondary small-mode-btn" data-mode="simple">Simplu</button>
              <button class="secondary small-mode-btn active" data-mode="topik">TOPIK</button>
            </div>
            <button id="randomBtn">üé≤ Random propozi»õie</button>
          </div>
          <!-- Row 3: sentence 2 toggle (for compound sentences) -->
          <div class="mode-row builder-enable-p2">
            <label>
              <input type="checkbox" id="enableP2" />
              ActiveazƒÉ Propozi»õia 2 (fraza)
            </label>
          </div>
        </div>
        <!-- Table of sentence parts for Propozi»õia 1 (and P2 if enabled) -->
        <div class="table-block">
          <div class="table-title">
            <span>Propozi»õia 1</span>
            <span class="page-indicator" id="pageInfo"></span>
          </div>
          <div class="table-horizontal" id="tableP1"></div>
          <div class="table-title hidden" id="titleP2">
            <span>Propozi»õia 2 (continuare / frazƒÉ)</span>
          </div>
          <div class="table-horizontal hidden" id="tableP2"></div>
          <!-- Navigation Controls: Prev/Next model and randomize -->
          <div class="controls">
            <div class="btn-group">
              <button id="prevBtn">‚¨Ö Prev (r√¢nd model)</button>
              <button id="nextBtn">Next ‚û°</button>
            </div>
            <div class="btn-group">
              <button id="randomBtn2">üé≤ Random</button>
            </div>
          </div>
        </div>
        <!-- Output block: Korean sentence preview and translation, actions (speak, save, toggle translation, copy) -->
        <div class="builder-output">
          <div class="output-line preview-line">
            <p id="previewKo" class="ko-text" style="font-size:14px; font-weight:600; color:var(--accent-strong);">Alege cuvintele...</p>
            <div>
              <button id="speakBtn">üîä Audio coreeanƒÉ</button>
              <button id="favBtn" class="secondary">‚≠ê SalveazƒÉ propozi»õia</button>
            </div>
          </div>
          <div class="output-line">
            <p id="previewRo" class="ro-text" style="font-size:12px; color:var(--text-soft);">Alege cuvintele pentru a forma propozi»õia...</p>
            <div>
              <button id="toggleTranslationBtn">Ascunde traducerea</button>
              <button id="copyBtn">Copiere</button>
            </div>
          </div>
        </div>
        <!-- Favorites overlay (for saved sentences) -->
        <div class="overlay" id="overlay">
          <div class="overlay-panel">
            <button class="close-btn" id="closePanelBtn">&times;</button>
            <h3 id="panelTitle">Salvate</h3>
            <p id="panelSub">Propozi»õii salvate pentru exersare ulterioarƒÉ:</p>
            <ul class="fav-list" id="panelList"></ul>
            <button id="clearFavBtn">»òterge tot</button>
          </div>
        </div>
      </div>
      <!-- EXERCISES Screen -->
      <div id="screen-exercises" class="screen" style="padding:8px 12px; overflow:auto;">
        <div class="card ex-card">
          <h3>Exerci»õii recapitulative TOPIK</h3>
          <p>ExerseazƒÉ completarea propozi»õiilor (Similar sec»õiunii Ïì∞Í∏∞ ‚Äì TOPIK I)</p>
          <span class="tag">BETA</span>
        </div>
        <div id="exercisesContainer" style="display:flex; flex-direction:column; gap:10px;"></div>
      </div>
      <!-- LESSONS Screen -->
      <div id="screen-lessons" class="screen" style="padding:8px 12px;">
        <div class="card">
          <h3>Lec»õii</h3>
          <p>Explica»õii gramaticale »ôi exemple</p>
        </div>
        <div style="display:flex; flex-direction:column; gap:10px;">
          <!-- Example Lesson Entry (to be dynamically populated) -->
          <div class="card ex-card">
            <h3>Lec»õia 1: Introducere</h3>
            <p>Exemplu: Azi am de √ÆnvƒÉ»õat multe cuvinte coreene.</p>
            <button id="lesson1TryBtn" class="btn-text">√éncearcƒÉ √Æn Builder &rarr;</button>
            <span class="tag">NEW</span>
          </div>
          <!-- Additional lessons can be appended similarly -->
        </div>
      </div>
      <!-- GLOSSARY Screen -->
      <div id="screen-glossary" class="screen" style="padding:8px 12px;">
        <div class="card gloss-card">
          <h3>Glosar</h3>
          <p>CƒÉutare rapidƒÉ √Æn toate cuvintele folosite</p>
          <input type="text" id="glossarySearch" placeholder="CautƒÉ un cuv√¢nt..." />
          <div class="results" id="glossaryResults"></div>
        </div>
      </div>
    </div>
    <!-- Bottom Navigation -->
    <div style="display:flex;">
      <button class="nav-btn active" data-target="builder" style="flex:1;">Builder</button>
      <button class="nav-btn" data-target="exercises" style="flex:1;">Exerci»õii</button>
      <button class="nav-btn" data-target="lessons" style="flex:1;">Lec»õii</button>
      <button class="nav-btn" data-target="glossary" style="flex:1;">Glosar</button>
    </div>
  </div>
  <script>
    let LAST_RO_SENTENCE = "";
    /* === LISTE DE CUVINTE (de bazƒÉ) === */
    const subjectData = [
      // Persoane & pronume
      { ko: "Ï†ÄÎäî", ro: "eu (formal)", en: "I (formal)" },
      { ko: "ÎÇòÎäî", ro: "eu (informal)", en: "I (informal)" },
      { ko: "Ïö∞Î¶¨Îäî", ro: "noi", en: "we" },
      { ko: "ÎãπÏã†ÏùÄ", ro: "tu / dvs.", en: "you" },
      { ko: "ÎÑàÎäî", ro: "tu (informal)", en: "you (informal)" },
      { ko: "Ïó¨Îü¨Î∂ÑÏùÄ", ro: "voi / dumneavoastrƒÉ", en: "you (plural/formal)" },
      { ko: "Í∑∏Îäî", ro: "el", en: "he" },
      { ko: "Í∑∏ÎÖÄÎäî", ro: "ea", en: "she" },
      { ko: "Í∑∏Îì§ÏùÄ", ro: "ei / ele", en: "they" },
      // Familie
      { ko: "ÏóÑÎßàÎäî", ro: "mama", en: "mother" },
      { ko: "ÏïÑÎπ†Îäî", ro: "tata", en: "father" },
      { ko: "ÌòïÏùÄ", ro: "fratele mai mare (al unui bƒÉiat)", en: "older brother (of a boy)" },
      { ko: "Ïò§Îπ†Îäî", ro: "fratele mai mare (al unei fete)", en: "older brother (of a girl)" },
      { ko: "ÎàÑÎÇòÎäî", ro: "sora mai mare (a unui bƒÉiat)", en: "older sister (of a boy)" },
      { ko: "Ïñ∏ÎãàÎäî", ro: "sora mai mare (a unei fete)", en: "older sister (of a girl)" },
      { ko: "ÎÇ®ÎèôÏÉùÏùÄ", ro: "fratele mai mic", en: "younger brother" },
      { ko: "Ïó¨ÎèôÏÉùÏùÄ", ro: "sora mai micƒÉ", en: "younger sister" },
      { ko: "Ìï†Î®∏ÎãàÎäî", ro: "bunica", en: "grandmother" },
      { ko: "Ìï†ÏïÑÎ≤ÑÏßÄÎäî", ro: "bunicul", en: "grandfather" },
      // Altele
      { ko: "ÌïôÏÉùÏùÄ", ro: "elevul", en: "student" },
      { ko: "ÏÑ†ÏÉùÎãòÏùÄ", ro: "profesorul", en: "teacher" },
      { ko: "ÏπúÍµ¨Îäî", ro: "prietenul / prietena", en: "friend" }
    ];
    const timeData = [
      // Zile
      { ko: "Ïò§Îäò", ro: "astƒÉzi", en: "today" },
      { ko: "ÎÇ¥Ïùº", ro: "m√¢ine", en: "tomorrow" },
      { ko: "Î™®Î†à", ro: "poim√¢ine", en: "the day after tomorrow" },
      { ko: "Ïñ¥Ï†ú", ro: "ieri", en: "yesterday" },
      { ko: "Í∑∏Ï†ÄÍªò", ro: "alaltƒÉieri", en: "the day before yesterday" },
      // Momente ale zilei
      { ko: "ÏïÑÏπ®Ïóê", ro: "diminea»õa", en: "in the morning" },
      { ko: "ÎÇÆÏóê", ro: "dupƒÉ-amiaza / ziua", en: "in the afternoon" },
      { ko: "Ï†ÄÎÖÅÏóê", ro: "seara", en: "in the evening" },
      { ko: "Î∞§Ïóê", ro: "noaptea", en: "at night" },
      // Altele
      { ko: "ÏßÄÍ∏à", ro: "acum", en: "now" },
      { ko: "ÎÇòÏ§ëÏóê", ro: "mai t√¢rziu", en: "later" },
      { ko: "Í≥ß", ro: "√Æn cur√¢nd", en: "soon" },
      { ko: "Ìï≠ÏÉÅ", ro: "√Æntotdeauna", en: "always" },
      { ko: "ÏûêÏ£º", ro: "des", en: "often" },
      { ko: "Í∞ÄÎÅî", ro: "ocazional", en: "sometimes" },
      { ko: "Ï†àÎåÄ", ro: "niciodatƒÉ (urmat de nega»õie)", en: "never (used with negation)" },
      { ko: "ÏùºÏ∞ç", ro: "devreme", en: "early" },
      { ko: "Îä¶Í≤å", ro: "t√¢rziu", en: "late" }
    ];
    const placeData = [
      { ko: "ÌïôÍµêÏóê", ro: "la »ôcoalƒÉ", en: "to school" },
      { ko: "ÏßëÏóê", ro: "acasƒÉ", en: "home" },
      { ko: "ÎßàÌä∏Ïóê", ro: "la supermarket", en: "to the supermarket" },
      { ko: "Í≥µÏõêÏóê", ro: "√Æn parc", en: "to the park" },
      { ko: "ÌöåÏÇ¨Ïóê", ro: "la firmƒÉ", en: "to the company" },
      { ko: "ÎèÑÏÑúÍ¥ÄÏóê", ro: "la bibliotecƒÉ", en: "to the library" },
      { ko: "Í∑πÏû•Ïóê", ro: "la teatru / cinematograf", en: "to the theater / cinema" },
      { ko: "ÏãùÎãπÏóê", ro: "la restaurant", en: "to the restaurant" },
      { ko: "Î∞îÎã§Ïóê", ro: "la mare", en: "to the seaside" },
      { ko: "ÏÇ∞Ïóê", ro: "la munte", en: "to the mountains" },
      { ko: "Í∞ïÏóê", ro: "la r√¢u", en: "to the river" },
      { ko: "Ìò∏ÏàòÏóê", ro: "la lac", en: "to the lake" },
      { ko: "ÏùÄÌñâÏóê", ro: "la bancƒÉ", en: "to the bank" },
      { ko: "Î≥ëÏõêÏóê", ro: "la spital", en: "to the hospital" },
      { ko: "ÏïΩÍµ≠Ïóê", ro: "la farmacie", en: "to the pharmacy" }
    ];
    const modData = [
      { ko: "ÌòºÏûêÏÑú", ro: "singur(ƒÉ)", en: "alone" },
      { ko: "Í∞ôÏù¥", ro: "√ÆmpreunƒÉ", en: "together" },
      { ko: "Ïûò", ro: "bine", en: "well" },
      { ko: "Îπ®Î¶¨", ro: "repede", en: "quickly" },
      { ko: "Ï≤úÏ≤úÌûà", ro: "√Æncet", en: "slowly" },
      { ko: "Ï°∞Ïö©Ìûà", ro: "lini»ôtit", en: "quietly" },
      { ko: "ÎßéÏù¥", ro: "mult", en: "a lot/many" },
      { ko: "Ï°∞Í∏à", ro: "pu»õin", en: "a little" },
      { ko: "ÌäπÌûà", ro: "√Æn special", en: "especially" }
    ];
    const objectData = [
      // Cuvinte de bazƒÉ
      { ko: "Ï±ÖÏùÑ", ro: "carte", en: "book" },
      { ko: "ÏÇ¨Í≥ºÎ•º", ro: "mƒÉr", en: "apple" },
      { ko: "ÎπµÏùÑ", ro: "p√¢ine", en: "bread" },
      { ko: "Î¨ºÏùÑ", ro: "apƒÉ", en: "water" },
      { ko: "Ïª§ÌîºÎ•º", ro: "cafea", en: "coffee" },
      { ko: "Ï∞®Î•º", ro: "ceai", en: "tea" },
      { ko: "Ïã†Î¨∏ÏùÑ", ro: "ziar", en: "newspaper" },
      { ko: "Ïó∞ÌïÑÏùÑ", ro: "creion", en: "pencil" },
      { ko: "Ìé∏ÏßÄÎ•º", ro: "scrisoare", en: "letter" },
      { ko: "Ïª¥Ìì®ÌÑ∞Î•º", ro: "calculator", en: "computer" },
      { ko: "ÌÖîÎ†àÎπÑÏ†ÑÏùÑ", ro: "televizor", en: "television" },
      { ko: "ÏùåÏïÖÏùÑ", ro: "muzicƒÉ", en: "music" },
      { ko: "ÏòÅÌôîÎ•º", ro: "film", en: "movie" },
      { ko: "ÏÇ¨ÏßÑÏùÑ", ro: "fotografie", en: "photo" },
      { ko: "Ïò∑ÏùÑ", ro: "hainƒÉ / haine", en: "clothes" },
      // Plural (pe persoanƒÉ)
      { ko: "Ï±ÖÎì§ÏùÑ", ro: "cƒÉr»õi", en: "books" },
      { ko: "ÏÇ¨Í≥ºÎì§ÏùÑ", ro: "mere", en: "apples" },
      // Alte substantive utile
      { ko: "ÏàôÏ†úÎ•º", ro: "temƒÉ / temele", en: "homework" },
      { ko: "ÏùºÏùÑ", ro: "treabƒÉ / treaba (muncƒÉ)", en: "work/job (task)" },
      { ko: "ÏùåÏãùÏùÑ", ro: "m√¢ncare", en: "food" },
      { ko: "ÏÑ†Î¨ºÏùÑ", ro: "cadou", en: "present" },
      { ko: "ÏßàÎ¨∏ÏùÑ", ro: "√Æntrebare", en: "question" },
      { ko: "ÎåÄÎãµÏùÑ", ro: "rƒÉspuns", en: "answer" },
      { ko: "Ïù¥ÏïºÍ∏∞Î•º", ro: "poveste / discu»õie", en: "story/conversation" },
      { ko: "ÎÖ∏ÎûòÎ•º", ro: "c√¢ntec", en: "song" }
    ];
    const numeralData = [
      { ko: "Ìïú", ro: "un(o)", en: "one" },
      { ko: "Îëê", ro: "doi / douƒÉ", en: "two" },
      { ko: "ÏÑ∏", ro: "trei", en: "three" },
      { ko: "ÎÑ§", ro: "patru", en: "four" },
      { ko: "Îã§ÏÑØ", ro: "cinci", en: "five" },
      { ko: "Ïó¨ÏÑØ", ro: "»ôase", en: "six" },
      { ko: "ÏùºÍ≥±", ro: "»ôapte", en: "seven" },
      { ko: "Ïó¨Îçü", ro: "opt", en: "eight" },
      { ko: "ÏïÑÌôâ", ro: "nouƒÉ", en: "nine" },
      { ko: "Ïó¥", ro: "zece", en: "ten" },
      // Sino-coreean (ex. pentru ore, etc.)
      { ko: "Ïã≠", ro: "zece (sino-coreean)", en: "ten (Sino-Korean)" },
      { ko: "Î∞±", ro: "o sutƒÉ", en: "hundred" },
      { ko: "Ï≤ú", ro: "o mie", en: "thousand" },
      { ko: "Îßå", ro: "zece mii", en: "ten thousand" }
    ];
    const counterData = [
      { ko: "Í∞úÎ•º", ro: "(obiecte √Æn general)", en: "(things in general)" },
      { ko: "Î™ÖÏùÑ", ro: "(persoane)", en: "(people)" },
      { ko: "Í∂åÏùÑ", ro: "(cƒÉr»õi/caiete)", en: "(books/notebooks)" },
      { ko: "ÏûîÏùÑ", ro: "(ce»ôti/pahare)", en: "(cups/glasses)" },
      { ko: "Î≥ëÏùÑ", ro: "(sticle)", en: "(bottles)" },
      { ko: "ÎßàÎ¶¨Î•º", ro: "(animale)", en: "(animals)" },
      { ko: "ÎåÄÎ•º", ro: "(ma»ôini)", en: "(vehicles)" },
      { ko: "ÏãúÏóê", ro: "(ora fixƒÉ)", en: "(hour o'clock)" },
      { ko: "Î∂ÑÏóê", ro: "(minute)", en: "(minutes)" }
    ];
    const verbData = [
      { ko: "Í∞ëÎãàÎã§", ro: "merg(e) (formal)", en: "go/goes (formal polite)" },
      { ko: "Í∞ÄÏöî", ro: "merg(e) (polite)", en: "go/goes (casual polite)" },
      { ko: "Í∞ÑÎã§", ro: "merg(e) (informal)", en: "go/goes (plain)" },
      { ko: "ÏôîÏäµÎãàÎã§", ro: "am/a venit (formal)", en: "came (formal polite past)" },
      { ko: "ÏôîÏñ¥Ïöî", ro: "am/a venit (polite)", en: "came (casual polite past)" },
      { ko: "ÏôîÎã§", ro: "am/a venit (informal)", en: "came (plain past)" },
      { ko: "Ìï©ÎãàÎã§", ro: "fac(e) (formal)", en: "do/does (formal polite)" },
      { ko: "Ìï¥Ïöî", ro: "fac(e) (polite)", en: "do/does (casual polite)" },
      { ko: "ÌïúÎã§", ro: "fac(e) (informal)", en: "do/does (plain)" },
      { ko: "Î®πÏäµÎãàÎã§", ro: "mƒÉn√¢nc(ƒÉ) (formal)", en: "eat/eats (formal polite)" },
      { ko: "Î®πÏñ¥Ïöî", ro: "mƒÉn√¢nc(ƒÉ) (polite)", en: "eat/eats (casual polite)" },
      { ko: "Î®πÎäîÎã§", ro: "mƒÉn√¢nc(ƒÉ) (informal)", en: "eat/eats (plain)" },
      { ko: "ÎßàÏã≠ÎãàÎã§", ro: "beau (formal)", en: "drink/drinks (formal polite)" },
      { ko: "ÎßàÏÖîÏöî", ro: "beau (polite)", en: "drink/drinks (casual polite)" },
      { ko: "ÎßàÏã†Îã§", ro: "beau (informal)", en: "drink/drinks (plain)" },
      { ko: "Î¥ÖÎãàÎã§", ro: "privesc / vƒÉd (formal)", en: "see/sees (formal polite)" },
      { ko: "Î¥êÏöî", ro: "privesc / vƒÉd (polite)", en: "see/sees (casual polite)" },
      { ko: "Î≥∏Îã§", ro: "privesc / vƒÉd (informal)", en: "see/sees (plain)" },
      { ko: "ÏùΩÏäµÎãàÎã§", ro: "citesc (formal)", en: "read/reads (formal polite)" },
      { ko: "ÏùΩÏñ¥Ïöî", ro: "citesc (polite)", en: "read/reads (casual polite)" },
      { ko: "ÏùΩÎäîÎã§", ro: "citesc (informal)", en: "read/reads (plain)" },
      { ko: "ÏîÅÎãàÎã§", ro: "scriu (formal)", en: "write/writes (formal polite)" },
      { ko: "Ïç®Ïöî", ro: "scriu (polite)", en: "write/writes (casual polite)" },
      { ko: "Ïì¥Îã§", ro: "scriu (informal)", en: "write/writes (plain)" },
      { ko: "ÎßêÌï©ÎãàÎã§", ro: "vorbesc (formal)", en: "speak/speaks (formal polite)" },
      { ko: "ÎßêÌï¥Ïöî", ro: "vorbesc (polite)", en: "speak/speaks (casual polite)" },
      { ko: "ÎßêÌïúÎã§", ro: "vorbesc (informal)", en: "speak/speaks (plain)" },
      { ko: "Îì£ÏäµÎãàÎã§", ro: "ascultƒÉ (formal)", en: "listen/listens (formal polite)" },
      { ko: "Îì§Ïñ¥Ïöî", ro: "ascultƒÉ (polite)", en: "listen/listens (casual polite)" },
      { ko: "Îì£ÎäîÎã§", ro: "ascultƒÉ (informal)", en: "listen/listens (plain)" },
      { ko: "Í≥µÎ∂ÄÌï©ÎãàÎã§", ro: "studiazƒÉ (formal)", en: "study/studies (formal polite)" },
      { ko: "Í≥µÎ∂ÄÌï¥Ïöî", ro: "studiazƒÉ (polite)", en: "study/studies (casual polite)" },
      { ko: "Í≥µÎ∂ÄÌïúÎã§", ro: "studiazƒÉ (informal)", en: "study/studies (plain)" },
      { ko: "ÏùºÌï©ÎãàÎã§", ro: "lucreazƒÉ (formal)", en: "work/works (formal polite)" },
      { ko: "ÏùºÌï¥Ïöî", ro: "lucreazƒÉ (polite)", en: "work/works (casual polite)" },
      { ko: "ÏùºÌïúÎã§", ro: "lucreazƒÉ (informal)", en: "work/works (plain)" },
      { ko: "Ïö¥ÎèôÌï©ÎãàÎã§", ro: "face sport (formal)", en: "exercise/exercises (formal polite)" },
      { ko: "Ïö¥ÎèôÌï¥Ïöî", ro: "face sport (polite)", en: "exercise/exercises (casual polite)" },
      { ko: "Ïö¥ÎèôÌïúÎã§", ro: "face sport (informal)", en: "exercise/exercises (plain)" },
      { ko: "ÏâΩÎãàÎã§", ro: "se odihne»ôte (formal)", en: "rest/rests (formal polite)" },
      { ko: "Ïâ¨Ïñ¥Ïöî", ro: "se odihne»ôte (polite)", en: "rest/rests (casual polite)" },
      { ko: "Ïâ∞Îã§", ro: "se odihne»ôte (informal)", en: "rest/rests (plain)" },
      { ko: "ÎÜâÎãàÎã§", ro: "se joacƒÉ (formal)", en: "play/plays (formal polite)" },
      { ko: "ÎÜÄÏïÑÏöî", ro: "se joacƒÉ (polite)", en: "play/plays (casual polite)" },
      { ko: "ÎÖºÎã§", ro: "se joacƒÉ (informal)", en: "play/plays (plain)" },
      { ko: "ÎßåÎÇ©ÎãàÎã§", ro: "se √Ænt√¢lne»ôte (formal)", en: "meet/meets (formal polite)" },
      { ko: "ÎßåÎÇòÏöî", ro: "se √Ænt√¢lne»ôte (polite)", en: "meet/meets (casual polite)" },
      { ko: "ÎßåÎÇúÎã§", ro: "se √Ænt√¢lne»ôte (informal)", en: "meet/meets (plain)" },
      { ko: "Ï§çÎãàÎã§", ro: "dƒÉ (formal)", en: "give/gives (formal polite)" },
      { ko: "Ï§òÏöî", ro: "dƒÉ (polite)", en: "give/gives (casual polite)" },
      { ko: "Ï§ÄÎã§", ro: "dƒÉ (informal)", en: "give/gives (plain)" },
      { ko: "Î∞õÏäµÎãàÎã§", ro: "prime»ôte (formal)", en: "receive/receives (formal polite)" },
      { ko: "Î∞õÏïÑÏöî", ro: "prime»ôte (polite)", en: "receive/receives (casual polite)" },
      { ko: "Î∞õÎäîÎã§", ro: "prime»ôte (informal)", en: "receive/receives (plain)" },
      { ko: "Î∞∞ÏõÅÎãàÎã§", ro: "√Ænva»õƒÉ (formal)", en: "learn/learns (formal polite)" },
      { ko: "Î∞∞ÏõåÏöî", ro: "√Ænva»õƒÉ (polite)", en: "learn/learns (casual polite)" },
      { ko: "Î∞∞Ïö¥Îã§", ro: "√Ænva»õƒÉ (informal)", en: "learn/learns (plain)" },
      { ko: "Í∞ÄÎ•¥Ïπ©ÎãàÎã§", ro: "predƒÉ (formal)", en: "teach/teaches (formal polite)" },
      { ko: "Í∞ÄÎ•¥Ï≥êÏöî", ro: "predƒÉ (polite)", en: "teach/teaches (casual polite)" },
      { ko: "Í∞ÄÎ•¥ÏπúÎã§", ro: "predƒÉ (informal)", en: "teach/teaches (plain)" }
    ];
    // Sentence 2 connectors (e.g., "and", "but", etc.)
    const sentence2Data = [
      { ko: "Í∑∏Î¶¨Í≥†", ro: "»ôi / iar", en: "and/and then" },
      { ko: "Í∑∏ÎûòÏÑú", ro: "a»ôa cƒÉ", en: "so/therefore" },
      { ko: "ÌïòÏßÄÎßå", ro: "dar", en: "but/however" },
      { ko: "Í∑∏Îü¨ÎÇò", ro: "√ÆnsƒÉ", en: "but/however" },
      { ko: "ÎòêÎäî", ro: "sau", en: "or" }
    ];
    // TIP: The arrays above provide basic words for each part of the sentence.
 
    // Additional data structures for user-added (custom) words or saved sentences
    const STORAGE_KEY = "ralucaKoreanCustomWords_v2";
    const customData = { subject: [], time: [], place: [], mod: [], object: [], verb: [], predicate: [], sentence2: [] };
    let favorites = [];
 
    // UI element references
    const screens = document.querySelectorAll(".screen");
    const navButtons = document.querySelectorAll(".nav-btn");
    const screenBuilder = document.getElementById("screen-builder");
    const screenExercises = document.getElementById("screen-exercises");
    const screenLessons = document.getElementById("screen-lessons");
    const screenGlossary = document.getElementById("screen-glossary");
 
    const previewKo = document.getElementById("previewKo");
    const previewRo = document.getElementById("previewRo");
    const pageInfo = document.getElementById("pageInfo");
    const tableP1 = document.getElementById("tableP1");
    const titleP2 = document.getElementById("titleP2");
    const tableP2 = document.getElementById("tableP2");
 
    const randomBtn = document.getElementById("randomBtn");
    const randomBtn2 = document.getElementById("randomBtn2");
    const speakBtn = document.getElementById("speakBtn");
    const favBtn = document.getElementById("favBtn");
    const resetBtn = document.getElementById("resetBtn");
    const enableP2 = document.getElementById("enableP2");
    const toggleTranslationBtn = document.getElementById("toggleTranslationBtn");
    const copyBtn = document.getElementById("copyBtn");
 
    const overlay = document.getElementById("overlay");
    const panelTitle = document.getElementById("panelTitle");
    const panelSub = document.getElementById("panelSub");
    const panelList = document.getElementById("panelList");
    const closePanelBtn = document.getElementById("closePanelBtn");
    const clearFavBtn = document.getElementById("clearFavBtn");
 
    const exercisesContainer = document.getElementById("exercisesContainer");
    const glossarySearch = document.getElementById("glossarySearch");
    const glossaryResults = document.getElementById("glossaryResults");
 
    // On page load, retrieve any custom words from localStorage
    function loadCustomData() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const saved = JSON.parse(raw);
      Object.keys(customData).forEach(k => {
        if (Array.isArray(saved[k])) {
          customData[k] = saved[k];
        }
      });
    }
    loadCustomData();
 
    // Save custom data (if user adds custom words, etc.)
    function saveCustomData() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(customData));
      } catch (e) {
        console.warn("Storage saving issue:", e);
      }
    }
 
    // Utility: choose a random element from an array
    function rand(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
 
    // Utility: combine default data and custom data for a given category
    function getCombinedList(category) {
      switch (category) {
        case "subject": return [...subjectData, ...customData.subject];
        case "time": return [...timeData, ...customData.time];
        case "place": return [...placeData, ...customData.place];
        case "mod": return [...modData, ...customData.mod];
        case "object": return [...objectData, ...customData.object];
        case "numeral": return [...numeralData];
        case "counter": return [...counterData];
        case "verb": return [...verbData, ...customData.verb];
        case "predicate": return [...verbData, ...customData.predicate]; // 'predicate' can hold entire predicate phrases, reuse verbData for now
        case "sentence2": return [...sentence2Data];
      }
      return [];
    }
 
    // Utility: Create a cell element for the table (word part)
    function createCell(id, text, isHighlight = false) {
      const cell = document.createElement("span");
      cell.className = "cell" + (isHighlight ? " highlight" : "");
      cell.textContent = text;
      cell.dataset.id = id;
      return cell;
    }
 
    // Populate the table for a given sentence (p1 or p2) based on selected parts and a given random model or user selection
    function buildSentenceParts(randomModelIndex = null) {
      // Determine which parts are active (checked)
      const activeParts = Array.from(document.querySelectorAll(".part-toggles input:checked")).map(inp => inp.getAttribute("data-part"));
      // Always include "subject" and "verb" in active parts (ensuring at least a basic sentence structure)
      if (!activeParts.includes("subject")) activeParts.unshift("subject");
      if (!activeParts.includes("verb")) activeParts.push("verb");
 
      // If randomModelIndex is provided, use that model's configuration of parts; otherwise, use activeParts directly for free build
      const modelParts = randomModelIndex != null ? sentenceModels[randomModelIndex] : activeParts;
 
      // Build or update table for sentence 1
      tableP1.innerHTML = "";
      modelParts.forEach(part => {
        // For each part, get a random word (or placeholder if not active)
        let wordObj = null;
        if (part === "predicate") {
          // If predicate (which might include verb plus ending) - treat as separate concept if needed
          wordObj = rand(getCombinedList("predicate"));
        } else {
          const list = getCombinedList(part);
          wordObj = list.length ? rand(list) : null;
        }
        let displayText = wordObj ? wordObj.ko : `(${part})`;
        const cell = createCell(part, displayText, false);
        tableP1.appendChild(cell);
      });
      // If sentence 2 is enabled, build table for sentence 2 similarly (with connector + second sentence structure)
      if (enableP2.checked) {
        titleP2.classList.remove("hidden");
        tableP2.classList.remove("hidden");
        tableP2.innerHTML = "";
        // Always start sentence2 with a connector (choose one at random)
        const connector = rand(sentence2Data);
        tableP2.appendChild(createCell("connector", connector.ko, true));
        // Then add a subject for second sentence unless it‚Äôs implicitly same subject? We'll include it for now
        const partsP2 = ["subject", ...modelParts.filter(p => p !== "subject")]; // ensure subject appears first
        partsP2.forEach((part, idx) => {
          if (idx === 0) {
            // first part is subject for sentence2
          }
          if (part === "predicate") {
            const wordObj = rand(getCombinedList("predicate"));
            let displayText = wordObj ? wordObj.ko : `(${part})`;
            tableP2.appendChild(createCell(part, displayText, false));
          } else if (part !== "connector") {
            const list = getCombinedList(part);
            let wordObj = list.length ? rand(list) : null;
            let displayText = wordObj ? wordObj.ko : `(${part})`;
            tableP2.appendChild(createCell(part, displayText, false));
          }
        });
      } else {
        titleP2.classList.add("hidden");
        tableP2.classList.add("hidden");
      }
      updateSentencePreview();
    }
 
    // Build the final Korean sentence from the table parts and update preview
    function updateSentencePreview() {
      // Gather Korean parts from the table cells
      let koSentence = "";
      tableP1.querySelectorAll(".cell").forEach(cell => {
        koSentence += cell.textContent.replace(/[*]/g, "") + " ";
      });
      koSentence = koSentence.trim();
      // If second sentence is enabled, add connector and parts
      if (enableP2.checked) {
        tableP2.querySelectorAll(".cell").forEach(cell => {
          koSentence += " " + cell.textContent.replace(/[*]/g, "");
        });
        koSentence = koSentence.trim();
      }
      previewKo.textContent = koSentence || "‚Ä¶";
      // Generate Romanian translation for the sentence
      let roSentence = generateTranslation();
      previewRo.textContent = roSentence || "‚Ä¶";
      LAST_RO_SENTENCE = roSentence;
    }
 
    // Generate translation in Romanian (and optionally English) based on current sentence structure
    function generateTranslation() {
      // For now, simple concatenation of selected parts' Romanian meaning
      // In a real scenario, grammar adjustments would be necessary (word order, particles usage, etc.)
      let roSentence = "";
      let enSentence = "";
      // Process parts from sentence 1
      tableP1.querySelectorAll(".cell").forEach(cell => {
        const id = cell.dataset.id;
        const koText = cell.textContent;
        let dataList = [];
        if (id === "subject") dataList = subjectData;
        else if (id === "time") dataList = timeData;
        else if (id === "place") dataList = placeData;
        else if (id === "mod") dataList = modData;
        else if (id === "object") dataList = objectData;
        else if (id === "numeral") dataList = numeralData;
        else if (id === "counter") dataList = counterData;
        else if (id === "verb") dataList = verbData;
        else if (id === "predicate") dataList = verbData; // simplifying: treat like verb
        const item = dataList.find(item => item.ko === koText);
        if (item) {
          roSentence += item.ro + " ";
          enSentence += item.en + " ";
        } else {
          // If item not found (e.g., placeholder or custom not recognized), just use the Korean as placeholder
          roSentence += koText + " ";
          enSentence += koText + " ";
        }
      });
      roSentence = roSentence.trim();
      enSentence = enSentence.trim();
      // Process sentence 2 if present
      if (enableP2.checked) {
        let roSentence2 = "";
        let enSentence2 = "";
        tableP2.querySelectorAll(".cell").forEach(cell => {
          const id = cell.dataset.id;
          const koText = cell.textContent;
          let dataList = [];
          if (id === "connector") dataList = sentence2Data;
          else if (id === "subject") dataList = subjectData;
          else if (id === "time") dataList = timeData;
          else if (id === "place") dataList = placeData;
          else if (id === "mod") dataList = modData;
          else if (id === "object") dataList = objectData;
          else if (id === "numeral") dataList = numeralData;
          else if (id === "counter") dataList = counterData;
          else if (id === "verb") dataList = verbData;
          else if (id === "predicate") dataList = verbData;
          const item = dataList.find(item => item.ko === koText);
          if (item) {
            roSentence2 += item.ro + " ";
            enSentence2 += item.en + " ";
          } else {
            roSentence2 += koText + " ";
            enSentence2 += koText + " ";
          }
        });
        roSentence2 = roSentence2.trim();
        enSentence2 = enSentence2.trim();
        if (roSentence && roSentence2) {
          roSentence = roSentence + ", " + roSentence2;
          enSentence = enSentence + ", " + enSentence2;
        }
      }
      return roSentence;
    }
 
    // Model patterns for sentences (for random mode)
    const sentenceModels = [
      // Each model is an array of parts that should appear in the sentence, in order
      ["subject", "verb"],
      ["subject", "object", "verb"],
      ["subject", "place", "verb"],
      ["subject", "time", "verb"],
      ["subject", "time", "place", "verb"],
      ["subject", "place", "object", "verb"],
      ["subject", "time", "object", "verb"],
      ["subject", "mod", "verb"],
      ["subject", "mod", "object", "verb"],
      ["subject", "time", "mod", "verb"],
      ["subject", "time", "mod", "object", "verb"],
      ["subject", "place", "mod", "verb"],
      ["subject", "place", "mod", "object", "verb"],
      ["subject", "time", "place", "mod", "verb"],
      ["subject", "time", "place", "mod", "object", "verb"],
      // Models including numeral & counter for countable objects
      ["subject", "numeral", "counter", "object", "verb"],
      ["subject", "time", "numeral", "counter", "object", "verb"],
      ["subject", "place", "numeral", "counter", "object", "verb"],
      ["subject", "time", "place", "numeral", "counter", "object", "verb"],
      // If needed, can add more patterns (with mod, etc.)
    ];
    let currentModelIndex = 0;
 
    // Initialize builder with model 0
    buildSentenceParts(currentModelIndex);
    pageInfo.textContent = `Model ${currentModelIndex + 1}/${sentenceModels.length}`;
 
    // Event: toggle between modes (Simplu vs TOPIK)
    document.querySelectorAll(".small-mode-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll(".small-mode-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        const mode = btn.getAttribute("data-mode");
        if (mode === "simple") {
          document.body.classList.add("pastel-theme");
        } else {
          // For TOPIK mode, possibly different theme or functionalities (if implemented)
          document.body.classList.add("pastel-theme");
          // If we had a different theme for TOPIK, we could toggle here
        }
      });
    });
 
    // Event: toggle which parts are included (checkboxes)
    document.querySelectorAll(".part-toggles input").forEach(input => {
      input.addEventListener("change", () => {
        // Rebuild the sentence model parts list (free build mode)
        buildSentenceParts(null);
      });
    });
 
    // Event: Random sentence (free build mode)
    randomBtn.addEventListener("click", () => {
      // If currently in random model mode, pressing random could just regenerate using same model pattern
      if (currentModelIndex != null) {
        buildSentenceParts(currentModelIndex);
      } else {
        buildSentenceParts(null);
      }
    });
    // Event: Random sentence (model mode) - second random button
    randomBtn2.addEventListener("click", () => {
      buildSentenceParts(currentModelIndex);
    });
 
    // Event: Prev/Next model (for structured patterns)
    prevBtn.addEventListener("click", () => {
      currentModelIndex = (currentModelIndex - 1 + sentenceModels.length) % sentenceModels.length;
      buildSentenceParts(currentModelIndex);
      pageInfo.textContent = `Model ${currentModelIndex + 1}/${sentenceModels.length}`;
    });
    nextBtn.addEventListener("click", () => {
      currentModelIndex = (currentModelIndex + 1) % sentenceModels.length;
      buildSentenceParts(currentModelIndex);
      pageInfo.textContent = `Model ${currentModelIndex + 1}/${sentenceModels.length}`;
    });
 
    // Event: Enable/Disable sentence 2
    enableP2.addEventListener("change", () => {
      buildSentenceParts(currentModelIndex);
    });
 
    // Event: Speak Korean sentence (using Web Speech API if available)
    speakBtn.addEventListener("click", () => {
      if (!("speechSynthesis" in window)) {
        alert("Browserul nu suportƒÉ audio.");
        return;
      }
      const text = previewKo.textContent;
      if (!text || text.includes("alege cuvinte")) return;
      const utterance = new SpeechSynthesisUtterance(text);
      // Choose Korean voice if available
      const koVoice = speechSynthesis.getVoices().find(v => v.lang.startsWith("ko"));
      if (koVoice) utterance.voice = koVoice;
      utterance.lang = "ko-KR";
      speechSynthesis.speak(utterance);
    });
 
    // Event: Save sentence (add to favorites)
    favBtn.addEventListener("click", () => {
      const ko = previewKo.textContent.trim();
      let ro = previewRo.textContent.trim();
      if (!ko || ko.includes("alege cuvinte")) return;
      if (ro.startsWith("¬∑¬∑¬∑")) ro = "";
      const exists = favorites.some(f => f.ko === ko && f.ro === ro);
      if (!exists) favorites.push({ ko, ro });
      renderFavorites();
      favBtn.textContent = "‚≠ê Salvat!";
      setTimeout(() => { favBtn.textContent = "‚≠ê SalveazƒÉ propozi»õia"; }, 800);
    });
 
    // Event: Toggle translation visibility (hide/show translation text)
    toggleTranslationBtn.addEventListener("click", () => {
      const isHidden = previewRo.classList.toggle("hidden");
      toggleTranslationBtn.textContent = isHidden ? "AratƒÉ traducerea" : "Ascunde traducerea";
    });
 
    // Event: Copy Korean sentence to clipboard
    copyBtn.addEventListener("click", () => {
      const ko = previewKo.textContent.trim();
      if (!ko || ko.includes("alege cuvinte")) return;
      navigator.clipboard.writeText(ko).then(() => {
        copyBtn.textContent = "Copiat!";
        copyBtn.classList.add("active");
        setTimeout(() => {
          copyBtn.textContent = "Copiere";
          copyBtn.classList.remove("active");
        }, 1000);
      }).catch(err => console.warn("Clipboard copy failed:", err));
    });
 
    // Render favorites list in overlay
    function renderFavorites() {
      panelList.innerHTML = "";
      favorites.forEach((item, index) => {
        const li = document.createElement("li");
        li.className = "fav-item";
        const pKo = document.createElement("p");
        pKo.textContent = item.ko;
        const pRo = document.createElement("p");
        pRo.textContent = item.ro;
        pRo.className = "tr";
        const removeBtn = document.createElement("button");
        removeBtn.textContent = "√ó »òterge";
        removeBtn.className = "remove-btn";
        removeBtn.addEventListener("click", () => {
          favorites.splice(index, 1);
          renderFavorites();
        });
        li.appendChild(pKo);
        if (item.ro) li.appendChild(pRo);
        li.appendChild(removeBtn);
        panelList.appendChild(li);
      });
    }
 
    // Event: open favorites overlay when clicking "Salvate" (not explicitly present as separate button, but could open when saving)
    // Instead, let's open overlay on long press of save or something (not implemented fully here).
 
    // Overlay close & clear events
    closePanelBtn.addEventListener("click", () => {
      overlay.classList.remove("show");
    });
    clearFavBtn.addEventListener("click", () => {
      if (confirm("Sigur »ôterge»õi toate propozi»õiile salvate?")) {
        favorites = [];
        renderFavorites();
      }
    });
 
    // Event: Show overlay when saving a sentence (just to confirm save, optional)
    // We won't show overlay on each save to avoid annoyance.
 
    // Navigation between screens
    navButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        const target = btn.getAttribute("data-target");
        screens.forEach(scr => scr.classList.remove("active"));
        document.getElementById("screen-" + target).classList.add("active");
        navButtons.forEach(nb => nb.classList.remove("active"));
        btn.classList.add("active");
      });
    });
 
    // ===== EXERCI»öII TOPIK ‚Äì modul nou =====
    // Example exercise data (for demonstration; these could be loaded from a separate data source)
    const exercises = [
      {
        type: "word", // or 'syll' or 'sentence'
        question: "Ïßë",
        options: ["casƒÉ", "a veni", "bƒÉiat"],
        answer: "casƒÉ"
      },
      {
        type: "word",
        question: "Ïò§Îã§",
        options: ["a veni", "a se juca", "a alerga"],
        answer: "a veni"
      }
      // Additional exercises can be added here
    ];
    // Render exercises
    function renderExercises() {
      exercisesContainer.innerHTML = "";
      exercises.forEach((ex, idx) => {
        const card = document.createElement("div");
        card.className = "quest-card type-" + ex.type;
        const title = document.createElement("h3");
        title.textContent = `√éntrebarea ${idx + 1}`;
        const content = document.createElement("div");
        content.className = "quest-content";
        if (ex.type === "sentence") {
          // For sentence type, we might split into words and blank one
          const parts = ex.question.split("____");
          parts.forEach((part, i) => {
            const p = document.createElement("p");
            p.textContent = part;
            if (i < parts.length - 1) {
              // add blank
              const blank = document.createElement("p");
              blank.className = "blank";
              blank.textContent = "____";
              content.appendChild(p);
              content.appendChild(blank);
            } else {
              content.appendChild(p);
            }
          });
        } else {
          const p = document.createElement("p");
          p.textContent = ex.question;
          content.appendChild(p);
        }
        if (ex.type !== "sentence") {
          const opts = document.createElement("div");
          opts.className = "opts";
          ex.options.forEach(opt => {
            const btn = document.createElement("button");
            btn.textContent = opt;
            btn.addEventListener("click", () => {
              // Mark answer correctness
              if (opt === ex.answer) {
                btn.classList.add("correct");
              } else {
                btn.classList.add("wrong");
              }
              // Disable all buttons after answer
              opts.querySelectorAll("button").forEach(b => b.disabled = true);
            });
            opts.appendChild(btn);
          });
          content.appendChild(opts);
        }
        card.appendChild(title);
        card.appendChild(content);
        exercisesContainer.appendChild(card);
      });
    }
    renderExercises();
 
    // ===== GLOSAR (cƒÉutare) =====
    // Combine all data lists for glossary search
    const glossaryData = [
      ...subjectData, ...timeData, ...placeData, ...modData,
      ...objectData, ...numeralData, ...counterData, ...verbData
    ];
    // Event: search in glossary
    glossarySearch.addEventListener("input", () => {
      const query = glossarySearch.value.trim().toLowerCase();
      glossaryResults.innerHTML = "";
      if (!query) return;
      glossaryData.forEach(item => {
        if (item.ro.toLowerCase().includes(query) || item.en.toLowerCase().includes(query) || item.ko.includes(query)) {
          const div = document.createElement("div");
          div.className = "result-item";
          div.innerHTML = `<span>${item.ko}</span> ‚Äî ${item.ro} (${item.en})`;
          glossaryResults.appendChild(div);
        }
      });
    });
 
    // ===== LEC»öII (exemple integrate cu Builder) =====
    // Ex: Pentru butonul "√éncearcƒÉ √Æn Builder" la lec»õia 1:
    function addLessonExample(btnId, roSentence) {
      const btn = document.getElementById(btnId);
      if (!btn) return;
      btn.addEventListener("click", () => {
        // Parse the Romanian sentence and try to pre-select matching words in builder
        // (For simplicity, we'll just fill the builder fields randomly here)
        currentModelIndex = null;
        // Navigate to Builder screen
        screens.forEach(scr => scr.classList.remove("active"));
        screenBuilder.classList.add("active");
        navButtons.forEach(nb => nb.classList.remove("active"));
        document.querySelector('.nav-btn[data-target="builder"]').classList.add("active");
        // Example: directly call random sentence for now
        buildSentenceParts(null);
        // In a real scenario, we would analyze roSentence and attempt to find matching ko components in data lists,
        // then construct the sentence specifically. That would require a mapping of ro->ko per word, etc.
      });
    }
 
    // ConectƒÉm lec»õiile direct (scriptul este la finalul <body>, deci elementele existƒÉ)
    addLessonExample("lesson1TryBtn", "Azi am de √ÆnvƒÉ»õat multe cuvinte coreene.");
    // Future lesson buttons can be connected similarly:
    // addLessonExample("lesson2TryBtn", "...");
  </script>
</body>
</html>
