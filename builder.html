<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Raluca Korean – Builder FINAL</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body{
  *{box-sizing:border-box}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto;
  background:linear-gradient(120deg,#e8f0ff,#ffe9ff,#e9fff5);
  color:#2f343b;
}
.app{
  max-width:1100px;
  margin:0 auto;
  padding:16px 16px 80px;
}
.header{
  padding:16px;
  border-radius:24px;
  background:linear-gradient(120deg,#6fb8ff,#a774ff,#ff7fd1);
  color:#fff;
  box-shadow:0 18px 40px rgba(0,0,0,.25);
}
.header h1{margin:0;font-size:22px}
.header p{margin:6px 0 0;font-size:13px;opacity:.95}

.card{
  margin-top:16px;
  padding:16px;
  border-radius:22px;
  background:#ffffffcc;
  box-shadow:0 16px 32px rgba(0,0,0,.12);
}

textarea{
  width:100%;
  min-height:80px;
  padding:12px;
  border-radius:16px;
  border:1px solid #ddd;
  font-size:14px;
}

.actions{
  margin-top:10px;
  display:flex;
  gap:10px;
}
button{
  border:none;
  border-radius:999px;
  padding:8px 18px;
  font-weight:800;
  color:#fff;
  cursor:pointer;
  background:linear-gradient(135deg,#6b8cff,#9b6bff);
}
button.secondary{
  background:linear-gradient(135deg,#ff9a6c,#ff5f8c);
}

.table-block{
  margin-top:14px;
  padding:12px;
  border-radius:20px;
  background:#ffffffcc;
  box-shadow:0 14px 28px rgba(0,0,0,.12);
}

.table-title{
  font-weight:900;
  font-size:13px;
  margin-bottom:6px;
}

.table{
  display:flex;
  gap:8px;
  overflow-x:auto;
}

.col{
  min-width:120px;
  padding:8px;
  border-radius:16px;
  background:#fdfbf7;
  border:1px solid #e2d7c8;
}
.col-header{
  font-size:10px;
  font-weight:900;
  color:#7b5dff;
  margin-bottom:4px;
}
.col-body{
  min-height:1.6em;
  font-size:15px;
  font-weight:900;
}
.col-body[contenteditable]{
  outline:none;
}

.preview{
  margin-top:18px;
}
.sentence{
  font-size:24px;
  font-weight:900;
  margin-top:10px;
}
.polite{
  font-size:12px;
  font-weight:800;
}
  
</head>
</style>  
<body>
  <div class="app">

    <header class="header">
      <h1>Raluca Korean – Builder FINAL</h1>
      <p>Construcție propoziții coreene – multi-clause, particles corecte</p>
    </header>

    <!-- INPUT -->
    <section class="card">
      <textarea id="inputText"
        placeholder="Ex: Astăzi merg la cafenea și citesc o carte și beau o cafea."></textarea>
      <div class="actions">
        <button id="autoFill">Auto-fill</button>
        <button id="resetAll" class="secondary">Reset</button>
      </div>
    </section>

    <!-- CLAUSES -->
    <div id="clausesHost"></div>

    <!-- PREVIEW -->
    <section class="card preview">
      <label class="polite">
        <input type="checkbox" id="politeToggle">
        Politețe (doar ultima clauză)
      </label>
      <div id="previewSentence" class="sentence">저 가요</div>
    </section>

  </div>
 <script> 
  /* ======================================================
   RALUCA KOREAN – BUILDER.JS (FINAL)
   Logică identică cu „Bun tabel”
   ====================================================== */

(() => {
  "use strict";

  /* =========================
     UTILS HANGUL
  ========================= */
  function hasBatchim(ch) {
    if (!ch) return false;
    const c = ch.charCodeAt(ch.length - 1);
    if (c < 0xac00 || c > 0xd7a3) return false;
    return (c - 0xac00) % 28 !== 0;
  }

  function lastHangul(str) {
    const s = (str || "").trim();
    return s ? s[s.length - 1] : "";
  }

  /* =========================
     PARTICLE LOGIC
  ========================= */

  // 은/는 (topic)
  function subjectParticle(noun) {
    if (!noun) return "";
    return noun + (hasBatchim(lastHangul(noun)) ? "은" : "는");
  }

  // 을/를 (object)
  function objectParticle(noun) {
    if (!noun) return "";
    return noun + (hasBatchim(lastHangul(noun)) ? "을" : "를");
  }

  // 에 / 에서 (place)
  function placeParticle(place, verb) {
    if (!place) return "";
    if (verb === "가다" || verb === "오다") return place + "에";
    return place + "에서";
  }

  /* =========================
     VERB + ENDING
  ========================= */

  function attachEnding(verbInf, endingRaw) {
    if (!verbInf) return "";
    if (!endingRaw) return verbInf;

    let e = endingRaw.replace(/^[-~]/, "").trim();
    if (!verbInf.endsWith("다")) return verbInf;

    const stem = verbInf.slice(0, -1);
    const last = lastHangul(stem);
    const b = hasBatchim(last);

    if (e === "고") return stem + "고";
    if (e === "지만") return stem + "지만";
    if (e === "아서" || e === "어서") return stem + e;
    if (e === "(으)면") return stem + (b ? "으면" : "면");
    if (e === "(으)려고") return stem + (b ? "으려고" : "려고");
    if (e === "(으)ㄹ 때") return stem + (b ? "을 때" : "ㄹ 때");

    return stem + e;
  }

  function politePresent(verbInf) {
    if (!verbInf || !verbInf.endsWith("다")) return verbInf;
    const stem = verbInf.slice(0, -1);
    const last = lastHangul(stem);

    if (stem.endsWith("하")) return stem.slice(0, -1) + "해요";

    const code = last.charCodeAt(0);
    const jung = Math.floor(((code - 0xac00) % (21 * 28)) / 28);
    const aGroup = [0, 2, 8, 9];
    return stem + (aGroup.includes(jung) ? "아요" : "어요");
  }

  /* =========================
     DOM HELPERS
  ========================= */

  function cell(idx, key) {
    return document.querySelector(
      `[data-clause-index="${idx}"] .col[data-key="${key}"] .col-body-main`
    );
  }

  function val(idx, key) {
    const c = cell(idx, key);
    return c ? c.textContent.trim() : "";
  }

  /* =========================
     BUILD CLAUSE
  ========================= */

  function buildClause(idx, isLast, polite) {
    const subj = val(idx, "subject");
    const time = val(idx, "time");
    const place = val(idx, "place");
    const mod = val(idx, "mod");
    const obj = val(idx, "object");
    const num = val(idx, "numeral");
    const ctr = val(idx, "counter");
    const verb = val(idx, "verb");
    const conj = val(idx, "conj");

    const parts = [];

    if (subj) parts.push(subjectParticle(subj));
    if (time) parts.push(time);
    if (place) parts.push(placeParticle(place, verb));
    if (mod) parts.push(mod);

    if (obj && num && ctr) parts.push(`${objParticle(obj)} ${num}${ctr}`);
    else if (obj) parts.push(objectParticle(obj));

    let verbOut = attachEnding(verb, conj);
    if (polite && isLast && !conj) verbOut = politePresent(verb);

    if (verbOut) parts.push(verbOut);

    return parts.join(" ").trim();
  }

  /* =========================
     PREVIEW
  ========================= */

  function rebuildPreview() {
    const clauses = document.querySelectorAll("[data-clause-index]");
    const polite = document.getElementById("politeToggle")?.checked;
    const out = [];

    clauses.forEach((_, i) => {
      const text = buildClause(i, i === clauses.length - 1, polite);
      if (text) out.push(text);
    });

    document.getElementById("previewSentence").textContent =
      out.join(" ") || "저는 가요";
  }

  /* =========================
     LIVE
  ========================= */

  document.addEventListener("input", e => {
    if (e.target.classList.contains("col-body-main")) rebuildPreview();
  });

  document.getElementById("politeToggle")
    ?.addEventListener("change", rebuildPreview);

  window.addEventListener("DOMContentLoaded", rebuildPreview);
})();  
</script>
</body>
</html>
