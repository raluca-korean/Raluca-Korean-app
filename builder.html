<!DOCTYPE html>
<html lang="ro">  <!-- Romanian interface language -->
<head>
  <meta charset="UTF-8" />
  <title>Raluca Korean ‚Äì Builder (Reconstruire)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* --- Pastel Background and Base Styles --- */
    :root {
      --bg1: #dff3ff;
      --bg2: #ffe9ff;
      --bg3: #f4fffc;
      --bg4: #e8f0ff;
      --accent: #7b5dff;
      --card-bg: #ffffffcc;
      --text-main: #2f343b;
      --text-soft: #7a8088;
      --border: #e1d7c7;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--text-main);
      background: linear-gradient(120deg, var(--bg1), var(--bg2), var(--bg3), var(--bg4));
      background-size: 380% 380%;
      animation: bgFlow 28s ease-in-out infinite;
    }
    @keyframes bgFlow {
      0% { background-position: 0% 50%; }
      50%{ background-position: 100% 50%; }
      100%{ background-position: 0% 50%; }
    }
    .app {
      max-width: 1040px;
      margin: 0 auto;
      padding: 18px 14px 80px;
    }
    /* Header styling */
    .rk-header {
      padding: 12px 16px 16px;
      border-radius: 26px;
      background: linear-gradient(120deg, #6fb8ff, #a774ff, #ff7fd1);
      color: #fff;
      box-shadow: 0 18px 45px rgba(77,93,255,0.4);
      margin-bottom: 16px;
    }
    .rk-header-main { 
      display: flex; justify-content: space-between; align-items: center; gap: 10px;
    }
    .rk-header-main h1 {
      margin: 0; font-size: 20px; font-weight: 900;
      letter-spacing: 0.06em; text-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    .rk-badge {
      background: rgba(255,255,255,0.3);
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
    }
    #subtitle {
      margin: 4px 0 0;
      font-size: 12px;
      opacity: 0.9;
    }

    /* Section titles */
    .section-title {
      font-size: 16px;
      font-weight: 700;
      margin: 20px 0 8px;
      color: var(--text-main);
    }

    /* Input and button controls for auto-fill */
    .input-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
    }
    .input-row input[type="text"] {
      flex: 1;
      min-width: 250px;
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 13px;
    }
    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      transition: background 0.2s;
    }
    button.primary { 
      background: var(--accent);
      color: #fff;
    }
    button.secondary {
      background: #ffffff99;
      color: var(--text-main);
    }
    button:hover { opacity: 0.9; }

    .hint {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
    }

    /* Table (columns) styling */
    .clauses {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .table-horizontal {
      display: flex;
      gap: 6px;
      overflow-x: auto;
      padding-bottom: 8px;
      margin-bottom: 12px;
    }
    .table-horizontal::-webkit-scrollbar {
      height: 8px;
    }
    .table-horizontal::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }
    .col {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      flex: none;
      width: 150px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    .col-header {
      background: var(--dimmed-bg, #f2eefc);
      text-align: center;
      font-size: 13px;
      font-weight: 700;
      padding: 6px 8px;
      border-bottom: 1px solid var(--border);
      position: relative;
    }
    /* Icons for headers based on data-key attribute */
    .col[data-key="subject"] .col-header::before  { content: "üë§"; position: absolute; left: 8px; }
    .col[data-key="time"] .col-header::before     { content: "‚è∞"; position: absolute; left: 8px; }
    .col[data-key="place"] .col-header::before    { content: "üìç"; position: absolute; left: 8px; }
    .col[data-key="mod"] .col-header::before      { content: "‚ú®"; position: absolute; left: 8px; }
    .col[data-key="object"] .col-header::before   { content: "üéØ"; position: absolute; left: 8px; }
    .col[data-key="numeral"] .col-header::before  { content: "#Ô∏è‚É£"; position: absolute; left: 8px; }
    .col[data-key="counter"] .col-header::before  { content: "üî¢"; position: absolute; left: 8px; }

    .col-body {
      padding: 4px;
      flex: 1;
      overflow-y: auto;
    }
    .col-body::-webkit-scrollbar {
      width: 6px;
    }
    .col-body::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }
    .item {
      display: block;
      width: 100%;
      padding: 6px 8px;
      margin: 2px 0;
      font-size: 13px;
      text-align: center;
      border-radius: 8px;
      border: 1px solid transparent;
      background: #fff;
      color: var(--text-main);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .item:hover {
      background: #eaeaea;
    }
    .item.selected {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    /* Preview card (output) styling */
    .preview-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 12px 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      margin-top: 8px;
    }
    .output-ko {
      font-size: 18px;
      font-weight: 600;
      margin: 0 0 8px;
      color: #000;
    }
    .output-trans {
      font-size: 14px;
      margin: 0;
      color: var(--text-main);
    }
    .output-trans.hidden {
      display: none;
    }
    .lang-select {
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
    }
    .lang-select select {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 12px;
    }

    /* Politeness toggle */
    .toggle-row {
      margin: 4px 0 8px;
      font-size: 13px;
    }
    .toggle-row label {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      user-select: none;
    }
    .toggle-row input[type="checkbox"] {
      transform: scale(1.2);
      accent-color: var(--accent);
      cursor: pointer;
    }
  </style>
</head>
<body>
<div class="app">
  
  <!-- Header -->
  <div class="rk-header">
    <div class="rk-header-main">
      <h1>RALUCA KOREAN</h1>
      <span class="rk-badge">Builder ‚Äì Modular</span>
    </div>
    <p id="subtitle">Construie»ôte propozi»õii coreene din elemente date</p>
  </div>

  <!-- Auto-fill input and controls -->
  <h3 class="section-title">Introdu propozi»õia</h3>
  <div class="input-row">
    <input id="inputText" type="text" placeholder="Ex: AstƒÉzi merg la cafenea »ôi citesc o carte »ôi beau o cafea. 
Today I go to the cafe and read a book and drink a coffee." />
    <div class="btn-row">
      <button id="autoFillBtn" class="primary">CompleteazƒÉ automat builder-ul</button>
      <button id="clearBtn" class="secondary">CurƒÉ»õƒÉ tot</button>
    </div>
  </div>
  <div class="hint">
    *Introduce»õi o propozi»õie √Æn rom√¢nƒÉ sau englezƒÉ »ôi apƒÉsa»õi "CompleteazƒÉ automat" pentru a popula tabelul.*
  </div>

  <!-- Builder table (clauses) -->
  <h3 class="section-title">Builder (clauze)</h3>
  <div id="clausesHost" class="clauses">
    <!-- Clause tables will be inserted here by script -->
  </div>
  <div class="toggle-row">
    <label>
      <input type="checkbox" id="secondClauseToggle" />
      <span>Propozi»õie secundarƒÉ</span>
    </label>
    <label style="margin-left:16px;">
      <input type="checkbox" id="politeToggle" checked />
      <span>Polite»õe (doar ultima clauzƒÉ)</span>
    </label>
  </div>

  <!-- Output preview and controls -->
  <div class="preview-card">
    <p id="koOutput" class="output-ko"></p>
    <p id="trOutput" class="output-trans"></p>
    <div class="lang-select">
      <span>Limba propozi»õiei:</span>
      <select id="langSelect">
        <option value="ro" selected>Rom√¢nƒÉ</option>
        <option value="en">English</option>
      </select>
    </div>
    <div class="btn-row" style="margin-top: 10px;">
      <button id="prevBtn" class="secondary">‚Üê Propozi»õia anterioarƒÉ</button>
      <button id="nextBtn" class="secondary">UrmƒÉtoarea propozi»õie ‚Üí</button>
      <button id="randomBtn" class="primary">Random propozi»õie</button>
      <button id="ttsBtn" class="primary">Audio coreeanƒÉ üîä</button>
      <button id="saveBtn" class="secondary">SalveazƒÉ propozi»õia</button>
      <button id="toggleTransBtn" class="secondary">Ascunde traducerea</button>
    </div>
  </div>

</div>  <!-- /.app container -->

<script>
(function () {
  "use strict";

  // =========================
  // 1) Data Definitions 
  // =========================
  // Predefined vocabulary and mapping rules for categories:
  const dataMap = {
    subject: [
      { re: /\b(eu)\b/i, value: "Ï†ÄÎäî", trans: "Eu" },
      { re: /\b(tu)\b/i, value: "ÎÑàÎäî", trans: "Tu" },
      { re: /\b(noi)\b/i, value: "Ïö∞Î¶¨Îäî", trans: "Noi" },
      // Optionally one can add "el/ea" etc. but omitted for simplicity
    ],
    time: [
      { re: /\b(azi|astƒÉzi)\b/i, value: "Ïò§Îäò", trans: "astƒÉzi" },
      { re: /\b(m√¢ine)\b/i, value: "ÎÇ¥Ïùº", trans: "m√¢ine" },
      { re: /\b(ieri)\b/i, value: "Ïñ¥Ï†ú", trans: "ieri" },
      { re: /\b(acum)\b/i, value: "ÏßÄÍ∏à", trans: "acum" }
    ],
    place: [
      { re: /\b(cafenea|cafe)\b/i, value: "Ïπ¥ÌéòÏóê", trans: "la cafenea" },
      { re: /\b(acasƒÉ|acasa)\b/i, value: "ÏßëÏóêÏÑú", trans: "acasƒÉ" },
      { re: /\b(»ôcoalƒÉ|scoala)\b/i, value: "ÌïôÍµêÏóêÏÑú", trans: "la »ôcoalƒÉ" },
      { re: /\b(serviciu|firmƒÉ|firma|companie)\b/i, value: "ÌöåÏÇ¨ÏóêÏÑú", trans: "la serviciu" },
      { re: /\b(magazin|supermarket)\b/i, value: "ÎßàÌä∏ÏóêÏÑú", trans: "la magazin" }
    ],
    mod: [
      { re: /\b(bine|ok)\b/i, value: "Ïûò", trans: "bine" },
      { re: /\b(√Æncet|incet)\b/i, value: "Ï≤úÏ≤úÌûà", trans: "√Æncet" },
      { re: /\b(repe(de)?|rapid)\b/i, value: "Îπ®Î¶¨", trans: "repede" },
      { re: /\b(mult)\b/i, value: "ÎßéÏù¥", trans: "mult" }
    ],
    object: [
      { re: /\b(carte|cƒÉr»õi|carti)\b/i, value: "Ï±Ö", trans: "carte" },
      { re: /\b(cafea)\b/i, value: "Ïª§Ìîº", trans: "cafea" },
      { re: /\b(apƒÉ|apa)\b/i, value: "Î¨º", trans: "apƒÉ" },
      { re: /\b(ceai)\b/i, value: "Ï∞®", trans: "ceai" },
      { re: /\b(m√¢ncare|mancare|pr√¢nz|pranz|cinƒÉ|cina|mic\s+dejun)\b/i, value: "ÏùåÏãù", trans: "m√¢ncare" }
    ],
    numeral: [
      { re: /\b(o)\s+\w+/i, value: "Ìïú", trans: "o" },   // "o" before a noun (assuming feminine form) 
      { re: /\b(una|un)\b/i, value: "Ìïú", trans: "un/una" }, // generic one
      { re: /\b(douƒÉ|doua)\b/i, value: "Îëê", trans: "douƒÉ" },
      { re: /\b(trei)\b/i, value: "ÏÑ∏", trans: "trei" }
      // (We can extend to 4,5... if needed)
    ],
    counter: [
      { re: /\b(carte|cƒÉr»õi|carti)\b/i, value: "Í∂å", trans: " (cƒÉr»õi)" },  // counter for books
      { re: /\b(cafea|apƒÉ|apa|ceai|m√¢ncare|mancare)\b/i, value: "Í∞ú", trans: " (bucƒÉ»õi)" }  // general counter
    ],
    verb: [
      { re: /\b(merg)\b|a\s+merge|sƒÉ\s+merg/i, value: "Í∞ÄÎã§", trans: "merg" },
      { re: /\b(vin)\b|a\s+veni|sƒÉ\s+vin/i, value: "Ïò§Îã§", trans: "vin" },
      { re: /\b(mƒÉn√¢nc|mananc)\b|a\s+m√¢nca|a\s+manca/i, value: "Î®πÎã§", trans: "mƒÉn√¢nc" },
      { re: /\b(beau)\b|a\s+bea|sƒÉ\s+beau/i, value: "ÎßàÏãúÎã§", trans: "beau" },
      { re: /\b(citesc)\b|a\s+citi|sƒÉ\s+citesc/i, value: "ÏùΩÎã§", trans: "citesc" },
      { re: /\b(lucrez)\b|a\s+lucra/i, value: "ÏùºÌïòÎã§", trans: "lucrez" }
      // Additional verbs can be added here
    ]
  };

  // The above dataMap provides:
  // - value: the Korean word (with appropriate particle, if fixed)
  // - trans: the Romanian word or phrase for translation
  // Note: Some Korean values already include particles (e.g., "Ïπ¥ÌéòÏóê" includes locative "Ïóê").
  // This is a simplification; a more advanced logic might add particles dynamically.

  // Example model sentences (each model defines selections for one or two clauses):
  const exampleModels = [
    { // Model 1: "Eu merg la cafenea."
      clause1: { subject:"Ï†ÄÎäî", time:"Ïò§Îäò", place:"Ïπ¥ÌéòÏóê", mod:"", object:"", numeral:"", counter:"", verbOverride:"Í∞ÄÏöî" },
      clause2: null,
      polite: true,
      translation_ro: "Eu astƒÉzi merg la cafenea.",
      translation_en: "Today I go to the cafe."
    },
    { // Model 2: "Eu mƒÉn√¢nc o cafea (beau o cafea)."
      clause1: { subject:"Ï†ÄÎäî", time:"", place:"", mod:"", object:"Ïª§Ìîº", numeral:"Ìïú", counter:"Í∞ú", verbOverride:"ÎßàÏÖîÏöî" },
      clause2: null,
      polite: true,
      translation_ro: "Eu beau o cafea.",
      translation_en: "I drink a coffee."
    },
    { // Model 3: "Noi m√¢ncƒÉm multƒÉ m√¢ncare acasƒÉ."
      clause1: { subject:"Ïö∞Î¶¨Îäî", time:"", place:"ÏßëÏóêÏÑú", mod:"ÎßéÏù¥", object:"ÏùåÏãù", numeral:"", counter:"", verbOverride:"Î®πÏñ¥Ïöî" },
      clause2: null,
      polite: true,
      translation_ro: "Noi m√¢ncƒÉm multƒÉ m√¢ncare acasƒÉ.",
      translation_en: "We eat a lot of food at home."
    },
    { // Model 4: "AstƒÉzi merg la serviciu »ôi citesc o carte."
      clause1: { subject:"Ï†ÄÎäî", time:"Ïò§Îäò", place:"ÌöåÏÇ¨ÏóêÏÑú", mod:"", object:"", numeral:"", counter:"", verbOverride:"Í∞ÄÍ≥†" }, // using connective form for clause1 verb
      clause2: { subject:"", time:"", place:"", mod:"", object:"Ï±Ö", numeral:"Ìïú", counter:"Í∂å", verbOverride:"ÏùΩÏñ¥Ïöî" },
      polite: true,
      translation_ro: "AstƒÉzi merg la serviciu »ôi citesc o carte.",
      translation_en: "Today I go to the office and read a book."
    }
  ];
  let currentModelIndex = -1;  // index for prev/next navigation

  // Utility: list of categories for easy iteration (excluding verb which is handled contextually)
  const categories = ["subject", "time", "place", "mod", "object", "numeral", "counter"];

  // =========================
  // 2) DOM Elements 
  // =========================
  const inputText = document.getElementById('inputText');
  const clausesHost = document.getElementById('clausesHost');
  const secondClauseToggle = document.getElementById('secondClauseToggle');
  const politeToggle = document.getElementById('politeToggle');
  const koOutput = document.getElementById('koOutput');
  const trOutput = document.getElementById('trOutput');
  const langSelect = document.getElementById('langSelect');
  const autoFillBtn = document.getElementById('autoFillBtn');
  const clearBtn = document.getElementById('clearBtn');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const randomBtn = document.getElementById('randomBtn');
  const ttsBtn = document.getElementById('ttsBtn');
  const saveBtn = document.getElementById('saveBtn');
  const toggleTransBtn = document.getElementById('toggleTransBtn');

  // We'll generate clause HTML blocks and maintain references to selection items.
  let clauseElements = [];  // to store the DOM elements of clauses for easy access
  let selections = {
    clause1: { subject:"", time:"", place:"", mod:"", object:"", numeral:"", counter:"" },
    clause2: { subject:"", time:"", place:"", mod:"", object:"", numeral:"", counter:"" }
  };

  // =========================
  // 3) UI Generation Functions 
  // =========================
  // Function to create one column (category block) HTML string
  function createColumnHTML(catKey, catLabel, exampleHint) {
    // Build each item in list as a div.button with text (using dataMap for values)
    let itemsHTML = "";
    const dataList = dataMap[catKey] || [];
    // For selection UI, we'll use Korean value for display if available, or a placeholder
    dataList.forEach(entry => {
      // Use Korean value as display if it's not empty
      const displayText = entry.value ? entry.value.replace(/(~Ïöî|Ïöî|Îã§)$/,"") : "(‚Äî)";
      // ^ we strip any trailing verb endings or particles for display clarity
      itemsHTML += `<div class="item" data-cat="${catKey}" data-val="${entry.value}" data-trans="${entry.trans}">${displayText || "‚Äî"}</div>`;
    });
    // If the category can be empty (optional), add a blank item option to deselect
    itemsHTML += `<div class="item" data-cat="${catKey}" data-val="" data-trans=""">(niciunul)</div>`;
    return `
      <div class="col" data-key="${catKey}">
        <div class="col-header">${catLabel}</div>
        <div class="col-body">
          ${itemsHTML}
        </div>
      </div>
    `;
  }

  // Function to generate the two clause tables based on current secondClauseToggle
  function renderClauses() {
    clausesHost.innerHTML = "";  // clear
    clauseElements = [];
    // Always render clause1
    clausesHost.innerHTML += `<div id="clause1" class="table-horizontal"></div>`;
    clauseElements.push(document.getElementById('clause1'));
    clauseElements[0].innerHTML = 
      createColumnHTML("subject","SUBJECT") +
      createColumnHTML("time","TIME") +
      createColumnHTML("place","PLACE") +
      createColumnHTML("mod","MOD") +
      createColumnHTML("object","OBJECT") +
      createColumnHTML("numeral","NUMERAL") +
      createColumnHTML("counter","COUNTER");
    // Render clause2 if enabled
    if (secondClauseToggle.checked) {
      clausesHost.innerHTML += `<div id="clause2" class="table-horizontal"></div>`;
      clauseElements.push(document.getElementById('clause2'));
      clauseElements[1].innerHTML = 
        createColumnHTML("subject","SUBJECT") +
        createColumnHTML("time","TIME") +
        createColumnHTML("place","PLACE") +
        createColumnHTML("mod","MOD") +
        createColumnHTML("object","OBJECT") +
        createColumnHTML("numeral","NUMERAL") +
        createColumnHTML("counter","COUNTER");
    }
    // After rendering, attach event listeners to all items for selection:
    document.querySelectorAll('.item').forEach(itemEl => {
      itemEl.addEventListener('click', () => onSelectItem(itemEl));
    });
  }

  // Initialize clauses on page load:
  renderClauses();

  // =========================
  // 4) Sentence Assembly 
  // =========================
  function updateSentenceOutput() {
    // This function reads current selections and constructs:
    // - The Korean sentence (combined clauses if any)
    // - The Romanian/English translation based on langSelect
    let koSentence = "";
    let roSentence = "";
    let enSentence = "";

    // Helper function to construct one clause's sentence
    function constructClause(sel, isLastClause) {
      // Determine verb based on context:
      let verbKor = "";
      let verbTransRo = "";
      let verbTransEn = "";

      // If a specific verb override is provided (from example model), use that
      if (sel.verbOverride) {
        // verbOverride expected to be a conjugated Korean verb form (e.g. Í∞ÄÏöî, Î®πÏñ¥Ïöî, Í∞ÄÍ≥†)
        verbKor = sel.verbOverride;
        // For translation, find the base verb in dataMap to get ro and en (approximate)
        const baseKor = sel.verbOverride.replace(/Ïöî|Í≥†$/, "Îã§");  // approximate root
        const verbEntry = dataMap.verb.find(v => v.value === baseKor);
        if (verbEntry) {
          verbTransRo = verbEntry.trans;
          // For English, do a simple mapping:
          const engMap = { "merg":"go", "vin":"come", "mƒÉn√¢nc":"eat", "beau":"drink", "citesc":"read", "lucrez":"work" };
          verbTransEn = engMap[verbEntry.trans] || verbEntry.trans;
          if (!isLastClause && verbKor.endsWith("Í≥†")) {
            // If not last clause and ends with Í≥† (and), add "»ôi" or "and"
            verbTransRo += " »ôi";
            verbTransEn += " and";
          }
        }
      } else {
        // Determine verb if not explicitly set:
        if (sel.object) {
          // if object exists, choose verb based on object
          if (sel.object === "Ï±Ö") { verbKor = isLastClause? "ÏùΩÏñ¥Ïöî" : "ÏùΩÍ≥†"; verbTransRo = "citesc"; verbTransEn = "read"; }
          else if (sel.object === "Ïª§Ìîº" || sel.object === "Î¨º" || sel.object === "Ï∞®") { verbKor = isLastClause? "ÎßàÏÖîÏöî" : "ÎßàÏãúÍ≥†"; verbTransRo = "beau"; verbTransEn = "drink"; }
          else if (sel.object === "ÏùåÏãù") { verbKor = isLastClause? "Î®πÏñ¥Ïöî" : "Î®πÍ≥†"; verbTransRo = "mƒÉn√¢nc"; verbTransEn = "eat"; }
          else { verbKor = isLastClause? "Ìï¥Ïöî" : "ÌïòÍ≥†"; verbTransRo = "fac"; verbTransEn = "do"; } // generic fallback
        } else if (sel.place) {
          // if only place (no object), use 'go' or 'am/is at' depending on context
          verbKor = isLastClause? "Í∞ÄÏöî" : "Í∞ÄÍ≥†";
          verbTransRo = "merg";
          verbTransEn = "go";
        } else {
          // if no object or place (just subject/time/mod), use a generic verb "do"
          verbKor = isLastClause? "Ìï¥Ïöî" : "ÌïòÍ≥†";
          verbTransRo = "fac";
          verbTransEn = "do";
        }
      }

      // Politeness: if politeToggle is off, use informal endings (we can simply drop Ïöî for simplicity)
      if (!politeToggle.checked) {
        // Remove 'Ïöî' polite endings for last clause
        verbKor = verbKor.replace(/Ïöî$/, "");
      }

      // Build Korean clause:
      // subject + time + place + object + (numeral+counter) + verb
      const subjectKor = sel.subject || ""; 
      const timeKor = sel.time || ""; 
      const placeKor = sel.place || ""; 
      let objectKor = sel.object || "";
      if (sel.numeral && sel.counter) {
        // if numeral and counter are present with object, combine them (e.g., "Ïª§Ìîº Ìïú Í∞ú")
        objectKor = objectKor + (sel.numeral ? " " + sel.numeral : "") + (sel.counter ? " " + sel.counter : "");
      }
      // If object exists but no numeral, add object particle (ÏùÑ/Î•º) appropriately:
      if (sel.object && !sel.numeral && !sel.counter) {
        // Add object particle: use Î•º if last char has vowel, ÏùÑ if consonant
        const lastCharCode = sel.object.charCodeAt(sel.object.length-1);
        const hasBatchim = (lastCharCode - 0xAC00) % 28 !== 0;
        objectKor = sel.object + (hasBatchim ? "ÏùÑ" : "Î•º");
      }
      // Compose clause Korean:
      const clauseKor = [subjectKor, timeKor, placeKor, objectKor, verbKor].filter(Boolean).join(" ");
      
      // Build Romanian clause (approximate literal translation):
      const subjectRo = sel.subject ? (dataMap.subject.find(e=>e.value===sel.subject)?.trans || "") : "";
      const timeRo = sel.time ? (dataMap.time.find(e=>e.value===sel.time)?.trans || "") : "";
      const placeRo = sel.place ? (dataMap.place.find(e=>e.value===sel.place)?.trans || "") : "";
      const modRo = sel.mod ? (dataMap.mod.find(e=>e.value===sel.mod)?.trans || "") : "";
      const objectRo = sel.object ? (dataMap.object.find(e=>e.value===sel.object)?.trans || "") : "";
      const numeralRo = sel.numeral ? (dataMap.numeral.find(e=>e.value===sel.numeral)?.trans || "") : "";
      let counterRo = "";
      if (sel.counter) {
        // for translation, we might just add generic word or plural form
        counterRo = sel.counter === "Í∂å" ? (objectRo ? (objectRo.endsWith("e")?" de":"") + " cƒÉr»õi" : " de cƒÉr»õi")
                  : sel.counter === "Í∞ú" ? " (buc)" : "";
        // The trans in dataMap.counter includes a hint (like "(cƒÉr»õi)" or "(bucƒÉ»õi)")
        const counterEntry = dataMap.counter.find(e=>e.value===sel.counter);
        if(counterEntry) counterRo = counterEntry.trans;
      }
      // Romanian clause assembly:
      let clauseRo = [subjectRo, timeRo, placeRo, modRo, (numeralRo ? numeralRo : ""), objectRo + counterRo, verbTransRo].filter(Boolean).join(" ").trim();
      // Clean up double spaces or dangling particles:
      clauseRo = clauseRo.replace(/\s+/g, " ");
      if (!isLastClause && clauseRo) clauseRo += " »ôi";  // add conjunction '»ôi' if it's not last clause
      
      // English clause assembly (similar approach):
      const subjectEn = sel.subject ? (sel.subject === "Ï†ÄÎäî" || sel.subject === "Ïö∞Î¶¨Îäî" ? "I/we" : "you") : ""; // simplistic
      const timeEn = sel.time ? (dataMap.time.find(e=>e.value===sel.time)?.trans || "") : "";
      const placeEn = sel.place ? (dataMap.place.find(e=>e.value===sel.place)?.trans || "").replace(/^la\s+/, "to ") : "";
      const modEn = sel.mod ? (dataMap.mod.find(e=>e.value===sel.mod)?.trans || "") : "";
      const objectEn = sel.object ? (dataMap.object.find(e=>e.value===sel.object)?.trans || "") : "";
      const numeralEn = sel.numeral ? (sel.numeral === "Ìïú" ? "one" : sel.numeral === "Îëê" ? "two" : sel.numeral === "ÏÑ∏" ? "three" : "") : "";
      let clauseEn = [subjectEn, timeEn, (sel.place ? "to" : ""), placeEn, modEn, numeralEn, objectEn, verbTransEn].filter(Boolean).join(" ").trim();
      if (!isLastClause && clauseEn) clauseEn += " and";

      return { ko: clauseKor, ro: clauseRo, en: clauseEn };
    }

    // Construct clause1 (always exists)
    const clause1Result = constructClause(selections.clause1, (!secondClauseToggle.checked));
    koSentence += clause1Result.ko;
    roSentence += clause1Result.ro;
    enSentence += clause1Result.en;
    // Construct clause2 if active
    if (secondClauseToggle.checked) {
      const clause2Result = constructClause(selections.clause2, true);
      // join with space (already added '»ôi/and' in clause1 if needed)
      koSentence += (koSentence && clause2Result.ko ? " " : "") + clause2Result.ko;
      roSentence += (roSentence && clause2Result.ro ? " " : "") + clause2Result.ro;
      enSentence += (enSentence && clause2Result.en ? " " : "") + clause2Result.en;
    }

    // Update outputs on page
    koOutput.textContent = koSentence;
    // Choose translation based on selection
    trOutput.textContent = (langSelect.value === "en") ? enSentence : roSentence;
  }

  // Selection handler for when a user clicks a word in a category column
  function onSelectItem(itemEl) {
    const cat = itemEl.getAttribute('data-cat');
    const val = itemEl.getAttribute('data-val');
    const trans = itemEl.getAttribute('data-trans');
    const clauseIndex = itemEl.closest('.table-horizontal').id === "clause1" ? 1 : 2;
    const clauseKey = clauseIndex === 1 ? 'clause1' : 'clause2';

    // Toggle selection: if already selected, deselect it.
    // Deselect other items in same category (within same clause)
    const clauseElem = clauseIndex === 1 ? clauseElements[0] : clauseElements[1];
    clauseElem.querySelectorAll(`.item[data-cat="${cat}"]`).forEach(elem => {
      elem.classList.remove('selected');
    });
    if (selections[clauseKey][cat] === val) {
      // if clicking the already selected value, we deselect it (toggle off)
      selections[clauseKey][cat] = "";
      // No item will be selected in UI for this category (all removed above)
    } else {
      // select new item
      itemEl.classList.add('selected');
      selections[clauseKey][cat] = val;
    }
    // Whenever a selection changes, we recalc the sentence
    updateSentenceOutput();
  }

  // =========================
  // 5) Auto-Fill (Parse input sentence)
  // =========================
  function autoFillBuilder(sentence) {
    if (!sentence) return;
    // Reset current selections
    selections.clause1 = { subject:"", time:"", place:"", mod:"", object:"", numeral:"", counter:"" };
    selections.clause2 = { subject:"", time:"", place:"", mod:"", object:"", numeral:"", counter:"" };
    // Lowercase for matching (keep original for output as needed)
    let text = sentence.trim();
    const textLower = text.toLowerCase();

    // Decide if there's a second clause (we'll split on common conjunctions like ' »ôi ' or ' and ')
    let parts = textLower.split(/\s+\w+\s+(?:»ôi|and)\s+/i);
    if (parts.length > 1) {
      secondClauseToggle.checked = true;
      renderClauses();  // re-render to ensure clause2 exists
      // After re-render, re-bind the item click events:
      document.querySelectorAll('.item').forEach(itemEl => {
        itemEl.addEventListener('click', () => onSelectItem(itemEl));
      });
    } else {
      secondClauseToggle.checked = false;
      renderClauses();
      document.querySelectorAll('.item').forEach(itemEl => {
        itemEl.addEventListener('click', () => onSelectItem(itemEl));
      });
    }
    // Recompute parts after toggling second clause
    parts = textLower.split(/\s+\w+\s+(?:»ôi|and)\s+/i);
    const part1 = parts[0] || textLower;
    const part2 = parts[1] || "";

    // Helper to fill one clause from a text part
    function fillClauseFromText(clauseKey, textPart) {
      // Iterate each category (except counter and verb, as counter depends on object and verb we infer)
      categories.forEach(catKey => {
        if (catKey === 'counter') return;  // skip counter in initial pass
        const entries = dataMap[catKey];
        for (let entry of entries) {
          if (entry.re.test(textPart)) {
            // If category is place, we might have "la <place>" in Romanian which was included in trans
            selections[clauseKey][catKey] = entry.value;
            // If we matched an object, we should also assign a counter if available for that object
            if (catKey === "object") {
              // find matching counter
              const counterEntry = dataMap.counter.find(c => c.re.test(textPart));
              if (counterEntry) {
                selections[clauseKey].counter = counterEntry.value;
              }
            }
            break;
          }
        }
      });
      // Subject: if none found in text but sentence likely has an implicit subject (like omitted "eu"), we default to "Ï†ÄÎäî"
      if (!selections[clauseKey].subject) {
        if (/(?:eu|tu|noi|el|ea)\b/i.test(textPart)) {
          // if some known pronoun is there but didn't match (due to regex requiring word boundary), try direct match
          if (/\beu\b/i.test(textPart)) selections[clauseKey].subject = "Ï†ÄÎäî";
          else if (/\btu\b/i.test(textPart)) selections[clauseKey].subject = "ÎÑàÎäî";
          else if (/\bnoi\b/i.test(textPart)) selections[clauseKey].subject = "Ïö∞Î¶¨Îäî";
        } else {
          // default to "Ï†ÄÎäî" if completely missing (assuming first person by default)
          selections[clauseKey].subject = "Ï†ÄÎäî";
        }
      }
    }

    fillClauseFromText('clause1', part1);
    if (secondClauseToggle.checked && part2) {
      fillClauseFromText('clause2', part2);
      // For clause2, if subject was not explicitly in second clause, we leave subject empty (it can be omitted in translation)
    }

    // After filling selections, update UI highlight:
    clauseElements.forEach((clauseEl, index) => {
      const ck = index === 0 ? 'clause1' : 'clause2';
      categories.forEach(catKey => {
        const val = selections[ck][catKey];
        if (val) {
          const itemEl = clauseEl.querySelector(`.item[data-cat="${catKey}"][data-val="${val}"]`);
          if (itemEl) itemEl.classList.add('selected');
        }
      });
    });
    updateSentenceOutput();
  }

  // =========================
  // 6) Event Listeners for Controls 
  // =========================
  // Auto-fill button
  autoFillBtn.addEventListener('click', () => {
    autoFillBuilder(inputText.value);
  });
  // Clear button
  clearBtn.addEventListener('click', () => {
    inputText.value = "";
    secondClauseToggle.checked = false;
    politeToggle.checked = true;
    renderClauses();
    // Reattach event listeners for new elements
    document.querySelectorAll('.item').forEach(itemEl => {
      itemEl.addEventListener('click', () => onSelectItem(itemEl));
    });
    // Reset selections
    selections.clause1 = { subject:"", time:"", place:"", mod:"", object:"", numeral:"", counter:"" };
    selections.clause2 = { subject:"", time:"", place:"", mod:"", object:"", numeral:"", counter:"" };
    koOutput.textContent = "";
    trOutput.textContent = "";
  });
  // Toggle second clause
  secondClauseToggle.addEventListener('change', () => {
    // Save current selections (for clause1) before re-render:
    const prevSel1 = { ...selections.clause1 };
    const prevSel2 = { ...selections.clause2 };
    renderClauses();
    // Reattach item event listeners
    document.querySelectorAll('.item').forEach(itemEl => {
      itemEl.addEventListener('click', () => onSelectItem(itemEl));
    });
    // Restore previous selections for clause1 and clause2 as applicable:
    selections.clause1 = prevSel1;
    selections.clause2 = prevSel2;
    // Re-highlight the selected items in UI:
    clauseElements.forEach((clauseEl, index) => {
      const ck = index === 0 ? 'clause1' : 'clause2';
      categories.forEach(catKey => {
        const val = selections[ck][catKey];
        if (val) {
          const itemEl = clauseEl.querySelector(`.item[data-cat="${catKey}"][data-val="${val}"]`);
          if (itemEl) itemEl.classList.add('selected');
        }
      });
    });
    updateSentenceOutput();
  });
  // Politeness toggle
  politeToggle.addEventListener('change', () => {
    updateSentenceOutput();
  });
  // Language selection change
  langSelect.addEventListener('change', () => {
    // Simply re-run update to change translation
    updateSentenceOutput();
  });
  // Random sentence button
  randomBtn.addEventListener('click', () => {
    // Deselect second clause if it was enabled:
    secondClauseToggle.checked = false;
    renderClauses();
    document.querySelectorAll('.item').forEach(itemEl => {
      itemEl.addEventListener('click', () => onSelectItem(itemEl));
    });
    // Reset selections
    selections.clause1 = { subject:"", time:"", place:"", mod:"", object:"", numeral:"", counter:"" };
    selections.clause2 = { subject:"", time:"", place:"", mod:"", object:"", numeral:"", counter:"" };
    // For each category in clause1, pick a random entry (including possibly none for optional categories)
    categories.forEach(catKey => {
      const list = dataMap[catKey];
      if (!list || list.length === 0) return;
      // Allow a chance to pick nothing for optional fields (e.g., 50% chance for time, mod)
      if ((catKey === 'time' || catKey === 'mod') && Math.random() < 0.5) {
        selections.clause1[catKey] = "";
      } else {
        const randomEntry = list[Math.floor(Math.random() * list.length)];
        selections.clause1[catKey] = randomEntry.value;
        // If object chosen, assign counter if applicable
        if (catKey === 'object') {
          const counterEntry = dataMap.counter.find(c => c.re.test(randomEntry.trans));
          selections.clause1.counter = counterEntry ? counterEntry.value : "";
        }
      }
    });
    // Ensure subject is not empty:
    if (!selections.clause1.subject) {
      selections.clause1.subject = "Ï†ÄÎäî";
    }
    // If object is empty but place is present, ensure verb will be 'go' by having place.
    // If both place and object randomly empty, at least time or mod will likely be present; otherwise it's just subject + verb "do".
    // Update UI highlights:
    clauseElements.forEach((clauseEl, index) => {
      const ck = index === 0 ? 'clause1' : 'clause2';
      categories.forEach(catKey => {
        const val = selections[ck][catKey];
        if (val) {
          const itemEl = clauseEl.querySelector(`.item[data-cat="${catKey}"][data-val="${val}"]`);
          if (itemEl) itemEl.classList.add('selected');
        }
      });
    });
    // Now update output
    updateSentenceOutput();
  });
  // Prev/Next buttons for example models
  prevBtn.addEventListener('click', () => {
    if (exampleModels.length === 0) return;
    currentModelIndex = (currentModelIndex <= 0) ? exampleModels.length - 1 : currentModelIndex - 1;
    loadExampleModel(currentModelIndex);
  });
  nextBtn.addEventListener('click', () => {
    if (exampleModels.length === 0) return;
    currentModelIndex = (currentModelIndex + 1) % exampleModels.length;
    loadExampleModel(currentModelIndex);
  });
  function loadExampleModel(index) {
    const model = exampleModels[index];
    if (!model) return;
    // Set second clause toggle based on model
    secondClauseToggle.checked = !!model.clause2;
    renderClauses();
    document.querySelectorAll('.item').forEach(itemEl => {
      itemEl.addEventListener('click', () => onSelectItem(itemEl));
    });
    // Load selections from model
    selections.clause1 = { ...selections.clause1, ...model.clause1 };
    if (model.clause2) {
      selections.clause2 = { ...selections.clause2, ...model.clause2 };
    } else {
      selections.clause2 = { subject:"", time:"", place:"", mod:"", object:"", numeral:"", counter:"" };
    }
    politeToggle.checked = model.polite;
    // Highlight selections in UI
    clauseElements.forEach((clauseEl, idx) => {
      const ck = idx === 0 ? 'clause1' : 'clause2';
      categories.forEach(catKey => {
        const val = selections[ck][catKey];
        if (val) {
          const itemEl = clauseEl.querySelector(`.item[data-cat="${catKey}"][data-val="${val}"]`);
          if (itemEl) itemEl.classList.add('selected');
        }
      });
    });
    // Output directly from model translations if available:
    koOutput.textContent = "";  // we'll reconstruct Korean from selections for accuracy
    updateSentenceOutput();
    // Override translation outputs with model's provided translation (for more natural phrasing if desired)
    if (model.translation_ro && model.translation_en) {
      if (langSelect.value === 'ro') {
        trOutput.textContent = model.translation_ro;
      } else {
        trOutput.textContent = model.translation_en;
      }
    }
  }
  // Audio (TTS) button
  ttsBtn.addEventListener('click', () => {
    const textToSpeak = koOutput.textContent;
    if (!textToSpeak) return;
    const utterance = new SpeechSynthesisUtterance(textToSpeak);
    utterance.lang = 'ko-KR';  // ensure Korean voice
    // Choose a Korean voice if available
    const voices = speechSynthesis.getVoices();
    utterance.voice = voices.find(v => v.lang.startsWith('ko') || v.lang.startsWith('ko-KR')) || null;
    speechSynthesis.speak(utterance);
  });
  // Save sentence button
  saveBtn.addEventListener('click', () => {
    const ko = koOutput.textContent;
    const tr = trOutput.textContent;
    if (!ko || !tr) return;
    try {
      const savedList = JSON.parse(localStorage.getItem('savedSentences') || "[]");
      savedList.push({ ko, tr });
      localStorage.setItem('savedSentences', JSON.stringify(savedList));
      // Feedback: briefly change button text or color to indicate success
      saveBtn.textContent = "Saved! ‚úì";
      setTimeout(() => { saveBtn.textContent = "SalveazƒÉ propozi»õia"; }, 1000);
    } catch (e) {
      console.warn("Save failed: ", e);
    }
  });
  // Hide/Show translation button
  toggleTransBtn.addEventListener('click', () => {
    if (trOutput.classList.contains('hidden')) {
      // currently hidden, so show it
      trOutput.classList.remove('hidden');
      toggleTransBtn.textContent = "Ascunde traducerea";
    } else {
      trOutput.classList.add('hidden');
      toggleTransBtn.textContent = "AratƒÉ traducerea";
    }
  });

  // =========================
  // 7) Initialization 
  // =========================
  // If needed, load first example or just start empty
  currentModelIndex = 0;
  loadExampleModel(currentModelIndex);
})();
</script>
</body>
</html>
