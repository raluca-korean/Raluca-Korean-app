<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Raluca Korean – Builder FINAL</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body{
  margin:0;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  background:linear-gradient(120deg,#dff3ff,#ffe9ff,#f4fffc,#e8f0ff);
}
.app{max-width:1100px;margin:0 auto;padding:20px}
h1{margin:0 0 12px}

.table-block{
  background:#ffffffcc;
  border-radius:18px;
  padding:12px;
  margin-bottom:16px;
  box-shadow:0 12px 28px rgba(0,0,0,.12);
}

.table-horizontal{
  display:flex;
  gap:8px;
  overflow-x:auto;
}

.col{
  min-width:120px;
  background:#fdfbf7;
  border-radius:14px;
  padding:8px;
  border:1px solid #e2d7c8;
}

.col-header{
  font-size:11px;
  font-weight:900;
  text-transform:uppercase;
  margin-bottom:4px;
}

.col-body-main{
  min-height:28px;
  font-size:15px;
  font-weight:800;
}
.col-body-main[contenteditable]{outline:none}

.preview{
  background:#fff;
  border-radius:18px;
  padding:14px;
  box-shadow:0 14px 30px rgba(0,0,0,.14);
}
.preview-sentence{
  font-size:22px;
  font-weight:900;
}
</style>
</head>

<body>
<div class="app">
<h1>Raluca Korean – Builder FINAL</h1>

<div id="clausesHost"></div>

<div class="preview">
<label>
<input type="checkbox" id="politeToggle">
 Politețe (doar ultima clauză)
</label>
<div id="previewSentence" class="preview-sentence">저 가요</div>
</div>
</div>

<script>
"use strict";

/* =========================
   CORE UTILS
========================= */
function hasBatchim(ch){
  if(!ch) return false;
  const code = ch.charCodeAt(ch.length-1);
  if(code < 0xAC00 || code > 0xD7A3) return false;
  return ((code - 0xAC00) % 28) !== 0;
}

/* =========================
   PARTICLES
========================= */
function subjectParticle(noun){
  if(!noun) return "";
  return noun + (hasBatchim(noun) ? "은" : "는");
}

function objectParticle(noun){
  if(!noun) return "";
  return noun + (hasBatchim(noun) ? "을" : "를");
}

function choosePlaceParticle(place, verb){
  if(!place) return "";
  if(verb === "가다" || verb === "오다") return place + "에";
  return place + "에서";
}

/* =========================
   ENDINGS
========================= */
function attachEnding(verbInf, ending){
  if(!verbInf) return "";
  if(!ending) return verbInf;

  if(!verbInf.endsWith("다")) return verbInf;
  const stem = verbInf.slice(0,-1);
  const last = stem[stem.length-1];
  const b = hasBatchim(last);

  if(ending === "-고") return stem + "고";
  if(ending === "-지만") return stem + "지만";
  if(ending === "-아서" || ending === "-어서") return stem + ending.slice(1);
  if(ending === "-(으)면") return stem + (b ? "으면":"면");
  if(ending === "-(으)ㄹ 때") return stem + (b ? "을 때":"ㄹ 때");
  if(ending === "-(으)려고") return stem + (b ? "으려고":"려고");

  return stem + ending.replace(/^-/,"");
}

function politeVerb(verbInf){
  if(!verbInf.endsWith("다")) return verbInf;
  if(verbInf === "하다") return "해요";
  const stem = verbInf.slice(0,-1);
  const last = stem[stem.length-1];
  const code = last.charCodeAt(0) - 0xAC00;
  const jung = Math.floor((code % (21*28))/28);
  const a = [0,2,8,9];
  return stem + (a.includes(jung) ? "아요":"어요");
}

/* =========================
   UI BUILD
========================= */
const host = document.getElementById("clausesHost");

function col(key,label){
  return `
  <div class="col" data-key="${key}">
    <div class="col-header">${label}</div>
    <div class="col-body-main" contenteditable></div>
  </div>`;
}

function clauseHTML(i){
  return `
  <div class="table-block" data-idx="${i}">
    <div class="table-horizontal">
      ${col("subject","SUBJECT")}
      ${col("time","TIME")}
      ${col("place","PLACE")}
      ${col("mod","MOD")}
      ${col("object","OBJECT")}
      ${col("numeral","NUMERAL")}
      ${col("counter","COUNTER")}
      ${col("verb","VERB")}
      ${col("conj","CONJ")}
    </div>
  </div>`;
}

function ensureClauses(n){
  const cur = host.children.length;
  for(let i=cur;i<n;i++) host.insertAdjacentHTML("beforeend",clauseHTML(i));
}

/* =========================
   READ CELLS
========================= */
function read(idx,key){
  return host.querySelector(`[data-idx="${idx}"] .col[data-key="${key}"] .col-body-main`)
    ?.textContent.trim() || "";
}

/* =========================
   BUILD PREVIEW
========================= */
function buildClause(i,last,polite){
  const s = read(i,"subject");
  const t = read(i,"time");
  const p = read(i,"place");
  const m = read(i,"mod");
  const o = read(i,"object");
  const n = read(i,"numeral");
  const c = read(i,"counter");
  const v = read(i,"verb");
  const conj = read(i,"conj");

  let subj = s ? subjectParticle(s) : "";
  let obj = o ? objectParticle(o + (n && c ? " "+n+" "+c : "")) : "";
  let place = choosePlaceParticle(p,v);

  let verbOut = conj ? attachEnding(v,conj) : v;
  if(last && polite && !conj) verbOut = politeVerb(v);

  return [subj,t,place,m,obj,verbOut].filter(Boolean).join(" ");
}

function rebuild(){
  const polite = document.getElementById("politeToggle").checked;
  const blocks = host.children.length;
  const out=[];
  for(let i=0;i<blocks;i++){
    const text = buildClause(i,i===blocks-1,polite);
    if(text) out.push(text);
  }
  document.getElementById("previewSentence").textContent =
    out.join(" ") || "저 가요";
}

/* =========================
   INIT
========================= */
ensureClauses(1);
host.addEventListener("input",rebuild);
document.getElementById("politeToggle").addEventListener("change",rebuild);
rebuild();
</script>
</body>
</html>
