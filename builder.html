<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Raluca Korean – Builder FINAL</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body{
  margin:0;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  background:linear-gradient(120deg,#dff3ff,#ffe9ff,#f4fffc,#e8f0ff);
}
.app{max-width:1100px;margin:0 auto;padding:20px}
h1{margin:0 0 12px}

.table-block{
  background:#ffffffcc;
  border-radius:18px;
  padding:12px;
  margin-bottom:16px;
  box-shadow:0 12px 28px rgba(0,0,0,.12);
}

.table-horizontal{
  display:flex;
  gap:8px;
  overflow-x:auto;
}

.col{
  min-width:120px;
  background:#fdfbf7;
  border-radius:14px;
  padding:8px;
  border:1px solid #e2d7c8;
}

.col-header{
  font-size:11px;
  font-weight:900;
  text-transform:uppercase;
  margin-bottom:4px;
}

.col-body-main{
  min-height:28px;
  font-size:15px;
  font-weight:800;
}
.col-body-main[contenteditable]{outline:none}

.preview{
  background:#fff;
  border-radius:18px;
  padding:14px;
  box-shadow:0 14px 30px rgba(0,0,0,.14);
}
.preview-sentence{
  font-size:22px;
  font-weight:900;
}
</style>
</head>

<body>
<div class="app">
<h1>Raluca Korean – Builder FINAL</h1>

<div id="clausesHost"></div>

<div class="preview">
<label>
<input type="checkbox" id="politeToggle">
 Politețe (doar ultima clauză)
</label>
<div id="previewSentence" class="preview-sentence">저 가요</div>
</div>
</div>

<script>
  (function () {
  "use strict";

  /* =========================
     GLOBAL STATE
  ========================= */
  let LINKS = []; // conectori între clauze (ENDING / WORD)

  /* =========================
     UTILS
  ========================= */
  function normalizeText(text) {
    if (!text) return "";
    return text
      .toLowerCase()
      .replace(/ş/g, "ș")
      .replace(/ţ/g, "ț")
      .replace(/[.,!?;:]/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  function escapeRegExp(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function hasBatchim(char) {
    if (!char) return false;
    const code = char.charCodeAt(0);
    if (code < 0xac00 || code > 0xd7a3) return false;
    return (code - 0xac00) % 28 !== 0;
  }

  function lastHangulChar(str) {
    if (!str) return "";
    return str.trim().slice(-1);
  }

  /* =========================
     CONNECTORS (SPLIT)
  ========================= */
  const CONNECTORS = [
    { keys: ["și", "si", "and"], ending: "-고" },
    { keys: ["dar", "but"], ending: "-지만" },
    { keys: ["pentru că", "pentru ca", "because"], ending: "-어서" },
    { keys: ["dacă", "daca", "if"], ending: "-(으)면" },
    { keys: ["când", "when"], ending: "-(으)ㄹ 때" },
    { keys: ["ca să", "in order to"], ending: "-(으)려고" }
  ];

  function buildConnectorRegex() {
    const all = CONNECTORS.flatMap(c => c.keys);
    all.sort((a, b) => b.length - a.length);
    return new RegExp("\\s(" + all.map(escapeRegExp).join("|") + ")\\s", "ig");
  }

  function mapConnector(token) {
    token = token.toLowerCase();
    for (const c of CONNECTORS) {
      if (c.keys.includes(token)) {
        return { ending: c.ending };
      }
    }
    return { ending: "-고" };
  }

  function splitIntoChain(raw) {
    const text = normalizeText(raw);
    if (!text) return { clauses: [], links: [] };

    const re = buildConnectorRegex();
    let m, last = 0;
    const clauses = [];
    const links = [];

    while ((m = re.exec(text)) !== null) {
      const before = text.slice(last, m.index).trim();
      if (before) clauses.push(before);
      links.push(mapConnector(m[1]));
      last = m.index + m[0].length;
    }

    const tail = text.slice(last).trim();
    if (tail) clauses.push(tail);
    while (links.length >= clauses.length) links.pop();

    return { clauses, links };
  }

  /* =========================
     SLOT RULES (RO / EN)
  ========================= */
  const RO = {
    subject: [{ re: /\b(eu)\b/i, v: "저" }],
    time: [{ re: /\b(azi|astăzi)\b/i, v: "오늘" }],
    place: [{ re: /\b(cafenea)\b/i, v: "카페" }],
    object: [{ re: /\b(carte)\b/i, v: "책" }],
    numeral: [{ re: /\b(o|una)\b/i, v: "한" }],
    counter: [{ re: /\b(carte)\b/i, v: "권" }],
    verb: [{ re: /\b(merg)\b/i, v: "가다" }]
  };

  function matchSlot(rules, text) {
    for (const r of rules) if (r.re.test(text)) return r.v;
    return "";
  }

  function parseToSlots(text) {
    const t = normalizeText(text);
    return {
      subject: matchSlot(RO.subject, t),
      time: matchSlot(RO.time, t),
      place: matchSlot(RO.place, t),
      object: matchSlot(RO.object, t),
      numeral: matchSlot(RO.numeral, t),
      counter: matchSlot(RO.counter, t),
      verb: matchSlot(RO.verb, t)
    };
  }

  /* =========================
     DOM HELPERS
  ========================= */
  const host = document.getElementById("clausesHost");

  function tableId(i) {
    return "tableP" + (i + 1);
  }

  function cell(id, key) {
    return document.querySelector(`#${id} .col[data-key="${key}"] .col-body-main`);
  }

  function get(id, key) {
    const c = cell(id, key);
    return c ? c.textContent.trim() : "";
  }

  function set(id, key, v) {
    const c = cell(id, key);
    if (c) c.textContent = v || "";
  }

  function ensureClauseCount(n) {
    const cur = host.children.length;
    if (cur === n) return;

    if (cur < n) {
      for (let i = cur; i < n; i++) {
        host.insertAdjacentHTML(
          "beforeend",
          `<section class="table-block" data-clause-index="${i}">
            <div id="${tableId(i)}" class="table-horizontal"></div>
          </section>`
        );
      }
    } else {
      for (let i = cur - 1; i >= n; i--) host.children[i].remove();
    }
  }

  /* =========================
     PARTICLES & ENDINGS
  ========================= */
  function choosePlaceParticle(place, verb) {
    if (!place) return "";
    if (verb === "가다" || verb === "오다") return place + "에";
    return place + "에서";
  }

  function attachEnding(verb, ending) {
    if (!ending || !verb.endsWith("다")) return verb;
    const stem = verb.slice(0, -1);
    const last = lastHangulChar(stem);
    const b = hasBatchim(last);

    if (ending === "-고") return stem + "고";
    if (ending === "-지만") return stem + "지만";
    if (ending === "-(으)면") return stem + (b ? "으면" : "면");
    if (ending === "-(으)ㄹ 때") return stem + (b ? "을 때" : "ㄹ 때");
    if (ending === "-(으)려고") return stem + (b ? "으려고" : "려고");
    if (ending === "-어서") return stem + "어서";

    return stem + ending;
  }

  function politeVerb(verb) {
    if (!verb.endsWith("다")) return verb;
    const stem = verb.slice(0, -1);
    return stem + "요";
  }

  /* =========================
     BUILD PREVIEW
  ========================= */
  function buildClause(i, isLast, polite) {
    const id = tableId(i);

    const subject = get(id, "subject");
    const time = get(id, "time");
    const placeB = get(id, "place");
    const object = get(id, "object");
    const numeral = get(id, "numeral");
    const counter = get(id, "counter");
    const verbInf = get(id, "verb");
    const conj = get(id, "conj");

    const obj =
      object && numeral && counter
        ? `${object} ${numeral} ${counter}`
        : object;

    const place = choosePlaceParticle(placeB, verbInf);

    let verb = attachEnding(verbInf, conj);
    if (isLast && polite && !conj) verb = politeVerb(verbInf);

    return [subject, time, place, obj, verb].filter(Boolean).join(" ");
  }

  function rebuildPreview() {
    const out = document.getElementById("previewSentence");
    const polite = document.getElementById("politeToggle")?.checked;

    const chunks = [];
    for (let i = 0; i < host.children.length; i++) {
      chunks.push(buildClause(i, i === host.children.length - 1, polite));
    }

    out.textContent = chunks.join(" ").trim() || "저 가요";
  }

  /* =========================
     AUTOFILL
  ========================= */
  function autoFill() {
    const input = document.getElementById("inputText").value;
    const chain = splitIntoChain(input);

    LINKS = chain.links;
    ensureClauseCount(chain.clauses.length);

    chain.clauses.forEach((c, i) => {
      const slots = parseToSlots(c);
      const id = tableId(i);
      Object.entries(slots).forEach(([k, v]) => v && set(id, k, v));
      if (LINKS[i]) set(id, "conj", LINKS[i].ending);
    });

    rebuildPreview();
  }

  /* =========================
     INIT
  ========================= */
  function init() {
    ensureClauseCount(1);
    set("tableP1", "subject", "저");
    set("tableP1", "verb", "가다");

    document.getElementById("autoFillBtn")?.addEventListener("click", autoFill);
    document.getElementById("clearBtn")?.addEventListener("click", () => location.reload());
    document.addEventListener("input", rebuildPreview);
    document.getElementById("politeToggle")?.addEventListener("change", rebuildPreview);

    rebuildPreview();
  }

  window.addEventListener("DOMContentLoaded", init);
})();
  
</script>
</body>
</html>
