<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Raluca Korean – Clause Builder</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<style>
body{font-family:system-ui;background:#f4f6fb;margin:0;padding:20px}
h1{margin:0 0 10px}
.table{display:flex;gap:8px;overflow-x:auto;margin-bottom:12px}
.col{min-width:110px;background:#fff;border-radius:12px;padding:8px;border:1px solid #ddd}
.col h4{margin:0 0 4px;font-size:11px;color:#666}
.col div{font-size:15px;font-weight:700;min-height:1.4em}
.col div[contenteditable]{outline:none}
.block{margin-bottom:20px;padding:12px;border-radius:14px;background:#fff;border:1px solid #ddd}
.preview{font-size:22px;font-weight:900}
button{padding:8px 14px;border-radius:999px;border:none;background:#6b7cff;color:#fff;font-weight:800}
</style>
</head>

<body>

<h1>Raluca Korean – Builder</h1>

<textarea id="inputText" placeholder="Astăzi merg la cafenea și citesc o carte și beau o cafea." style="width:100%;height:70px"></textarea>
<br><br>
<button id="autoFill">Auto-fill</button>

<div id="clauses"></div>

<div class="block">
  <label><input type="checkbox" id="polite"> Polite (ultima clauză)</label>
  <div id="preview" class="preview">저 가요</div>
</div>

<script>
/* =======================
   GLOBAL STATE
======================= */
let CURRENT_CHAIN = { clauses: [], links: [] };

/* =======================
   SPLIT LOGIC
======================= */
const CONNECTORS = [
  { keys:["și","si","and"], ending:"-고", word:null },
  { keys:["dar","but"], ending:"-지만", word:null },
  { keys:["pentru că","because"], ending:"-어서", word:null },
  { keys:["apoi"], ending:"-고", word:"그리고" }
];

function splitIntoChain(text){
  const t=text.toLowerCase().replace(/[.,!?]/g,"");
  let clauses=[], links=[];
  let rest=t;

  while(true){
    let found=null;
    for(const c of CONNECTORS){
      for(const k of c.keys){
        const i=rest.indexOf(" "+k+" ");
        if(i!==-1 && (!found || i<found.i))
          found={i,k,c};
      }
    }
    if(!found) break;

    clauses.push(rest.slice(0,found.i).trim());
    links.push({ending:found.c.ending,word:found.c.word});
    rest=rest.slice(found.i+found.k.length+2);
  }
  clauses.push(rest.trim());
  return {clauses,links};
}

/* =======================
   UI
======================= */
function clauseHTML(i){
  return `
  <div class="block" data-i="${i}">
    <div class="table">
      ${col("subject","SUBJ")}
      ${col("time","TIME")}
      ${col("place","PLACE")}
      ${col("object","OBJ")}
      ${col("verb","VERB")}
      ${col("conj","ENDING")}
    </div>
  </div>`;
}
function col(k,l){
  return `<div class="col" data-k="${k}"><h4>${l}</h4><div contenteditable></div></div>`;
}
function cell(i,k){
  return document.querySelector(`[data-i="${i}"] [data-k="${k}"] div`);
}

/* =======================
   BUILD CLAUSE (CURAT)
======================= */
function buildClause(i,isLast,polite){
  const subj=cell(i,"subject").textContent.trim();
  const time=cell(i,"time").textContent.trim();
  const place=cell(i,"place").textContent.trim();
  const obj=cell(i,"object").textContent.trim();
  const verb=cell(i,"verb").textContent.trim();
  const ending=cell(i,"conj").textContent.trim();

  let v=verb;
  if(v.endsWith("다") && ending){
    v=v.slice(0,-1)+ending.replace("-","");
  }
  if(politeshould(isLast,polite,ending,verb)) v=toPolite(verb);

  return [subj,time,place,obj,v].filter(Boolean).join(" ");
}
function politeshould(isLast,polite,ending,verb){
  return polite && isLast && !ending && verb.endsWith("다");
}
function toPolite(v){
  if(!v.endsWith("다"))return v;
  const s=v.slice(0,-1);
  return s.endsWith("하")?s.slice(0,-1)+"해요":s+"어요";
}

/* =======================
   PREVIEW (SINGURUL LOC)
======================= */
function rebuildPreview(){
  const p=[];
  const n=CURRENT_CHAIN.clauses.length;
  const polite=document.getElementById("polite").checked;

  for(let i=0;i<n;i++){
    p.push(buildClause(i,i===n-1,polite));
    if(i<n-1 && CURRENT_CHAIN.links[i]?.word)
      p.push(CURRENT_CHAIN.links[i].word);
  }
  document.getElementById("preview").textContent=p.join(" ").trim()||"저 가요";
}

/* =======================
   AUTOFILL
======================= */
document.getElementById("autoFill").onclick=()=>{
  const t=document.getElementById("inputText").value;
  CURRENT_CHAIN=splitIntoChain(t);
  const host=document.getElementById("clauses");
  host.innerHTML="";
  CURRENT_CHAIN.clauses.forEach((_,i)=>{
    host.insertAdjacentHTML("beforeend",clauseHTML(i));
    if(CURRENT_CHAIN.links[i])
      cell(i,"conj").textContent=CURRENT_CHAIN.links[i].ending;
  });
  rebuildPreview();
};

document.addEventListener("input",e=>{
  if(e.target.closest(".col")) rebuildPreview();
});
document.getElementById("polite").onchange=rebuildPreview;
</script>

</body>
</html>
