<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Raluca Korean – Builder FINAL</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body{
  margin:0;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  background:linear-gradient(120deg,#dff3ff,#ffe9ff,#f4fffc,#e8f0ff);
}
.app{max-width:1100px;margin:0 auto;padding:20px}
h1{margin:0 0 12px}

.table-block{
  background:#ffffffcc;
  border-radius:18px;
  padding:12px;
  margin-bottom:16px;
  box-shadow:0 12px 28px rgba(0,0,0,.12);
}

.table-horizontal{
  display:flex;
  gap:8px;
  overflow-x:auto;
}

.col{
  min-width:120px;
  background:#fdfbf7;
  border-radius:14px;
  padding:8px;
  border:1px solid #e2d7c8;
}

.col-header{
  font-size:11px;
  font-weight:900;
  text-transform:uppercase;
  margin-bottom:4px;
}

.col-body-main{
  min-height:28px;
  font-size:15px;
  font-weight:800;
}
.col-body-main[contenteditable]{outline:none}

.preview{
  background:#fff;
  border-radius:18px;
  padding:14px;
  box-shadow:0 14px 30px rgba(0,0,0,.14);
}
.preview-sentence{
  font-size:22px;
  font-weight:900;
}
</style>
</head>

<body>
<div class="app">
<h1>Raluca Korean – Builder FINAL</h1>

<div id="clausesHost"></div>

<div class="preview">
<label>
<input type="checkbox" id="politeToggle">
 Politețe (doar ultima clauză)
</label>
<div id="previewSentence" class="preview-sentence">저 가요</div>
</div>
</div>

<script>
  (function () {
  "use strict";

  /* =====================================================
     GLOBAL STATE
  ===================================================== */
  let LINKS = [];

  /* =====================================================
     UTILS
  ===================================================== */
  function normalizeText(t) {
    return (t || "")
      .toLowerCase()
      .replace(/ş/g, "ș")
      .replace(/ţ/g, "ț")
      .replace(/[.,!?;:]/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  function escapeRegExp(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function hasBatchim(ch) {
    if (!ch) return false;
    const c = ch.charCodeAt(0);
    if (c < 0xac00 || c > 0xd7a3) return false;
    return (c - 0xac00) % 28 !== 0;
  }

  function lastHangulChar(str) {
    return str ? str.trim().slice(-1) : "";
  }

  /* =====================================================
     CONNECTORS (SPLIT + ENDINGS)
  ===================================================== */
  const CONNECTORS = [
    { keys: ["și", "si", "and"], ending: "-고" },
    { keys: ["dar", "but"], ending: "-지만" },
    { keys: ["pentru că", "pentru ca", "because"], ending: "-아서/어서" },
    { keys: ["dacă", "daca", "if"], ending: "-(으)면" },
    { keys: ["când", "when"], ending: "-(으)ㄹ 때" },
    { keys: ["ca să", "in order to"], ending: "-(으)려고" }
  ];

  function buildConnectorRegex() {
    const all = CONNECTORS.flatMap(c => c.keys);
    all.sort((a, b) => b.length - a.length);
    return new RegExp("\\s(" + all.map(escapeRegExp).join("|") + ")\\s", "ig");
  }

  function mapConnector(token) {
    token = token.toLowerCase();
    for (const c of CONNECTORS) {
      if (c.keys.includes(token)) return c.ending;
    }
    return "-고";
  }

  function splitIntoClauses(raw) {
    const text = normalizeText(raw);
    if (!text) return { clauses: [], links: [] };

    const re = buildConnectorRegex();
    let m, last = 0;
    const clauses = [];
    const links = [];

    while ((m = re.exec(text)) !== null) {
      const before = text.slice(last, m.index).trim();
      if (before) clauses.push(before);
      links.push(mapConnector(m[1]));
      last = m.index + m[0].length;
    }

    const tail = text.slice(last).trim();
    if (tail) clauses.push(tail);
    while (links.length >= clauses.length) links.pop();

    return { clauses, links };
  }

  /* =====================================================
     SLOT RULES RO / EN
  ===================================================== */
  const RULES = {
    subject: [
      { re: /\b(eu|i)\b/i, v: "저" },
      { re: /\b(tu|you)\b/i, v: "너" },
      { re: /\b(noi|we)\b/i, v: "우리" }
    ],
    time: [
      { re: /\b(azi|astăzi|today)\b/i, v: "오늘" },
      { re: /\b(mâine|tomorrow)\b/i, v: "내일" },
      { re: /\b(ieri|yesterday)\b/i, v: "어제" }
    ],
    place: [
      { re: /\b(cafenea|cafe)\b/i, v: "카페" },
      { re: /\b(acasa|acasă|home)\b/i, v: "집" },
      { re: /\b(scoal[aă]|school)\b/i, v: "학교" }
    ],
    object: [
      { re: /\b(carte|book)\b/i, v: "책" },
      { re: /\b(cafea|coffee)\b/i, v: "커피" }
    ],
    numeral: [
      { re: /\b(o|una|a|one)\b/i, v: "한" },
      { re: /\b(dou[aă]|two)\b/i, v: "두" }
    ],
    counter: [
      { re: /\b(carte|book)\b/i, v: "권" },
      { re: /\b(cafea|coffee)\b/i, v: "잔" }
    ],
    verb: [
      { re: /\b(merg|go)\b/i, v: "가다" },
      { re: /\b(citesc|read)\b/i, v: "읽다" },
      { re: /\b(beau|drink)\b/i, v: "마시다" }
    ]
  };

  function matchSlot(rules, text) {
    for (const r of rules) if (r.re.test(text)) return r.v;
    return "";
  }

  function parseSlots(text) {
    const t = normalizeText(text);
    const out = {};
    for (const k in RULES) out[k] = matchSlot(RULES[k], t);
    return out;
  }

  /* =====================================================
     DOM HELPERS
  ===================================================== */
  const host = document.getElementById("clausesHost");

  function tableId(i) {
    return "tableP" + (i + 1);
  }

  function cell(id, key) {
    return document.querySelector(`#${id} .col[data-key="${key}"] .col-body-main`);
  }

  function get(id, key) {
    return cell(id, key)?.textContent.trim() || "";
  }

  function set(id, key, v) {
    const c = cell(id, key);
    if (c) c.textContent = v || "";
  }

  function ensureClauses(n) {
    const cur = host.children.length;
    if (cur === n) return;

    if (cur < n) {
      for (let i = cur; i < n; i++) {
        host.insertAdjacentHTML("beforeend", `
          <section class="table-block" data-clause-index="${i}">
            <div id="${tableId(i)}" class="table-horizontal"></div>
          </section>
        `);
      }
    } else {
      for (let i = cur - 1; i >= n; i--) host.children[i].remove();
    }
  }

  /* =====================================================
     PARTICLES & ENDINGS
  ===================================================== */
  function choosePlaceParticle(place, verb) {
    if (!place) return "";
    return (verb === "가다" || verb === "오다") ? place + "에" : place + "에서";
  }

  function attachEnding(verb, ending) {
    if (!ending || !verb.endsWith("다")) return verb;
    const stem = verb.slice(0, -1);
    const last = lastHangulChar(stem);
    const b = hasBatchim(last);

    if (ending === "-고") return stem + "고";
    if (ending === "-지만") return stem + "지만";
    if (ending === "-(으)면") return stem + (b ? "으면" : "면");
    if (ending === "-(으)ㄹ 때") return stem + (b ? "을 때" : "ㄹ 때");
    if (ending === "-(으)려고") return stem + (b ? "으려고" : "려고");
    if (ending === "-아서/어서") return stem + (b ? "어서" : "아서");

    return stem + ending;
  }

  function polite(verb) {
    if (!verb.endsWith("다")) return verb;
    return verb.slice(0, -1) + "요";
  }

  /* =====================================================
     BUILD SENTENCE
  ===================================================== */
  function buildClause(i, last, politeOn) {
    const id = tableId(i);

    const subject = get(id, "subject");
    const time = get(id, "time");
    const placeB = get(id, "place");
    const object = get(id, "object");
    const numeral = get(id, "numeral");
    const counter = get(id, "counter");
    const verbInf = get(id, "verb");
    const conj = get(id, "conj");

    const obj = object && numeral && counter
      ? `${object} ${numeral} ${counter}`
      : object;

    const place = choosePlaceParticle(placeB, verbInf);
    let verb = attachEnding(verbInf, conj);

    if (last && politeOn && !conj) verb = polite(verbInf);

    return [subject, time, place, obj, verb].filter(Boolean).join(" ");
  }

  function rebuildPreview() {
    const politeOn = document.getElementById("politeToggle")?.checked;
    const out = [];

    for (let i = 0; i < host.children.length; i++) {
      out.push(buildClause(i, i === host.children.length - 1, politeOn));
    }

    document.getElementById("previewSentence").textContent =
      out.join(" ").trim() || "저 가요";
  }

  /* =====================================================
     AUTOFILL
  ===================================================== */
  function autoFill() {
    const input = document.getElementById("inputText").value;
    const chain = splitIntoClauses(input);

    LINKS = chain.links;
    ensureClauses(chain.clauses.length);

    chain.clauses.forEach((c, i) => {
      const slots = parseSlots(c);
      const id = tableId(i);
      Object.entries(slots).forEach(([k, v]) => v && set(id, k, v));
      if (LINKS[i]) set(id, "conj", LINKS[i]);
    });

    rebuildPreview();
  }

  /* =====================================================
     INIT
  ===================================================== */
  function init() {
    ensureClauses(1);
    set("tableP1", "subject", "저");
    set("tableP1", "verb", "가다");

    document.getElementById("autoFillBtn")?.addEventListener("click", autoFill);
    document.getElementById("clearBtn")?.addEventListener("click", () => location.reload());
    document.addEventListener("input", rebuildPreview);
    document.getElementById("politeToggle")?.addEventListener("change", rebuildPreview);

    rebuildPreview();
  }

  window.addEventListener("DOMContentLoaded", init);
})();
  
</script>
</body>
</html>
