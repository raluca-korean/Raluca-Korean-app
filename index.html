Bun 3 
<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Construiește & Extinde Propoziții</title>
  <style>
    :root{
      --bg:#0f172a;
      --panel:#111c3a;
      --card:#0b1226;
      --text:#e5e7eb;
      --muted:#a5b4fc;
      --accent:#fbbf24;
      --line:#233055;
      --ok:#22c55e;
      --warn:#f97316;
      --bad:#ef4444;
    }
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 20% 10%, #1e2a6b 0%, var(--bg) 60%);
      color:var(--text);
    }
    header{
      padding:20px 16px; border-bottom:1px solid var(--line);
      background: rgba(15,23,42,.75);
      position: sticky; top:0; backdrop-filter: blur(8px); z-index:10;
    }
    header h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    header p{ margin:6px 0 0; color:#c7d2fe; font-size:13px; }

    .wrap{ max-width:1100px; margin:0 auto; padding:16px; display:grid; gap:14px; }
    .grid{ display:grid; gap:14px; grid-template-columns: 1.05fr .95fr; }
    @media (max-width: 940px){ .grid{ grid-template-columns:1fr; } }

    .panel{
      background: rgba(17,28,58,.68);
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .panel h2{ margin:0 0 10px; font-size:15px; color:#e0e7ff; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row > *{ flex: 0 0 auto; }

    select, button, input{
      background: rgba(11,18,38,.8);
      color: var(--text);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
      outline:none;
    }
    select{ min-width: 220px; }
    button{ cursor:pointer; }
    button.primary{ border-color: rgba(251,191,36,.45); }
    button.primary:hover{ background: rgba(251,191,36,.12); }
    button.ghost:hover{ background: rgba(165,180,252,.10); }
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      border:1px solid var(--line);
      border-radius:999px;
      padding:6px 10px;
      background: rgba(11,18,38,.6);
      font-size:12px;
      color:#c7d2fe;
    }
    .pill strong{ color: var(--accent); font-weight:700; }

    .cards{ display:grid; gap:10px; }
    .card{
      background: rgba(11,18,38,.75);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
    }
    .korean{
      font-size:20px; line-height:1.25; letter-spacing:.2px;
    }
    .romanian{
      margin-top:6px; font-size:13px; color:#c7d2fe;
    }
    .meta{
      margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;
    }
    .tag{
      font-size:12px; padding:4px 8px; border-radius:999px;
      border:1px solid var(--line);
      color:#e0e7ff;
      background: rgba(35,48,85,.35);
    }
    .tag.ok{ border-color: rgba(34,197,94,.35); color:#bbf7d0; }
    .tag.warn{ border-color: rgba(249,115,22,.35); color:#fed7aa; }
    .tag.bad{ border-color: rgba(239,68,68,.35); color:#fecaca; }

    .big{
      border:1px dashed rgba(251,191,36,.55);
      background: rgba(251,191,36,.08);
    }
    .big .korean{ font-size:22px; }
    .split{
      display:grid; gap:10px; grid-template-columns:1fr;
    }
    .help{
      font-size:12px; color:#c7d2fe; margin:8px 0 0;
    }
    .divider{ height:1px; background: var(--line); margin:12px 0; }

    .small{ font-size:12px; color:#c7d2fe; }
    .rightTools{ display:flex; gap:8px; flex-wrap:wrap; }
    .mini{ padding:8px 10px; border-radius:10px; font-size:13px; }
    .copyOk{ color:#bbf7d0; }
  </style>
</head>
<body>
  <header>
    <h1>Construiește & Extinde propoziții</h1>
    <p>Pornești de la propoziții scurte și le extinzi: ADD • MODIFY • CHANGE • COMBINE</p>
  </header>

  <div class="wrap">
    <div class="grid">

      <!-- LEFT: Builder -->
      <section class="panel">
        <h2>1) Alege un set (universal)</h2>
        <div class="row">
          <select id="setSelect"></select>
          <button class="ghost mini" id="resetBtn">Reset</button>
          <span class="pill">Nivel: <strong id="levelLabel">A1</strong></span>
        </div>
        <p class="help">Setul îți oferă propoziții de bază + opțiuni de extindere. Poți adăuga seturi noi foarte ușor în variabila <code>SETS</code>.</p>

        <div class="divider"></div>

        <h2>2) Propoziții de bază</h2>
        <div class="cards" id="baseCards"></div>

        <div class="divider"></div>

        <h2>3) Extinde pas cu pas</h2>
        <div class="split">

          <div class="card">
            <div class="row">
              <span class="pill"><strong>ADD</strong> (adaugă)</span>
              <select id="addSelect"></select>
              <button class="primary mini" id="applyAdd">Aplică</button>
              <button class="ghost mini" id="undoAdd">Undo</button>
            </div>
            <p class="help">Ex: 몸에, 물에, 너무, 벌써, 깜짝, 새벽 5시에…</p>
          </div>

          <div class="card">
            <div class="row">
              <span class="pill"><strong>MODIFY</strong> (modifică)</span>
              <select id="modifySelect"></select>
              <button class="primary mini" id="applyModify">Aplică</button>
              <button class="ghost mini" id="undoModify">Undo</button>
            </div>
            <p class="help">Ex: 물 → 따뜻한 물, 마스카라 → 오래된 마스카라…</p>
          </div>

          <div class="card">
            <div class="row">
              <span class="pill"><strong>CHANGE</strong> (schimbă forma)</span>
              <select id="changeSelect"></select>
              <button class="primary mini" id="applyChange">Aplică</button>
              <button class="ghost mini" id="undoChange">Undo</button>
            </div>
            <p class="help">Ex: afirmativ→negativ, descriptiv→devenire(어지다/어지다), imperativ(으)세요…</p>
          </div>

          <div class="card">
            <div class="row">
              <span class="pill"><strong>COMBINE</strong> (unește propoziții)</span>
              <select id="combineSelect"></select>
              <button class="primary mini" id="applyCombine">Generează</button>
            </div>
            <p class="help">Conectori: -고, -아/어/여서, -(으)니까, -는데, -더니, -기 전에</p>
          </div>

        </div>
      </section>

      <!-- RIGHT: Preview -->
      <aside class="panel">
        <h2>Preview (rezultatul curent)</h2>

        <div class="card big">
          <div class="korean" id="previewKo">—</div>
          <div class="romanian" id="previewRo">—</div>
          <div class="meta" id="previewMeta"></div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div class="rightTools">
            <button class="ghost mini" id="copyKo">Copiază KO</button>
            <button class="ghost mini" id="copyRo">Copiază RO</button>
            <button class="ghost mini" id="saveBtn">Salvează</button>
          </div>
          <span class="small" id="copyStatus"></span>
        </div>

        <div class="divider"></div>

        <h2>Istoric (session)</h2>
        <div class="cards" id="history"></div>
        <p class="help">Istoricul este doar în sesiune (până închizi pagina). Dacă vrei persistare, îți leg la LocalStorage fără să ating restul aplicației.</p>
      </aside>

    </div>
  </div>

  <script>
    /***********************
     *  DATA (universal)
     ***********************/
    const SETS = [
      {
        id: "shower",
        title: "Duș (acțiuni + reacție)",
        level: "A1→A2",
        base: [
          { id:"b1", ko:"비누칠했어요.", ro:"M-am săpunit (am făcut spumă)."},
          { id:"b2", ko:"물을 틀었어요.", ro:"Am dat drumul la apă."},
          { id:"b3", ko:"물이 차가웠어요.", ro:"Apa era rece."},
          { id:"b4", ko:"놀랐어요.", ro:"Am fost surprins(ă)."}
        ],
        add: [
          { label:"몸에 (pe corp)", type:"prefixObject", target:"비누칠했어요.", out:"몸에 비누칠했어요.", ro:"M-am săpunit pe corp." },
          { label:"따뜻한 (caldă) + 물", type:"replace", find:"물을", repl:"따뜻한 물을", roHint:"apă caldă" },
          { label:"깜짝 (brusc/foarte)", type:"prefixAdverb", target:"놀랐어요.", out:"깜짝 놀랐어요.", ro:"Am fost foarte surprins(ă)." }
        ],
        modify: [
          { label:"물 → 따뜻한 물", type:"replace", find:"물을", repl:"따뜻한 물을", roHint:"apă caldă" },
          { label:"놀랐어요 → 깜짝 놀랐어요", type:"replaceSentence", from:"놀랐어요.", to:"깜짝 놀랐어요.", roHint:"foarte surprins(ă)" }
        ],
        change: [
          { label:"Afirmativ → Negativ (exemplu generic)", type:"infoOnly", note:"Pentru acest set, nu avem propoziție cu 있다/없다. Vezi setul «Mascara & timp»." },
          { label:"Descriere → rezultat (어두워요 → 어두워졌어요 tip)", type:"infoOnly", note:"Acest set e pe acțiuni. Vezi setul «Cortine & lumină»." }
        ],
        combine: [
          { label:"-고 (și)", id:"and", pattern:"{A} 그리고 {B}", ro:"A și B" },
          { label:"-아/어/여서 (cauză→rezultat)", id:"so", pattern:"{A} 그래서 {B}", ro:"Pentru că A, (așa că) B" },
          { label:"-(으)니까 (motiv)", id:"because", pattern:"{A}니까 {B}", ro:"Deoarece A, B" },
          { label:"-는데 (contrast/context)", id:"but", pattern:"{A}는데 {B}", ro:"A, dar B / A, iar B" },
          { label:"-더니 (după ce... s-a întâmplat)", id:"then", pattern:"{A}더니 {B}", ro:"După ce A, s-a întâmplat B" }
        ],
        suggestedChain: {
          steps: [
            "몸에 비누칠했어요.",
            "따뜻한 물을 틀었어요.",
            "물이 차가웠어요.",
            "깜짝 놀랐어요."
          ],
          finalKo: "몸에 비누칠하고 따뜻한 물을 틀었는데, 물이 차가워서 깜짝 놀랐어요.",
          finalRo: "M-am săpunit și am dat drumul la apă caldă, dar apa era rece, așa că am fost foarte surprins(ă)."
        }
      },

      {
        id: "mascara",
        title: "Mascara & timp (negativ + rezultat)",
        level: "A1→A2",
        base: [
          { id:"m1", ko:"시간이 있었어요.", ro:"Am avut timp."},
          { id:"m2", ko:"마스카라를 발랐어요.", ro:"Am aplicat mascara."},
          { id:"m3", ko:"번졌어요.", ro:"S-a întins (s-a șters)."}
        ],
        add: [
          { label:"오래된 (veche) + 마스카라", type:"replace", find:"마스카라를", repl:"오래된 마스카라를", roHint:"mascara veche" },
          { label:"대충 (în grabă)", type:"insertBeforeVerb", verb:"발랐어요.", insert:"대충 ", roHint:"în grabă" },
          { label:"다 (complet)", type:"prefixAdverb", target:"번졌어요.", out:"다 번졌어요.", ro:"S-a întins complet." }
        ],
        modify: [
          { label:"마스카라 → 오래된 마스카라", type:"replace", find:"마스카라를", repl:"오래된 마스카라를", roHint:"mascara veche" }
        ],
        change: [
          { label:"시간이 있었어요 → 시간이 없었어요 (negativ)", type:"replaceSentence", from:"시간이 있었어요.", to:"시간이 없었어요.", roHint:"nu am avut timp" }
        ],
        combine: [
          { label:"-아/어/여서 (cauză→rezultat)", id:"so", pattern:"{A}서 {B}", ro:"Pentru că A, B" },
          { label:"-더니 (acțiune → rezultat observat)", id:"then", pattern:"{A}더니 {B}", ro:"Am făcut A și apoi B" }
        ],
        suggestedChain: {
          steps: [
            "시간이 없었어요.",
            "오래된 마스카라를 대충 발랐어요.",
            "다 번졌어요."
          ],
          finalKo: "시간이 없어서 오래된 마스카라를 대충 발랐더니 다 번졌어요.",
          finalRo: "Nu am avut timp, așa că am aplicat în grabă mascara veche și s-a întins complet."
        }
      },

      {
        id: "glasses",
        title: "Ochelari (imperativ + motiv)",
        level: "A1→A2",
        base: [
          { id:"g1", ko:"안경이 더러워요.", ro:"Ochelarii sunt murdari."},
          { id:"g2", ko:"써요.", ro:"Îi pun (ochelarii)."},
          { id:"g3", ko:"닦아요.", ro:"Îi șterg / lustruiesc."}
        ],
        add: [
          { label:"제 (ai mei)", type:"replace", find:"안경이", repl:"제 안경이", roHint:"ochelarii mei" },
          { label:"너무 (prea)", type:"insertAfterSubject", subject:"안경이", insert:" 너무", roHint:"prea" }
        ],
        modify: [
          { label:"Imperativ: 쓰세요", type:"replaceSentence", from:"써요.", to:"쓰세요.", roHint:"Pune-i." },
          { label:"Imperativ: 닦으세요", type:"replaceSentence", from:"닦아요.", to:"닦으세요.", roHint:"Șterge-i." }
        ],
        change: [
          { label:"Combină cu -기 전에 (înainte de)", type:"infoOnly", note:"Generează: 쓰기 전에 닦으세요." }
        ],
        combine: [
          { label:"-기 전에 (înainte de)", id:"before", pattern:"{A}기 전에 {B}", ro:"Înainte de A, B" },
          { label:"-(으)니까 (motiv)", id:"because", pattern:"{A}니까 {B}", ro:"Pentru că A, B" }
        ],
        suggestedChain: {
          steps: [
            "제 안경이 너무 더러워요.",
            "쓰기 전에 닦으세요."
          ],
          finalKo: "제 안경이 너무 더러우니까 쓰기 전에 닦으세요.",
          finalRo: "Pentru că ochelarii mei sunt prea murdari, șterge-i înainte să îi pui."
        }
      },

      {
        id: "alarm",
        title: "Alarmă (timp + rezultat + deja)",
        level: "A1→A2",
        base: [
          { id:"a1", ko:"알람이 울렸어요.", ro:"A sunat alarma."},
          { id:"a2", ko:"일어났어요.", ro:"M-am trezit."},
          { id:"a3", ko:"졸려요.", ro:"Îmi e somn."}
        ],
        add: [
          { label:"시끄러운 (zgomotoasă)", type:"replace", find:"알람이", repl:"시끄러운 알람이", roHint:"alarmă zgomotoasă" },
          { label:"새벽 5시에 (la 5 dimineața)", type:"prefixTime", target:"알람이 울렸어요.", out:"새벽 5시에 알람이 울렸어요.", ro:"La 5 dimineața a sunat alarma." },
          { label:"너무 일찍 (prea devreme)", type:"replaceSentence", from:"일어났어요.", to:"너무 일찍 일어났어요.", roHint:"m-am trezit prea devreme" },
          { label:"벌써 (deja)", type:"replaceSentence", from:"졸려요.", to:"벌써 졸려요.", roHint:"îmi e deja somn" }
        ],
        modify: [],
        change: [],
        combine: [
          { label:"-아/어/여서 (cauză→rezultat)", id:"so", pattern:"{A}서 {B}", ro:"Așa că" },
          { label:"-더니 (și acum)", id:"then", pattern:"{A}더니 {B}", ro:"După ce A, acum B" }
        ],
        suggestedChain: {
          steps: [
            "새벽 5시에 시끄러운 알람이 울렸어요.",
            "너무 일찍 일어났어요.",
            "벌써 졸려요."
          ],
          finalKo: "새벽 5시에 시끄러운 알람이 울려서 너무 일찍 일어났더니 벌써 졸려요.",
          finalRo: "La 5 dimineața a sunat o alarmă zgomotoasă, m-am trezit prea devreme și deja îmi e somn."
        }
      }
    ];

    /***********************
     *  STATE
     ***********************/
    let currentSet = SETS[0];
    let currentKo = "";
    let currentRo = "";
    let appliedTags = [];
    let history = [];

    const el = (id) => document.getElementById(id);

    function init(){
      // set dropdown
      const s = el("setSelect");
      s.innerHTML = "";
      SETS.forEach(set=>{
        const opt = document.createElement("option");
        opt.value = set.id;
        opt.textContent = `${set.title}`;
        s.appendChild(opt);
      });
      s.value = currentSet.id;
      s.addEventListener("change", ()=>{
        const picked = SETS.find(x=>x.id===s.value);
        if(picked){ currentSet = picked; resetAll(); renderAll(); }
      });

      el("resetBtn").addEventListener("click", ()=>{ resetAll(); renderAll(); });

      el("applyAdd").addEventListener("click", ()=>applyAdd());
      el("undoAdd").addEventListener("click", ()=>undoTag("ADD"));

      el("applyModify").addEventListener("click", ()=>applyModify());
      el("undoModify").addEventListener("click", ()=>undoTag("MODIFY"));

      el("applyChange").addEventListener("click", ()=>applyChange());
      el("undoChange").addEventListener("click", ()=>undoTag("CHANGE"));

      el("applyCombine").addEventListener("click", ()=>applyCombine());

      el("copyKo").addEventListener("click", ()=>copyText(currentKo, "KO copiat."));
      el("copyRo").addEventListener("click", ()=>copyText(currentRo, "RO copiat."));

      el("saveBtn").addEventListener("click", ()=>saveToHistory());

      resetAll();
      renderAll();
    }

    function resetAll(){
      // start from suggested final by default (or first base sentence)
      const sug = currentSet.suggestedChain;
      currentKo = sug?.finalKo || (currentSet.base[0]?.ko ?? "—");
      currentRo = sug?.finalRo || (currentSet.base[0]?.ro ?? "—");
      appliedTags = [{kind:"BASE", label:"Preset (final sugerat)"}];
      history = [];
      renderHistory();
    }

    function renderAll(){
      el("levelLabel").textContent = currentSet.level || "A1";
      renderBase();
      renderSelects();
      renderPreview();
    }

    function renderBase(){
      const wrap = el("baseCards");
      wrap.innerHTML = "";
      currentSet.base.forEach(b=>{
        const c = document.createElement("div");
        c.className = "card";
        c.innerHTML = `
          <div class="korean">${escapeHtml(b.ko)}</div>
          <div class="romanian">${escapeHtml(b.ro)}</div>
          <div class="meta"><span class="tag">BASE</span></div>
        `;
        wrap.appendChild(c);
      });

      // quick action: load suggested chain
      const sug = currentSet.suggestedChain;
      if(sug?.steps?.length){
        const c = document.createElement("div");
        c.className = "card";
        c.innerHTML = `
          <div class="korean">Preset recomandat (ca în carte)</div>
          <div class="romanian">Apasă ca să încarci propoziția finală + fluxul sugerat.</div>
          <div class="meta">
            <span class="tag ok">RECOMANDAT</span>
            <button class="ghost mini" id="loadSuggested">Încarcă presetul</button>
          </div>
        `;
        wrap.prepend(c);
        c.querySelector("#loadSuggested").addEventListener("click", ()=>{
          currentKo = sug.finalKo;
          currentRo = sug.finalRo;
          appliedTags = [{kind:"BASE", label:"Preset (final sugerat)"}];
          renderPreview();
        });
      }
    }

    function renderSelects(){
      // ADD
      const addSel = el("addSelect");
      addSel.innerHTML = "";
      if(!currentSet.add?.length){
        addSel.appendChild(new Option("— nu există —", ""));
      } else {
        currentSet.add.forEach((a,i)=> addSel.appendChild(new Option(a.label, String(i))) );
      }

      // MODIFY
      const modSel = el("modifySelect");
      modSel.innerHTML = "";
      if(!currentSet.modify?.length){
        modSel.appendChild(new Option("— nu există —", ""));
      } else {
        currentSet.modify.forEach((m,i)=> modSel.appendChild(new Option(m.label, String(i))) );
      }

      // CHANGE
      const chSel = el("changeSelect");
      chSel.innerHTML = "";
      if(!currentSet.change?.length){
        chSel.appendChild(new Option("— nu există —", ""));
      } else {
        currentSet.change.forEach((c,i)=> chSel.appendChild(new Option(c.label, String(i))) );
      }

      // COMBINE
      const combSel = el("combineSelect");
      combSel.innerHTML = "";
      if(!currentSet.combine?.length){
        combSel.appendChild(new Option("— nu există —", ""));
      } else {
        currentSet.combine.forEach((c,i)=> combSel.appendChild(new Option(c.label, String(i))) );
      }
    }

    function renderPreview(){
      el("previewKo").textContent = currentKo || "—";
      el("previewRo").textContent = currentRo || "—";

      const meta = el("previewMeta");
      meta.innerHTML = "";
      appliedTags.forEach(t=>{
        const span = document.createElement("span");
        span.className = "tag " + (
          t.kind === "ADD" ? "ok" :
          t.kind === "MODIFY" ? "warn" :
          t.kind === "CHANGE" ? "bad" : ""
        );
        span.textContent = `${t.kind}: ${t.label}`;
        meta.appendChild(span);
      });
    }

    function renderHistory(){
      const h = el("history");
      h.innerHTML = "";
      if(!history.length){
        const empty = document.createElement("div");
        empty.className = "card";
        empty.innerHTML = `<div class="romanian">Nu ai nimic salvat în sesiunea aceasta.</div>`;
        h.appendChild(empty);
        return;
      }
      history.slice().reverse().forEach(item=>{
        const c = document.createElement("div");
        c.className = "card";
        c.innerHTML = `
          <div class="korean">${escapeHtml(item.ko)}</div>
          <div class="romanian">${escapeHtml(item.ro)}</div>
          <div class="meta">
            <span class="tag">${escapeHtml(item.setTitle)}</span>
            <button class="ghost mini">Reîncarcă</button>
          </div>
        `;
        c.querySelector("button").addEventListener("click", ()=>{
          currentKo = item.ko;
          currentRo = item.ro;
          appliedTags = [{kind:"BASE", label:"Reîncărcat din istoric"}];
          renderPreview();
        });
        h.appendChild(c);
      });
    }

    function applyAdd(){
      const idx = parseInt(el("addSelect").value, 10);
      const rule = currentSet.add?.[idx];
      if(!rule) return;

      const res = applyRule(rule);
      if(res){
        appliedTags.push({kind:"ADD", label: rule.label});
        renderPreview();
      }
    }

    function applyModify(){
      const idx = parseInt(el("modifySelect").value, 10);
      const rule = currentSet.modify?.[idx];
      if(!rule) return;

      const res = applyRule(rule);
      if(res){
        appliedTags.push({kind:"MODIFY", label: rule.label});
        renderPreview();
      }
    }

    function applyChange(){
      const idx = parseInt(el("changeSelect").value, 10);
      const rule = currentSet.change?.[idx];
      if(!rule) return;

      const res = applyRule(rule);
      if(res){
        appliedTags.push({kind:"CHANGE", label: rule.label});
        renderPreview();
      }
    }

    function applyCombine(){
      // Pentru universal: pentru fiecare set, COMBINE generează propoziția finală sugerată.
      // (Dacă vrei combinare “din sloturi”, îți leg ulterior la builderul tău existent.)
      const idx = parseInt(el("combineSelect").value, 10);
      const rule = currentSet.combine?.[idx];
      if(!rule) return;

      const sug = currentSet.suggestedChain;
      if(sug?.finalKo && sug?.finalRo){
        currentKo = sug.finalKo;
        currentRo = sug.finalRo;
        appliedTags.push({kind:"COMBINE", label: rule.label});
        renderPreview();
        return;
      }

      // fallback simplu: combină primele două propoziții base cu pattern
      const A = (currentSet.base[0]?.ko ?? "").replace(/\.$/,"");
      const B = (currentSet.base[1]?.ko ?? "").replace(/\.$/,"");
      currentKo = rule.pattern
        .replace("{A}", A)
        .replace("{B}", B) + ".";
      currentRo = rule.ro;
      appliedTags.push({kind:"COMBINE", label: rule.label});
      renderPreview();
    }

    function undoTag(kind){
      // “Undo” pe ultimul tag de acel tip => revenim la preset și reaplicăm restul fără acel tag
      const idx = [...appliedTags].reverse().findIndex(t=>t.kind===kind);
      if(idx === -1) return;

      const realIndex = appliedTags.length - 1 - idx;
      appliedTags.splice(realIndex, 1);

      // Rebuild simplu: revenim la final sugerat și păstrăm doar tag-urile rămase (fără recalcul avansat).
      // Dacă vrei undo perfect (replay reguli), îți introduc stack de transformări.
      const sug = currentSet.suggestedChain;
      currentKo = sug?.finalKo || (currentSet.base[0]?.ko ?? "—");
      currentRo = sug?.finalRo || (currentSet.base[0]?.ro ?? "—");

      // păstrăm doar un marker
      appliedTags = appliedTags.length ? appliedTags : [{kind:"BASE", label:"Preset (final sugerat)"}];
      renderPreview();
    }

    function applyRule(rule){
      if(rule.type === "infoOnly"){
        // doar informație – nu schimbă propoziția
        currentRo = (currentRo || "") + ` (Notă: ${rule.note})`;
        return true;
      }

      if(rule.type === "replace"){
        if(currentKo.includes(rule.find)){
          currentKo = currentKo.replace(rule.find, rule.repl);
          if(rule.roHint) currentRo = addHint(currentRo, rule.roHint);
          return true;
        }
        return false;
      }

      if(rule.type === "replaceSentence"){
        if(currentKo.includes(rule.from)){
          currentKo = currentKo.replace(rule.from, rule.to);
          if(rule.roHint) currentRo = addHint(currentRo, rule.roHint);
          return true;
        }
        return false;
      }

      if(rule.type === "prefixObject" || rule.type === "prefixAdverb" || rule.type === "prefixTime"){
        // for these we replace target sentence if present, else set directly
        if(currentKo.includes(rule.target)){
          currentKo = currentKo.replace(rule.target, rule.out);
          if(rule.ro) currentRo = rule.ro;
          return true;
        }
        // fallback: if target not found, set sentence directly
        currentKo = rule.out;
        if(rule.ro) currentRo = rule.ro;
        return true;
      }

      if(rule.type === "insertBeforeVerb"){
        // crude: insert before the verb token if present
        if(currentKo.includes(rule.verb)){
          currentKo = currentKo.replace(rule.verb, rule.insert + rule.verb);
          if(rule.roHint) currentRo = addHint(currentRo, rule.roHint);
          return true;
        }
        return false;
      }

      if(rule.type === "insertAfterSubject"){
        // insert after subject token occurrence
        const token = rule.subject;
        const i = currentKo.indexOf(token);
        if(i !== -1){
          const before = currentKo.slice(0, i + token.length);
          const after  = currentKo.slice(i + token.length);
          currentKo = before + rule.insert + after;
          if(rule.roHint) currentRo = addHint(currentRo, rule.roHint);
          return true;
        }
        return false;
      }

      return false;
    }

    function addHint(ro, hint){
      // păstrează RO curent, adaugă o paranteză scurtă dacă nu există deja
      if(!ro) return ro;
      if(ro.includes(hint)) return ro;
      return ro + ` (hint: ${hint})`;
    }

    async function copyText(txt, okMsg){
      try{
        await navigator.clipboard.writeText(txt || "");
        el("copyStatus").textContent = okMsg;
        el("copyStatus").className = "small copyOk";
        setTimeout(()=>{ el("copyStatus").textContent=""; }, 1200);
      }catch(e){
        el("copyStatus").textContent = "Nu pot copia (browser restrictions).";
        el("copyStatus").className = "small";
      }
    }

    function saveToHistory(){
      if(!currentKo) return;
      history.push({ ko: currentKo, ro: currentRo, setTitle: currentSet.title });
      renderHistory();
    }

    function escapeHtml(str){
      return (str ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    init();
  </script>
</body>
</html>
