<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Extension Practice — Light</title>
  <style>
    :root{
      --bg:#f8eef3;
      --panel:#ffffff;
      --card:#fff7fb;
      --text:#3b2f36;
      --muted:#8f6b7b;
      --accent:#e79ab5;
      --line:#f0d7e2;
      --dash:#e7b9cc;
      --shadow: 0 10px 22px rgba(0,0,0,.05);
    }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .wrap{ max-width: 1100px; margin: 0 auto; padding: 26px 16px 40px; }
    h1{ margin:0 0 10px; font-size: 26px; letter-spacing:.2px; }
    .sub{ color: var(--muted); font-size: 13px; margin-bottom: 18px; }

    .grid3{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 18px;
    }
    @media (max-width: 980px){ .grid3{ grid-template-columns:1fr; } }

    .card{
      background: var(--panel);
      border: 1px dashed var(--dash);
      border-radius: 18px;
      padding: 18px 16px 14px;
      box-shadow: var(--shadow);
    }

    .ko{ font-size: 22px; line-height: 1.25; text-align:center; }
    .ro{ font-size: 13px; color: var(--muted); text-align:center; margin-top: 6px; }

    .chipRow{
      margin-top: 14px;
      display:flex;
      justify-content:center;
      flex-wrap:wrap;
      gap:10px;
    }
    .chipGroup{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:center;
    }
    .groupTitle{
      width:100%;
      text-align:center;
      font-size:12px;
      color: var(--muted);
      margin-top: 6px;
    }
    .chip{
      border: 1px solid var(--line);
      background: #fff;
      color: var(--text);
      border-radius: 999px;
      padding: 8px 10px;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
      transition: .12s ease;
    }
    .chip:hover{ background: rgba(231,154,181,.10); border-color: rgba(231,154,181,.55); }
    .chip:active{ transform: translateY(1px); }
    .chip.disabled{
      opacity:.45;
      pointer-events:none;
      background: #fafafa;
    }
    .chip.add{ border-color: rgba(231,154,181,.45); }
    .chip.modify{ border-color: rgba(143,107,123,.35); }
    .chip.change{ border-color: rgba(231,154,181,.45); }

    .actions{
      margin-top: 12px;
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    button{
      background: #fff;
      border: 1px solid var(--line);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      cursor:pointer;
    }
    button:hover{ background: rgba(231,154,181,.10); border-color: rgba(231,154,181,.55); }

    .expanded{
      margin-top: 14px;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px 12px;
    }
    .expanded .ko{ font-size: 22px; font-weight: 650; }
    .expanded .ro{ margin-top: 6px; }

    .combineBlock{
      margin-top: 22px;
      padding: 16px;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
    }
    .combineTitle{
      text-align:center;
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 10px;
    }
    .centerRow{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom: 12px;
    }
    select{
      background:#fff;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      outline:none;
      min-width: 260px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--muted);
      font-size: 12px;
    }
    .pill strong{ color: var(--accent); }

    .resultBox{
      background: var(--card);
      border: 2px solid rgba(231,154,181,.55);
      border-radius: 18px;
      padding: 16px 14px;
      text-align:center;
    }

    .copyRow{
      margin-top: 10px;
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .status{ font-size:12px; color: var(--muted); }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Extension Practice</h1>
  <div class="sub">Click pe ADD / MODIFY / CHANGE pe fiecare propoziție → COMBINE în 2 pași → fraza finală</div>

  <div class="grid3" id="cards"></div>

  <div class="combineBlock">
    <div class="combineTitle">COMBINE 1 (Propoziția 1 + Propoziția 2)</div>
    <div class="centerRow">
      <span class="pill"><strong>Conector</strong></span>
      <select id="c1"></select>
      <button id="gen12">Generează</button>
    </div>
    <div class="resultBox">
      <div class="ko" id="outKo12">—</div>
      <div class="ro" id="outRo12">—</div>
    </div>
  </div>

  <div class="combineBlock">
    <div class="combineTitle">COMBINE 2 (Rezultatul de sus + Propoziția 3)</div>
    <div class="centerRow">
      <span class="pill"><strong>Conector</strong></span>
      <select id="c2"></select>
      <button id="genFinal">Generează</button>
    </div>
    <div class="resultBox">
      <div class="ko" id="finalKo">—</div>
      <div class="ro" id="finalRo">—</div>
    </div>
    <div class="copyRow">
      <button id="copyKo">Copiază KO</button>
      <button id="copyRo">Copiază RO</button>
      <span class="status" id="status"></span>
    </div>
  </div>
</div>

<script>
/********************************************************
 * TEMPLATE reutilizabil: schimbi DOAR obiectul LESSON
 ********************************************************/
const LESSON = {
  title: "Duș (exemplu)",
  cards: [
    {
      base: { ko:"비누칠했어요.", ro:"M-am săpunit." },
      add: [
        { id:"add_body", label:"ADD 몸에", type:"prefix", outKo:"몸에 비누칠했어요.", outRo:"M-am săpunit pe corp." }
      ],
      modify: [],
      change: []
    },
    {
      base: { ko:"물을 틀었어요.", ro:"Am dat drumul la apă." },
      add: [],
      modify: [
        { id:"mod_warm", label:"MODIFY 따뜻한", type:"replace", find:"물을", repl:"따뜻한 물을", roHint:"apă caldă" }
      ],
      change: []
    },
    {
      base: { ko:"놀랐어요.", ro:"Am fost surprins(ă)." },
      add: [
        { id:"add_surpr", label:"ADD 깜짝", type:"prefix", outKo:"깜짝 놀랐어요.", outRo:"Am fost foarte surprins(ă)." }
      ],
      modify: [],
      change: []
    }
  ],
  // Conectori: 1 = aproape mereu -고; 2 = cauză/contrast/condiție etc.
  connectors1: [
    { id:"go", label:"-고 (și)", roJoin:"și" }
  ],
  connectors2: [
    { id:"so", label:"-아/어/여서 (cauză → rezultat)", roJoin:"așa că" },
    { id:"nikka", label:"-(으)니까 (motiv)", roJoin:"pentru că" },
    { id:"neunde", label:"-(으)ㄴ데 / -는데 (contrast/context)", roJoin:"dar" },
    { id:"deoni", label:"-더니 (după ce...)", roJoin:"și apoi" },
    { id:"before", label:"-기 전에 (înainte de)", roJoin:"înainte să" },
    { id:"ryeomyeon", label:"-(으)려면 (dacă vreau să...)", roJoin:"dacă vreau să" }
  ]
};

/********************************************************
 * ENGINE: reguli + conectoare legate de verb
 ********************************************************/
const el = (id) => document.getElementById(id);
const norm = (s) => (s || "").trim().replace(/\s+/g," ");
const stripPunct = (s) => norm(s).replace(/[.?!]$/,"");

function addHint(ro, hint){
  if(!ro) return ro;
  if(ro.includes(hint)) return ro;
  return ro + ` (hint: ${hint})`;
}

function applyRule(rule, ko, ro){
  let newKo = ko, newRo = ro;

  if(rule.type === "prefix"){
    newKo = rule.outKo;
    newRo = rule.outRo ?? ro;
    return { ok:true, ko:norm(newKo), ro:newRo };
  }

  if(rule.type === "replace"){
    if(newKo.includes(rule.find)){
      newKo = newKo.replace(rule.find, rule.repl);
      if(rule.roHint) newRo = addHint(newRo, rule.roHint);
      return { ok:true, ko:norm(newKo), ro:newRo };
    }
    return { ok:false, ko, ro };
  }

  // (opțional) pentru adverbe ușor: "빨리" înainte de predicat
  if(rule.type === "insertBeforePredicate"){
    const s = norm(newKo);
    const punct = /[.?!]$/.test(s) ? s.slice(-1) : "";
    const core = punct ? s.slice(0,-1) : s;
    const parts = core.split(" ");
    const pred = parts[parts.length-1];
    const prefix = parts.slice(0,-1).join(" ");
    const insert = (rule.insert || "").trim();
    if(!insert) return { ok:false, ko, ro };
    newKo = norm((prefix ? prefix + " " : "") + insert + " " + pred) + punct;
    if(rule.roHint) newRo = addHint(newRo, rule.roHint);
    return { ok:true, ko:newKo, ro:newRo };
  }

  return { ok:false, ko, ro };
}

function normalizeKoSentence(s){ return norm(s); }
function stripFinalPunct(s){ return normalizeKoSentence(s).replace(/[.?!]$/,"").trim(); }
function ensurePeriod(ko){ const t = normalizeKoSentence(ko); return /[.?!]$/.test(t) ? t : (t + "."); }

function splitIntoPrefixAndPredicate(sentenceNoPunct){
  const s = normalizeKoSentence(sentenceNoPunct);
  const parts = s.split(" ");
  if(parts.length === 1) return { prefix:"", pred: parts[0] };
  return { prefix: parts.slice(0,-1).join(" "), pred: parts[parts.length-1] };
}
function analyzePredicate(pred){
  if(pred.endsWith("했어요")) return { kind:"ha_past", stem: pred.slice(0,-3) };
  if(pred.endsWith("았어요")) return { kind:"past", stem: pred.slice(0,-3), aeo:"아", past:"았" };
  if(pred.endsWith("었어요")) return { kind:"past", stem: pred.slice(0,-3), aeo:"어", past:"었" };
  if(pred.endsWith("였어요")) return { kind:"past", stem: pred.slice(0,-3), aeo:"여", past:"였" };

  if(pred.endsWith("해요")) return { kind:"ha_pres", stem: pred.slice(0,-2) };
  if(pred.endsWith("아요")) return { kind:"pres", stem: pred.slice(0,-2) };
  if(pred.endsWith("어요")) return { kind:"pres", stem: pred.slice(0,-2) };
  if(pred.endsWith("여요")) return { kind:"pres", stem: pred.slice(0,-2) };

  if(pred.endsWith("이에요")) return { kind:"cop", stem: pred.slice(0,-2) };
  if(pred.endsWith("예요")) return { kind:"cop", stem: pred.slice(0,-2) };
  if(pred.endsWith("세요")) return { kind:"imp", stem: pred.slice(0,-2) };

  return { kind:"unknown", stem: pred };
}
function joinPrefix(prefix, tail){ return prefix ? (prefix + " " + tail) : tail; }

function toConnective(sentence, connectorId){
  const s = stripFinalPunct(sentence);
  const { prefix, pred } = splitIntoPrefixAndPredicate(s);
  const a = analyzePredicate(pred);

  if(connectorId === "go"){
    if(a.kind === "ha_past" || a.kind === "ha_pres"){
      return prefix ? (prefix + "하고") : (a.stem + "하고");
    }
    if(a.kind === "past" || a.kind === "pres" || a.kind === "imp"){
      return joinPrefix(prefix, a.stem) + "고";
    }
    return joinPrefix(prefix, pred) + "고";
  }

  if(connectorId === "so"){
    if(a.kind === "ha_past" || a.kind === "ha_pres"){
      return prefix ? (prefix + "해서") : (a.stem + "해서");
    }
    if(a.kind === "past"){
      return joinPrefix(prefix, a.stem + a.aeo) + "서";
    }
    if(a.kind === "pres"){
      return joinPrefix(prefix, a.stem) + "서";
    }
    return joinPrefix(prefix, pred) + "서";
  }

  if(connectorId === "nikka"){
    if(a.kind === "ha_past") return prefix ? (prefix + "했으니까") : (a.stem + "했으니까");
    if(a.kind === "ha_pres") return joinPrefix(prefix, a.stem + "하") + "니까";
    if(a.kind === "past") return joinPrefix(prefix, a.stem + a.past) + "으니까";
    if(a.kind === "pres") return joinPrefix(prefix, a.stem) + "니까";
    return joinPrefix(prefix, pred) + "니까";
  }

  if(connectorId === "neunde"){
    if(a.kind === "ha_past") return prefix ? (prefix + "했는데") : (a.stem + "했는데");
    if(a.kind === "ha_pres") return joinPrefix(prefix, a.stem + "하") + "는데";
    if(a.kind === "past") return joinPrefix(prefix, a.stem + a.past) + "는데";
    if(a.kind === "pres") return joinPrefix(prefix, a.stem) + "는데";
    return joinPrefix(prefix, pred) + "는데";
  }

  if(connectorId === "deoni"){
    if(a.kind === "ha_past") return prefix ? (prefix + "했더니") : (a.stem + "했더니");
    if(a.kind === "past") return joinPrefix(prefix, a.stem + a.past) + "더니";
    if(a.kind === "pres") return joinPrefix(prefix, a.stem) + "더니";
    return joinPrefix(prefix, pred) + "더니";
  }

  if(connectorId === "before"){
    if(a.kind === "ha_past" || a.kind === "ha_pres"){
      const baseVerb = joinPrefix(prefix, a.stem + "하");
      return baseVerb + "기 전에";
    }
    if(a.kind === "past" || a.kind === "pres" || a.kind === "imp"){
      return joinPrefix(prefix, a.stem) + "기 전에";
    }
    return joinPrefix(prefix, pred) + "기 전에";
  }

  if(connectorId === "ryeomyeon"){
    if(a.kind === "ha_past" || a.kind === "ha_pres"){
      const baseVerb = joinPrefix(prefix, a.stem + "하");
      return baseVerb + "려면";
    }
    if(a.kind === "past" || a.kind === "pres" || a.kind === "imp"){
      return joinPrefix(prefix, a.stem) + "려면";
    }
    return joinPrefix(prefix, pred) + "려면";
  }

  return s;
}

/********************************************************
 * UI: click pe chip-uri (ADD/MODIFY/CHANGE)
 ********************************************************/
const state = {
  cards: LESSON.cards.map(c => ({
    ko: c.base.ko,
    ro: c.base.ro,
    appliedIds: new Set() // ca să putem dezactiva chip-uri deja aplicate (light)
  })),
  combined12: { ko:"", ro:"" },
  final: { ko:"", ro:"" }
};

function makeChip(rule, kind, onClick){
  const b = document.createElement("button");
  b.type = "button";
  b.className = `chip ${kind}`;
  b.textContent = rule.label;
  b.addEventListener("click", onClick);
  return b;
}

function render(){
  // cards
  const cardsWrap = el("cards");
  cardsWrap.innerHTML = "";

  LESSON.cards.forEach((card, i) => {
    const sec = document.createElement("section");
    sec.className = "card";

    const baseKo = document.createElement("div");
    baseKo.className = "ko";
    baseKo.textContent = card.base.ko;

    const baseRo = document.createElement("div");
    baseRo.className = "ro";
    baseRo.textContent = card.base.ro;

    const expanded = document.createElement("div");
    expanded.className = "expanded";

    const outKo = document.createElement("div");
    outKo.className = "ko";
    outKo.textContent = state.cards[i].ko;

    const outRo = document.createElement("div");
    outRo.className = "ro";
    outRo.textContent = state.cards[i].ro;

    expanded.appendChild(outKo);
    expanded.appendChild(outRo);

    const chipRow = document.createElement("div");
    chipRow.className = "chipRow";

    // ADD group
    const addWrap = document.createElement("div");
    addWrap.className = "chipGroup";
    const addTitle = document.createElement("div");
    addTitle.className = "groupTitle";
    addTitle.textContent = "ADD";
    addWrap.appendChild(addTitle);

    (card.add || []).forEach(rule => {
      const chip = makeChip(rule, "add", () => {
        const res = applyRule(rule, state.cards[i].ko, state.cards[i].ro);
        if(!res.ok) return;
        state.cards[i].ko = res.ko;
        state.cards[i].ro = res.ro;
        state.cards[i].appliedIds.add(rule.id);
        render(); // re-render ca să dezactiveze chip-ul aplicat
      });
      if(state.cards[i].appliedIds.has(rule.id)) chip.classList.add("disabled");
      addWrap.appendChild(chip);
    });

    // MODIFY group
    const modWrap = document.createElement("div");
    modWrap.className = "chipGroup";
    const modTitle = document.createElement("div");
    modTitle.className = "groupTitle";
    modTitle.textContent = "MODIFY";
    modWrap.appendChild(modTitle);

    (card.modify || []).forEach(rule => {
      const chip = makeChip(rule, "modify", () => {
        const res = applyRule(rule, state.cards[i].ko, state.cards[i].ro);
        if(!res.ok) return;
        state.cards[i].ko = res.ko;
        state.cards[i].ro = res.ro;
        state.cards[i].appliedIds.add(rule.id);
        render();
      });
      if(state.cards[i].appliedIds.has(rule.id)) chip.classList.add("disabled");
      modWrap.appendChild(chip);
    });

    // CHANGE group (în template poți pune reguli care schimbă ending; aici lăsăm placeholder)
    const chWrap = document.createElement("div");
    chWrap.className = "chipGroup";
    const chTitle = document.createElement("div");
    chTitle.className = "groupTitle";
    chTitle.textContent = "CHANGE";
    chWrap.appendChild(chTitle);

    (card.change || []).forEach(rule => {
      const chip = makeChip(rule, "change", () => {
        const res = applyRule(rule, state.cards[i].ko, state.cards[i].ro);
        if(!res.ok) return;
        state.cards[i].ko = res.ko;
        state.cards[i].ro = res.ro;
        state.cards[i].appliedIds.add(rule.id);
        render();
      });
      if(state.cards[i].appliedIds.has(rule.id)) chip.classList.add("disabled");
      chWrap.appendChild(chip);
    });

    // dacă nu există reguli într-un grup, îl ascundem (light)
    if((card.add||[]).length) chipRow.appendChild(addWrap);
    if((card.modify||[]).length) chipRow.appendChild(modWrap);
    if((card.change||[]).length) chipRow.appendChild(chWrap);

    const actions = document.createElement("div");
    actions.className = "actions";

    const resetBtn = document.createElement("button");
    resetBtn.textContent = "Reset";
    resetBtn.addEventListener("click", ()=>{
      state.cards[i].ko = card.base.ko;
      state.cards[i].ro = card.base.ro;
      state.cards[i].appliedIds.clear();
      render();
    });

    actions.appendChild(resetBtn);

    sec.appendChild(baseKo);
    sec.appendChild(baseRo);
    sec.appendChild(chipRow);
    sec.appendChild(actions);
    sec.appendChild(expanded);

    cardsWrap.appendChild(sec);
  });

  // combine selects
  fillConnectors();
  // generate outputs (live)
  combine12();
  combineFinal();
}

function fillConnectors(){
  // c1
  const c1 = el("c1");
  if(c1.options.length === 0){
    LESSON.connectors1.forEach((c,idx)=> c1.appendChild(new Option(c.label, String(idx))));
    c1.value = "0";
  }
  // c2
  const c2 = el("c2");
  if(c2.options.length === 0){
    LESSON.connectors2.forEach((c,idx)=> c2.appendChild(new Option(c.label, String(idx))));
    c2.value = "0";
  }
}

function combine12(){
  const rule = LESSON.connectors1[parseInt(el("c1").value,10)] || LESSON.connectors1[0];
  const A = state.cards[0].ko;
  const B = state.cards[1].ko;

  const Aconn = toConnective(A, rule.id);
  state.combined12.ko = norm(Aconn + " " + stripFinalPunct(B) + ".");
  state.combined12.ro = `${stripPunct(state.cards[0].ro)} ${rule.roJoin} ${stripPunct(state.cards[1].ro)}.`;

  el("outKo12").textContent = state.combined12.ko;
  el("outRo12").textContent = state.combined12.ro;
}

function combineFinal(){
  const rule = LESSON.connectors2[parseInt(el("c2").value,10)] || LESSON.connectors2[0];
  const X = state.combined12.ko;
  const C = state.cards[2].ko;

  const Xconn = toConnective(X, rule.id);
  state.final.ko = ensurePeriod(norm(Xconn + " " + stripFinalPunct(C)));
  state.final.ro = `${stripPunct(state.combined12.ro)} ${rule.roJoin} ${stripPunct(state.cards[2].ro)}.`;

  el("finalKo").textContent = state.final.ko;
  el("finalRo").textContent = state.final.ro;
}

async function copyText(txt, okMsg){
  try{
    await navigator.clipboard.writeText(txt || "");
    el("status").textContent = okMsg;
    setTimeout(()=> el("status").textContent="", 1200);
  }catch{
    el("status").textContent = "Nu pot copia (browser restrictions).";
  }
}

function wire(){
  el("gen12").addEventListener("click", ()=> combine12());
  el("genFinal").addEventListener("click", ()=> combineFinal());
  el("c1").addEventListener("change", ()=> combine12());
  el("c2").addEventListener("change", ()=> combineFinal());

  el("copyKo").addEventListener("click", ()=> copyText(state.final.ko, "KO copiat."));
  el("copyRo").addEventListener("click", ()=> copyText(state.final.ro, "RO copiat."));
}

wire();
render();
</script>
</body>
</html>
