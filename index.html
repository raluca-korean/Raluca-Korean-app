<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Raluca Korean â€“ Builder Multi-Clause Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root{
      --bg1:#dff3ff;
      --bg2:#ffe9ff;
      --bg3:#f4fffc;
      --bg4:#e8f0ff;

      --accent:#7b5dff;
      --card-bg:#ffffffcc;
      --text-main:#2f343b;
      --text-soft:#7a8088;
      --border:#e1d7c7;
    }

    *{box-sizing:border-box;}

    body{
      margin:0;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      color:var(--text-main);
      background:linear-gradient(120deg,var(--bg1),var(--bg2),var(--bg3),var(--bg4));
      background-size:380% 380%;
      animation:bgFlow 28s ease-in-out infinite;
    }
    @keyframes bgFlow{
      0%{background-position:0% 50%;}
      50%{background-position:100% 50%;}
      100%{background-position:0% 50%;}
    }

    .app{
      max-width:1040px;
      margin:0 auto;
      padding:18px 14px 80px;
    }

    .rk-header{
      position:relative;
      padding:12px 16px 16px;
      border-radius:26px;
      background:linear-gradient(120deg,#6fb8ff,#a774ff,#ff7fd1);
      color:#fff;
      box-shadow:0 18px 45px rgba(77,93,255,0.4);
    }
    .rk-header-main{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .rk-header-main h1{
      margin:0;
      font-size:20px;
      font-weight:900;
      letter-spacing:0.06em;
      text-transform:uppercase;
    }
    .rk-badge{
      font-size:11px;
      font-weight:600;
      padding:4px 9px;
      border-radius:999px;
      background:rgba(255,255,255,0.18);
      border:1px solid rgba(255,255,255,0.4);
    }
    #subtitle{
      margin:8px 0 0;
      font-size:12px;
      opacity:0.95;
    }

    .card{
      margin-top:16px;
      padding:16px 18px 18px;
      border-radius:22px;
      background:var(--card-bg);
      backdrop-filter:blur(16px);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 18px 40px rgba(0,0,0,0.12);
    }
    .card h2{
      margin:0 0 8px;
      font-size:16px;
      font-weight:800;
      letter-spacing:0.03em;
    }

    textarea{
      width:100%;
      border-radius:16px;
      border:1px solid var(--border);
      padding:10px 12px;
      font-size:14px;
      resize:vertical;
      min-height:70px;
      color:var(--text-main);
      background:#fff;
    }
    textarea:focus{
      outline:none;
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.9),
        0 0 0 3px rgba(149,120,255,0.5);
      border-color:rgba(149,120,255,0.7);
    }

    .btn-row{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    button{
      border:none;
      border-radius:999px;
      padding:8px 16px;
      font-size:12px;
      font-weight:800;
      cursor:pointer;
      color:#fff;
      background:linear-gradient(135deg,#6b8cff,#9b6bff);
      box-shadow:
        0 10px 24px rgba(108,110,210,0.4),
        0 0 0 1px rgba(255,255,255,0.7) inset;
      transition:transform .12s ease, box-shadow .12s ease, filter .12s ease;
    }
    button.secondary{
      background:linear-gradient(135deg,#ff9a6c,#ff5f8c);
    }
    button:hover{
      transform:translateY(-1px);
      box-shadow:0 12px 26px rgba(0,0,0,0.18);
      filter:brightness(1.03);
    }
    button:active{
      transform:translateY(1px) scale(0.98);
      box-shadow:0 6px 16px rgba(0,0,0,0.25);
      filter:brightness(0.97);
    }

    .section-title{
      margin-top:18px;
      margin-bottom:6px;
      font-size:13px;
      font-weight:800;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:#4b607d;
    }

    .table-block{
      margin-top:10px;
      padding:10px 10px 12px;
      border-radius:20px;
      background:var(--card-bg);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 14px 30px rgba(0,0,0,0.1);
    }
    .table-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:12px;
      font-weight:800;
      color:var(--text-soft);
      margin-bottom:6px;
    }
    .table-horizontal{
      display:flex;
      gap:8px;
      overflow-x:auto;
      padding-bottom:4px;
    }

    .col{
      min-width:110px;
      max-width:150px;
      flex:0 0 auto;
      border-radius:16px;
      padding:7px 7px 9px;
      background:radial-gradient(circle at top left,#fdfbf7,#f2ebde);
      border:1px solid #e2d7c8;
      box-shadow:0 10px 22px rgba(95,78,58,0.16);
    }
    .col-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:4px;
      font-size:10px;
      font-weight:900;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:#7b5dff;
      border-bottom:1px solid rgba(208,196,255,0.8);
      padding-bottom:2px;
      margin-bottom:3px;
    }
    .col-header::before{
      content:"";
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:16px;
      height:16px;
      border-radius:6px;
      background:#fff;
      font-size:11px;
      box-shadow:0 1px 3px rgba(0,0,0,0.06);
    }
    .col[data-key="subject"] .col-header::before{content:"ğŸ‘¤";}
    .col[data-key="time"]    .col-header::before{content:"â°";}
    .col[data-key="place"]   .col-header::before{content:"ğŸ“";}
    .col[data-key="mod"]     .col-header::before{content:"âœ¨";}
    .col[data-key="object"]  .col-header::before{content:"ğŸ¯";}
    .col[data-key="numeral"] .col-header::before{content:"#ï¸âƒ£";}
    .col[data-key="counter"] .col-header::before{content:"ğŸ”¢";}
    .col[data-key="verb"]    .col-header::before{content:"ğŸš€";}
    .col[data-key="conj"]    .col-header::before{content:"ğŸ”—";}

    .col-body-label{
      font-size:10px;
      color:#938777;
      margin-bottom:1px;
    }
    .col-body-main{
      font-size:15px;
      font-weight:900;
      min-height:1.4em;
    }
    .col-body-main[contenteditable="true"]{
      outline:none;
      cursor:text;
    }
    .col-body-main:focus{
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.8),
        0 0 0 2px rgba(149,120,255,0.7);
      border-radius:6px;
    }

    .col-body-extra.example{
      margin-top:2px;
      font-size:10px;
      color:#b09b83;
    }

    .preview-card{
      margin-top:14px;
      padding:12px 14px;
      border-radius:20px;
      background:var(--card-bg);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 16px 32px rgba(0,0,0,0.12);
    }
    .preview-title{
      font-size:12px;
      font-weight:900;
      color:#4b607d;
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:6px;
    }
    .preview-sentence{
      font-size:22px;
      font-weight:900;
      line-height:1.6;
      margin-bottom:4px;
      word-break:keep-all;
    }
    .preview-ro{
      font-size:12px;
      color:var(--text-soft);
    }

    .hint{
      margin-top:6px;
      font-size:11px;
      color:var(--text-soft);
      line-height:1.4;
    }
    code.k{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      background: rgba(255,255,255,0.7);
      border: 1px solid rgba(0,0,0,0.06);
      padding: 1px 6px;
      border-radius: 999px;
    }

    @media (max-width:600px){
      .rk-header-main h1{font-size:17px;}
      .col{min-width:95px;}
    }
  </style>
</head>

<body>
  <div class="app">
    <header class="rk-header">
      <div class="rk-header-main">
        <h1>RALUCA KOREAN</h1>
        <span class="rk-badge">Builder â€“ Multi Clause</span>
      </div>
      <p id="subtitle">
        Split pe conectori multipli + P2/P3/P4â€¦ + endings lipite de verb (infinitiv Ã®n tabel).
      </p>
    </header>

    <!-- Input -->
    <section class="card" id="roCard">
      <h2>RomÃ¢nÄƒ / English â†’ CoreeanÄƒ (auto-fill)</h2>
      <div style="margin-bottom:6px;font-size:11px;color:var(--text-soft);display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
        <span>Limba propoziÈ›iei:</span>
        <select id="langSelect" style="padding:2px 8px;border-radius:999px;border:1px solid var(--border);font-size:11px;">
          <option value="ro" selected>RomÃ¢nÄƒ</option>
          <option value="en">English</option>
        </select>
      </div>

      <textarea id="inputText" placeholder="Ex: AstÄƒzi merg la cafenea È™i citesc o carte È™i beau o cafea.
Today I go to the cafe and read a book and drink a coffee."></textarea>

      <div class="btn-row">
        <button id="autoFillBtn">CompleteazÄƒ automat builder-ul</button>
        <button id="clearBtn" class="secondary">CurÄƒÈ›Äƒ tot</button>
      </div>

      <div class="hint">
        Reguli de bazÄƒ:
        <br>â€¢ <b>È™i / and</b> â†’ <code class="k">-ê³ </code> (lipit de verbul dinainte).
        <br>â€¢ <b>dar / but</b> â†’ <code class="k">-ì§€ë§Œ</code>
        <br>â€¢ <b>pentru cÄƒ / because</b> â†’ <code class="k">-ì–´ì„œ</code> (poÈ›i schimba manual la <code class="k">-ì•„ì„œ</code>)
        <br>â€¢ <b>dacÄƒ / if</b> â†’ <code class="k">-(ìœ¼)ë©´</code>
        <br>â€¢ <b>cÃ¢nd / atunci cÃ¢nd / when</b> â†’ <code class="k">-(ìœ¼)ã„¹ ë•Œ</code>
        <br>â€¢ <b>ca sÄƒ / in order to / to</b> â†’ <code class="k">-(ìœ¼)ë ¤ê³ </code>
      </div>
    </section>

    <h3 class="section-title">Builder (clauze)</h3>
    <div id="clausesHost"></div>

    <!-- Preview -->
    <section class="preview-card">
     <div class="preview-title">
  <span>PropoziÈ›ia finalÄƒ Ã®n coreeanÄƒ</span>

  <label style="display:flex;align-items:center;gap:6px;font-size:11px;color:var(--text-soft);font-weight:800;">
    <input type="checkbox" id="politeLast" />
    PoliteÈ›e (doar ultima clauzÄƒ)
  </label>
</div>
      <script>
(function () {
  // ============================================================
  // 0) Helpers
  // ============================================================
  function normalizeText(text) {
    if (!text) return "";
    let t = text.toLowerCase();
    t = t.replace(/ÅŸ/g, "È™").replace(/Å£/g, "È›");
    t = t.replace(/[.,!?;:]/g, " ");
    t = t.replace(/\s+/g, " ").trim();
    return t;
  }

  function escapeRegExp(s) {
    return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  // ============================================================
  // 1) CONNECTORS (RO/EN) -> KO endings (default)
  // ============================================================
  const CONNECTOR_MAP = [
    // long first
    { keys: ["atunci cÃ¢nd", "atunci cand", "when"], type: "ending", ko: "-(ìœ¼)ã„¹ ë•Œ" },
    { keys: ["pentru cÄƒ", "pentru ca", "fiindcÄƒ", "fiindca", "because"], type: "ending", ko: "-ì–´ì„œ" },
    { keys: ["ca sÄƒ", "ca sa", "pentru a", "in order to"], type: "ending", ko: "-(ìœ¼)ë ¤ê³ " },
    { keys: ["dacÄƒ", "daca", "if"], type: "ending", ko: "-(ìœ¼)ë©´" },
    { keys: ["deÈ™i", "desi", "although", "even though"], type: "ending", ko: "-ì§€ë§Œ" },
    { keys: ["dar", "but"], type: "ending", ko: "-ì§€ë§Œ" },
    { keys: ["È™i", "si", "and"], type: "ending", ko: "-ê³ " },
  ];

  const CONNECTOR_KEYS = Array.from(
    new Set(CONNECTOR_MAP.flatMap(x => x.keys))
  ).sort((a, b) => b.length - a.length);

  const CONNECTOR_REGEX = new RegExp("\\s(" + CONNECTOR_KEYS.map(escapeRegExp).join("|") + ")\\s", "ig");

  function splitIntoChain(raw) {
    const original = (raw || "").replace(/\s+/g, " ").trim();
    const t = normalizeText(original);
    if (!t) return { clauses: [], links: [] };

    const parts = [];
    let lastIndex = 0;
    let m;
    while ((m = CONNECTOR_REGEX.exec(t)) !== null) {
      const before = t.slice(lastIndex, m.index).trim();
      const token = (m[1] || "").trim().toLowerCase();
      if (before) parts.push({ kind: "clause", text: before });
      parts.push({ kind: "conn", text: token });
      lastIndex = m.index + m[0].length;
    }
    const tail = t.slice(lastIndex).trim();
    if (tail) parts.push({ kind: "clause", text: tail });

    const clauses = [];
    const linksRaw = [];
    for (const p of parts) {
      if (p.kind === "clause") clauses.push(p.text);
      else linksRaw.push(p.text);
    }
    while (linksRaw.length >= clauses.length) linksRaw.pop();

    const links = linksRaw.map(tok => {
      const mapped = CONNECTOR_MAP.find(x => x.keys.includes(tok));
      return mapped ? { raw: tok, type: mapped.type, ko: mapped.ko } : { raw: tok, type: "ending", ko: "-ê³ " };
    });

    return { clauses, links };
  }

  // ============================================================
  // 2) RULES RO -> KO, EN -> KO (fixed clean base, extensible)
  // ============================================================
  const RO_RULES = {
    subject: [
      { re: /\beu\s*\(informal\)|\beu\s*-\s*informal\b/, value: "ë‚˜" },
      { re: /\beu\s*\(formal\)|\beu\s*-\s*formal\b/, value: "ì €" },
      { re: /\beu\b/, value: "ì €" },
      { re: /\btu\b/, value: "ë„ˆ" },
      { re: /\bnoi\b/, value: "ìš°ë¦¬" },
      { re: /\bel\b/, value: "ê·¸" },
      { re: /\bea\b/, value: "ê·¸ë…€" },
    ],
    time: [
      { re: /\bazi\b|\bastÄƒzi\b/, value: "ì˜¤ëŠ˜" },
      { re: /\bmÃ¢ine\b/, value: "ë‚´ì¼" },
      { re: /\bieri\b/, value: "ì–´ì œ" },
      { re: /\bacum\b/, value: "ì§€ê¸ˆ" },
      { re: /\bdiminea(È›|t)a\b/, value: "ì•„ì¹¨ì—" },
      { re: /\bseara\b/, value: "ì €ë…ì—" },
    ],
    place: [
      { re: /\bacas[Äƒa]\b/, value: "ì§‘ì—ì„œ" },
      { re: /\b(cafenea|cafe)\b/, value: "ì¹´í˜ì—ì„œ" },
      { re: /È™coal[Äƒa]|scoala/, value: "í•™êµì—ì„œ" },
      { re: /firm[Äƒa]|serviciu|companie/, value: "íšŒì‚¬ì—ì„œ" },
      { re: /\bparc\b/, value: "ê³µì›ì—ì„œ" },
      { re: /pia[tÈ›]Äƒ/, value: "ì‹œì¥ì—" }, // destinaÈ›ie genericÄƒ
      { re: /magazin|supermarket/, value: "ê°€ê²Œì—ì„œ" },
    ],
    mod: [
      { re: /\bbine\b|ok\b/, value: "ì˜" },
      { re: /Ã®ncet|incet/, value: "ì²œì²œíˆ" },
      { re: /repede|rapid/, value: "ë¹¨ë¦¬" },
      { re: /\bmult\b/, value: "ë§ì´" },
      { re: /\bsingur(Äƒ)?\b/, value: "í˜¼ì" },
      { re: /Ã®mpreunÄƒ|impreuna/, value: "ê°™ì´" },
    ],
    object: [
      { re: /\bcafea\b/, value: "ì»¤í”¼" },
      { re: /\bap[Äƒa]\b/, value: "ë¬¼" },
      { re: /carte|c[Äƒa]rÈ›/, value: "ì±…" },
      { re: /m[Äƒa]ncare|pr[Äƒa]n(z)?|cina|mic\s+dejun/, value: "ìŒì‹" },
      { re: /\bceai\b/, value: "ì°¨" },
      { re: /film|serial/, value: "ì˜í™”" },
      { re: /telefon/, value: "íœ´ëŒ€í°" },
    ],
    numeral: [
      { re: /\bo\s+/, value: "í•œ" },
      { re: /\bdou[Äƒa]\s+/, value: "ë‘" },
      { re: /\btrei\s+/, value: "ì„¸" },
    ],
    counter: [
      { re: /carte|c[Äƒa]rÈ›/, value: "ê¶Œ" },
      { re: /cafea|ceai|ap[Äƒa]|m[Äƒa]ncare/, value: "ì”" }, // bÄƒuturi = ì”; mÃ¢ncare nu e perfect, dar ok pt test
    ],
    verb: [
      { re: /merg|a\s+merge|sÄƒ\s+merg|sa\s+merg/, value: "ê°€ë‹¤" },
      { re: /vin|a\s+veni|sÄƒ\s+vin|sa\s+vin/, value: "ì˜¤ë‹¤" },
      { re: /beau|a\s+bea|sÄƒ\s+beau|sa\s+beau/, value: "ë§ˆì‹œë‹¤" },
      { re: /m[Ã¢Äƒ]n[Ã¢a]nc|mananc|a\s+m[Ã¢Äƒ]nca/, value: "ë¨¹ë‹¤" },
      { re: /citesc|a\s+citi|sÄƒ\s+citesc|sa\s+citesc/, value: "ì½ë‹¤" },
      { re: /scriu|a\s+scrie/, value: "ì“°ë‹¤" },
      { re: /lucrez|a\s+lucra/, value: "ì¼í•˜ë‹¤" },
      { re: /Ã®nv[Äƒa]È›|invat|a\s+Ã®nv[Äƒa]È›a|a\s+invata/, value: "ë°°ìš°ë‹¤" },
      { re: /studiez|a\s+studia/, value: "ê³µë¶€í•˜ë‹¤" },
      { re: /cump[Äƒa]r|a\s+cump[Äƒa]ra/, value: "ì‚¬ë‹¤" },
      { re: /dorm|a\s+dormi/, value: "ìë‹¤" },
      { re: /vorbesc|a\s+vorbi/, value: "ë§í•˜ë‹¤" },
      { re: /privesc|m[Äƒa]\s+uit|a\s+vedea|a\s+privi/, value: "ë³´ë‹¤" },
    ],
  };

  const EN_RULES = {
    subject: [
      { re: /\bi\b/, value: "ì €" },
      { re: /\byou\b/, value: "ë„ˆ" },
      { re: /\bwe\b/, value: "ìš°ë¦¬" },
      { re: /\bhe\b/, value: "ê·¸" },
      { re: /\bshe\b/, value: "ê·¸ë…€" },
    ],
    time: [
      { re: /\btoday\b/, value: "ì˜¤ëŠ˜" },
      { re: /\btomorrow\b/, value: "ë‚´ì¼" },
      { re: /\byesterday\b/, value: "ì–´ì œ" },
      { re: /\bnow\b/, value: "ì§€ê¸ˆ" },
      { re: /\bmorning\b/, value: "ì•„ì¹¨ì—" },
      { re: /\bevening\b/, value: "ì €ë…ì—" },
    ],
    place: [
      { re: /\bat home\b|\bhome\b/, value: "ì§‘ì—ì„œ" },
      { re: /\bat the cafe\b|\bcafe\b|\bcoffee shop\b/, value: "ì¹´í˜ì—ì„œ" },
      { re: /\bschool\b/, value: "í•™êµì—ì„œ" },
      { re: /\bat work\b|\bwork\b|\boffice\b|\bcompany\b/, value: "íšŒì‚¬ì—ì„œ" },
      { re: /\bpark\b/, value: "ê³µì›ì—ì„œ" },
      { re: /\bmarket\b|\bmart\b|\bgrocery\b/, value: "ì‹œì¥ì—" },
      { re: /\bstore\b|\bshop\b/, value: "ê°€ê²Œì—ì„œ" },
    ],
    mod: [
      { re: /\bwell\b|\bokay\b|\bnicely\b/, value: "ì˜" },
      { re: /\bslowly\b/, value: "ì²œì²œíˆ" },
      { re: /\bfast\b|\bquickly\b/, value: "ë¹¨ë¦¬" },
      { re: /\ba lot\b|\bmuch\b/, value: "ë§ì´" },
      { re: /\balone\b/, value: "í˜¼ì" },
      { re: /\btogether\b/, value: "ê°™ì´" },
    ],
    object: [
      { re: /\bcoffee\b/, value: "ì»¤í”¼" },
      { re: /\bwater\b/, value: "ë¬¼" },
      { re: /\bbook\b|books\b/, value: "ì±…" },
      { re: /\bfood\b|meal\b|lunch\b|dinner\b|breakfast\b/, value: "ìŒì‹" },
      { re: /\btea\b/, value: "ì°¨" },
      { re: /\bmovie\b|\bfilm\b/, value: "ì˜í™”" },
      { re: /\bphone\b/, value: "íœ´ëŒ€í°" },
    ],
    numeral: [
      { re: /\bone\b|\ba\b/, value: "í•œ" },
      { re: /\btwo\b/, value: "ë‘" },
      { re: /\bthree\b/, value: "ì„¸" },
    ],
    counter: [
      { re: /\bbook\b|books\b/, value: "ê¶Œ" },
      { re: /\bcoffee\b|\btea\b|\bwater\b/, value: "ì”" },
    ],
    verb: [
      { re: /\bgo\b|\bgoing\b/, value: "ê°€ë‹¤" },
      { re: /\bcome\b|\bcoming\b/, value: "ì˜¤ë‹¤" },
      { re: /\bdrink\b|\bdrinking\b/, value: "ë§ˆì‹œë‹¤" },
      { re: /\beat\b|\beating\b/, value: "ë¨¹ë‹¤" },
      { re: /\bread\b|\breading\b/, value: "ì½ë‹¤" },
      { re: /\bwrite\b|\bwriting\b/, value: "ì“°ë‹¤" },
      { re: /\bwork\b|\bworking\b/, value: "ì¼í•˜ë‹¤" },
      { re: /\bstudy\b|\bstudying\b/, value: "ê³µë¶€í•˜ë‹¤" },
      { re: /\blearn\b|\blearning\b/, value: "ë°°ìš°ë‹¤" },
      { re: /\bwatch\b|\bwatching\b|\bsee\b|\bseeing\b/, value: "ë³´ë‹¤" },
      { re: /\bbuy\b|\bbuying\b/, value: "ì‚¬ë‹¤" },
      { re: /\bsleep\b|\bsleeping\b/, value: "ìë‹¤" },
      { re: /\bspeak\b|\bspeaking\b|\btalk\b|\btalking\b/, value: "ë§í•˜ë‹¤" },
    ],
  };

  function matchSlot(rules, textNorm) {
    if (!rules) return "";
    for (const rule of rules) {
      if (rule.re.test(textNorm)) return rule.value;
    }
    return "";
  }

  function parseToSlots(text, lang) {
    const t = normalizeText(text);
    if (!t) return {};
    const RULES = (lang === "en") ? EN_RULES : RO_RULES;
    return {
      subject: matchSlot(RULES.subject, t),
      time: matchSlot(RULES.time, t),
      place: matchSlot(RULES.place, t),
      mod: matchSlot(RULES.mod, t),
      object: matchSlot(RULES.object, t),
      numeral: matchSlot(RULES.numeral, t),
      counter: matchSlot(RULES.counter, t),
      verb: matchSlot(RULES.verb, t),
    };
  }

  // ============================================================
  // 3) UI: build dynamic clauses (P1..Pn)
  // ============================================================
  const host = document.getElementById("clausesHost");

  function colHTML(key, title, hint, example) {
    return `
      <div class="col" data-key="${key}">
        <div class="col-header">${title}</div>
        <div class="col-body-label">${hint}</div>
        <div class="col-body-main" contenteditable="true"></div>
        ${example ? `<div class="col-body-extra example">${example}</div>` : ""}
      </div>
    `;
  }

  function clauseBlockHTML(idx) {
    const label = "PropoziÈ›ia " + (idx + 1);
    const id = "tableP" + (idx + 1);

    return `
      <section class="table-block" data-clause-index="${idx}">
        <div class="table-title">
          <span>${label}</span>
          <span style="font-size:11px;color:var(--text-soft);">VERB infinitiv (â€¦ë‹¤) â€¢ CONJ = ending sau conector</span>
        </div>

        <div id="${id}" class="table-horizontal">
          ${colHTML("subject","SUBJECT","eu/tuâ€¦", "ex: ì €, ë‚˜, ë„ˆ")}
          ${colHTML("time","TIME","azi/todayâ€¦", "ex: ì˜¤ëŠ˜, ë‚´ì¼")}
          ${colHTML("place","PLACE","acasÄƒ/cafeâ€¦", "ex: ì§‘ì—ì„œ, ì¹´í˜ì—ì„œ")}
          ${colHTML("mod","MOD","bine/slowlyâ€¦", "ex: ì˜, ì²œì²œíˆ")}
          ${colHTML("object","OBJECT","cafea/coffeeâ€¦", "ex: ì»¤í”¼, ì±…")}
          ${colHTML("numeral","NUMERAL","una/twoâ€¦", "ex: í•œ, ë‘")}
          ${colHTML("counter","COUNTER","ê°œ/ê¶Œ/ì”â€¦", "ex: ê¶Œ, ì”")}
          ${colHTML("verb","VERB","ê°€ë‹¤, ì½ë‹¤â€¦", "IMPORTANT: infinitiv (â€¦ë‹¤)")}
          ${colHTML("conj","CONJ / ENDING","-ê³ , -ì§€ë§Œ, -ì–´ì„œâ€¦", "ex: -ê³ , -ì§€ë§Œ, -ì–´ì„œ, -(ìœ¼)ë©´, -(ìœ¼)ã„¹ ë•Œ, -(ìœ¼)ë ¤ê³ , ê·¸ë¦¬ê³ ")}
        </div>
      </section>
    `;
  }

  function ensureClauseCount(n) {
    const current = host.querySelectorAll("[data-clause-index]").length;
    if (current === n) return;

    if (current < n) {
      for (let i = current; i < n; i++) {
        host.insertAdjacentHTML("beforeend", clauseBlockHTML(i));
      }
    } else {
      for (let i = current - 1; i >= n; i--) {
        const el = host.querySelector('[data-clause-index="' + i + '"]');
        if (el) el.remove();
      }
    }
  }

  // ============================================================
  // 4) Read/Write table cells
  // ============================================================
  function setCell(tableId, key, value) {
    const table = document.getElementById(tableId);
    if (!table) return;
    const cell = table.querySelector(`.col[data-key="${key}"] .col-body-main`);
    if (cell) cell.textContent = value || "";
  }

  function readCell(tableId, key) {
    const table = document.getElementById(tableId);
    if (!table) return "";
    const cell = table.querySelector(`.col[data-key="${key}"] .col-body-main`);
    return cell ? cell.textContent.trim() : "";
  }

  function applySlotsToClause(idx, slots) {
    const tableId = "tableP" + (idx + 1);
    const keys = ["subject","time","place","mod","object","numeral","counter","verb"];
    for (const k of keys) {
      if (slots[k]) setCell(tableId, k, slots[k]);
    }
  }

  function setConjForClause(idx, value) {
    const tableId = "tableP" + (idx + 1);
    setCell(tableId, "conj", value || "");
  }

  // ============================================================
  // 5) Endings attach logic (verb stays infinitive in table)
  // ============================================================
  function normalizeEnding(x) {
    let t = (x || "").trim();
    t = t.replace(/^[-~]/, "").trim(); // "-ê³ " "~ê³ " -> "ê³ "
    return t;
  }

  function isStandaloneConnector(x) {
    const t = (x || "").trim();
    return ["ê·¸ë¦¬ê³ ","ê·¸ë˜ì„œ","í•˜ì§€ë§Œ","ë˜","ë˜ëŠ”","ê·¸ë˜ë„","ê·¸ëŸ¬ë©´"].includes(t);
  }

  function attachEndingToVerb(verbInf, endingRaw) {
    const v = (verbInf || "").trim();
    if (!v) return "";
    const e = normalizeEnding(endingRaw);
    if (!e) return v;

    if (isStandaloneConnector(e)) return v;
    if (!v.endsWith("ë‹¤")) return v;

    const stem = v.slice(0, -1);

    // í•˜ë‹¤ exceptions
    if (v === "í•˜ë‹¤" && (e === "ì•„ì„œ" || e === "ì–´ì„œ")) return "í•´ì„œ";
    if (v === "í•˜ë‹¤" && e === "ê³ ") return "í•˜ê³ ";
    if (v === "í•˜ë‹¤" && e === "(ìœ¼)ë©´") return "í•˜ë©´";
    if (v === "í•˜ë‹¤" && e === "(ìœ¼)ë ¤ê³ ") return "í•˜ë ¤ê³ ";
    if (v === "í•˜ë‹¤" && e === "(ìœ¼)ã„¹ ë•Œ") return "í•  ë•Œ";

    // bracket endings simplified (we do basic default)
    if (e === "(ìœ¼)ë©´") return stem + "ë©´";
    if (e === "(ìœ¼)ã„¹ ë•Œ") return stem + "ã„¹ ë•Œ";
    if (e === "(ìœ¼)ë ¤ê³ ") return stem + "ë ¤ê³ ";

    // normal endings
    return stem + e;
  }

  // ============================================================
  // 6) Polite conjugation (preview only, last clause optional)
  // ============================================================
  const POLITE_OVERRIDES = {
    "í•˜ë‹¤": "í•´ìš”",
    "ê°€ë‹¤": "ê°€ìš”",
    "ì˜¤ë‹¤": "ì™€ìš”",
    "ë³´ë‹¤": "ë´ìš”",
    "ìë‹¤": "ììš”",
    "ì‚¬ë‹¤": "ì‚¬ìš”",
  };

  function politeFromInfinitive(v) {
    const verb = (v || "").trim();
    if (!verb) return "";
    if (!verb.endsWith("ë‹¤")) return verb;

    if (POLITE_OVERRIDES[verb]) return POLITE_OVERRIDES[verb];

    // VERY SIMPLE heuristic (good enough for now):
    // stem + "ì–´ìš”" default
    // (we can refine later with vowel harmony & irregulars)
    const stem = verb.slice(0, -1);
    return stem + "ì–´ìš”";
  }

  // ============================================================
  // 7) Place particle fix: ê°€ë‹¤/ì˜¤ë‹¤ => -ì— ; otherwise -ì—ì„œ
  // ============================================================
  function adjustPlaceByVerb(place, verbInf) {
    let p = (place || "").trim();
    const v = (verbInf || "").trim();

    if (!p) return p;

    const isGoCome = (v === "ê°€ë‹¤" || v === "ì˜¤ë‹¤");

    // normalize common cases
    if (isGoCome) {
      // "ì¹´í˜ì—ì„œ" -> "ì¹´í˜ì—"
      if (p.endsWith("ì—ì„œ")) p = p.slice(0, -2) + "ì—";
      // "ì§‘ì—ì„œ" -> "ì§‘ì—"
      if (p.endsWith("ì§‘ì—ì„œ")) p = "ì§‘ì—";
    } else {
      // destination-like "ì‹œì¥ì—" -> keep as is for now (ok)
      // if endswith ì— but action verb -> prefer ì—ì„œ
      if (p.endsWith("ì—") && !p.endsWith("ì—ì„œ")) {
        // heuristic: turn "ì¹´í˜ì—" -> "ì¹´í˜ì—ì„œ"
        p = p + "ì„œ";
      }
    }
    return p;
  }

  // ============================================================
  // 8) Build clause from table
  // ============================================================
  function buildClauseFromTable(idx, isLastClause, politeLastOn) {
    const tableId = "tableP" + (idx + 1);

    const subject = readCell(tableId, "subject");
    const time = readCell(tableId, "time");
    const placeRaw = readCell(tableId, "place");
    const mod = readCell(tableId, "mod");
    const object = readCell(tableId, "object");
    const numeral = readCell(tableId, "numeral");
    const counter = readCell(tableId, "counter");
    const verbInf = readCell(tableId, "verb");
    const conjRaw = readCell(tableId, "conj");

    let obj = "";
    if (object && numeral && counter) obj = `${object} ${numeral} ${counter}`;
    else if (object) obj = object;

    const place = adjustPlaceByVerb(placeRaw, verbInf);

    // If last clause and polite toggle ON => conjugate verb politely (preview only)
    let verbOut;
    if (isLastClause && politeLastOn) {
      verbOut = politeFromInfinitive(verbInf);
    } else {
      verbOut = verbInf;
    }

    // Attach ending only if NOT last clause (auto-fill puts endings in previous clause)
    // BUT: if user manually wrote ending in conj cell, we still respect it for that clause
    // (works for both non-last and last, but typically last should be blank)
    const verbWithEnding = attachEndingToVerb(verbOut, conjRaw);

    const conjNorm = normalizeEnding(conjRaw);
    const mid = isStandaloneConnector(conjNorm) ? conjNorm : "";

    const pieces = [subject, time, place, mod, obj, verbWithEnding].filter(Boolean);
    const clause = pieces.join(" ").trim();

    const hasAny = clause.length > 0 || mid.length > 0;
    return { clause, mid, hasAny };
  }

  // ============================================================
  // 9) Rebuild preview
  // ============================================================
  function rebuildPreview() {
    const blocks = host.querySelectorAll("[data-clause-index]");
    const n = blocks.length;

    const politeLastOn = !!(document.getElementById("politeLast") && document.getElementById("politeLast").checked);

    const chunks = [];
    for (let i = 0; i < n; i++) {
      const isLast = (i === n - 1);
      const c = buildClauseFromTable(i, isLast, politeLastOn);
      if (!c.hasAny) continue;

      chunks.push(c.clause);
      if (c.mid && i < n - 1) chunks.push(c.mid);
    }

    const out = document.getElementById("previewSentence");
    const info = document.getElementById("previewInfo");

    const sentence = (chunks.join(" ").replace(/\s+/g, " ").trim()) || "ì € ê°€ë‹¤";
    if (out) out.textContent = sentence;

    if (info) {
      info.textContent =
        "RegulÄƒ: verbul rÄƒmÃ¢ne infinitiv (â€¦ë‹¤) Ã®n tabel. Endings (-ê³ /-ì§€ë§Œ/-ì–´ì„œ/-(ìœ¼)ë©´/-(ìœ¼)ã„¹ ë•Œ/-(ìœ¼)ë ¤ê³ ) se lipesc Ã®n preview. " +
        "Loc: ê°€ë‹¤/ì˜¤ë‹¤ => -ì—, altfel => -ì—ì„œ. PoliteÈ›e (toggle) afecteazÄƒ doar ultima clauzÄƒ Ã®n preview.";
    }
  }

  // ============================================================
  // 10) Auto-fill (RO/EN) + multi split
  // ============================================================
  function autoFillFromInput() {
    const input = document.getElementById("inputText");
    const lang = (document.getElementById("langSelect") || {}).value || "ro";
    const raw = (input && input.value) ? input.value : "";

    const chain = splitIntoChain(raw);
    const clauses = chain.clauses;
    const links = chain.links;

    if (!clauses.length) {
      ensureClauseCount(1);
      // defaults
      setCell("tableP1", "subject", "ì €");
      setCell("tableP1", "verb", "ê°€ë‹¤");
      rebuildPreview();
      return;
    }

    ensureClauseCount(clauses.length);

    // fill slots
    for (let i = 0; i < clauses.length; i++) {
      const slots = parseToSlots(clauses[i], lang);
      applySlotsToClause(i, slots);
    }

    // set connectors into CONJ of previous clause
    for (let i = 0; i < links.length; i++) {
      setConjForClause(i, links[i].ko);
    }

    // last conj blank
    setConjForClause(clauses.length - 1, "");

    rebuildPreview();
  }

  // ============================================================
  // 11) Clear
  // ============================================================
  function clearAll() {
    const input = document.getElementById("inputText");
    if (input) input.value = "";

    ensureClauseCount(1);

    const t = document.getElementById("tableP1");
    if (t) t.querySelectorAll(".col-body-main").forEach(el => el.textContent = "");

    setCell("tableP1", "subject", "ì €");
    setCell("tableP1", "verb", "ê°€ë‹¤");

    const polite = document.getElementById("politeLast");
    if (polite) polite.checked = false;

    rebuildPreview();
  }

  // ============================================================
  // 12) Live preview on edits
  // ============================================================
  function wireLivePreview() {
    document.addEventListener("input", function (e) {
      const target = e.target;
      if (target && target.classList && target.classList.contains("col-body-main")) {
        rebuildPreview();
      }
    });

    const polite = document.getElementById("politeLast");
    if (polite) {
      polite.addEventListener("change", rebuildPreview);
    }
  }

  // ============================================================
  // 13) Init
  // ============================================================
  function init() {
    ensureClauseCount(1);
    setCell("tableP1", "subject", "ì €");
    setCell("tableP1", "verb", "ê°€ë‹¤");

    const autoFillBtn = document.getElementById("autoFillBtn");
    const clearBtn = document.getElementById("clearBtn");

    if (autoFillBtn) autoFillBtn.addEventListener("click", autoFillFromInput);
    if (clearBtn) clearBtn.addEventListener("click", clearAll);

    wireLivePreview();
    rebuildPreview();
  }

  window.addEventListener("DOMContentLoaded", init);
})();
</script>
</body>
</html>
