<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Builder Universal — Interactiv (Motor general)</title>
  <style>
    :root{
      --bg:#0f172a;
      --panel:#111c3a;
      --card:#0b1226;
      --text:#e5e7eb;
      --muted:#a5b4fc;
      --accent:#fbbf24;
      --line:#233055;
      --ok:#22c55e;
      --warn:#f97316;
      --bad:#ef4444;
    }
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 20% 10%, #1e2a6b 0%, var(--bg) 60%);
      color:var(--text);
    }
    .topnav{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      padding:12px 16px; border-bottom:1px solid var(--line);
      background: rgba(15,23,42,.82);
      position: sticky; top:0; backdrop-filter: blur(8px); z-index:20;
    }
    .brand{ display:flex; flex-direction:column; gap:2px; }
    .brand strong{ font-size:14px; letter-spacing:.2px; }
    .brand span{ font-size:12px; color:#c7d2fe; }
    .navlinks{ display:flex; gap:8px; flex-wrap:wrap; }
    .navlinks a{
      text-decoration:none;
      color: var(--text);
      border:1px solid var(--line);
      background: rgba(11,18,38,.55);
      padding:8px 10px;
      border-radius:12px;
      font-size:13px;
    }
    .navlinks a:hover{ background: rgba(165,180,252,.10); }
    .navlinks a.active{
      border-color: rgba(251,191,36,.55);
      background: rgba(251,191,36,.10);
    }

    header{
      padding:14px 16px; border-bottom:1px solid var(--line);
      background: rgba(15,23,42,.45);
    }
    header h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    header p{ margin:6px 0 0; color:#c7d2fe; font-size:13px; }

    .wrap{ max-width:1200px; margin:0 auto; padding:16px; display:grid; gap:14px; }
    .grid{ display:grid; gap:14px; grid-template-columns: 1.05fr .95fr; }
    @media (max-width: 980px){ .grid{ grid-template-columns:1fr; } }

    .panel{
      background: rgba(17,28,58,.68);
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .panel h2{ margin:0 0 10px; font-size:15px; color:#e0e7ff; }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row > *{ flex: 0 0 auto; }

    select, button, input, textarea{
      background: rgba(11,18,38,.8);
      color: var(--text);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
      outline:none;
    }
    textarea{ width:100%; min-height:72px; resize:vertical; }
    select{ min-width: 240px; }
    button{ cursor:pointer; }
    button.primary{ border-color: rgba(251,191,36,.45); }
    button.primary:hover{ background: rgba(251,191,36,.12); }
    button.ghost:hover{ background: rgba(165,180,252,.10); }
    button.danger{ border-color: rgba(239,68,68,.35); }
    button.danger:hover{ background: rgba(239,68,68,.10); }

    .pill{
      display:inline-flex; gap:8px; align-items:center;
      border:1px solid var(--line);
      border-radius:999px;
      padding:6px 10px;
      background: rgba(11,18,38,.6);
      font-size:12px;
      color:#c7d2fe;
    }
    .pill strong{ color: var(--accent); font-weight:700; }

    .cards{ display:grid; gap:10px; }
    .card{
      background: rgba(11,18,38,.75);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
    }
    .card.clickable{ cursor:pointer; }
    .card.clickable:hover{ background: rgba(165,180,252,.08); }

    .korean{ font-size:20px; line-height:1.25; letter-spacing:.2px; }
    .romanian{ margin-top:6px; font-size:13px; color:#c7d2fe; }

    .meta{ margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .tag{
      font-size:12px; padding:4px 8px; border-radius:999px;
      border:1px solid var(--line);
      color:#e0e7ff;
      background: rgba(35,48,85,.35);
    }
    .tag.ok{ border-color: rgba(34,197,94,.35); color:#bbf7d0; }
    .tag.warn{ border-color: rgba(249,115,22,.35); color:#fed7aa; }
    .tag.bad{ border-color: rgba(239,68,68,.35); color:#fecaca; }
    .tag.active{ border-color: rgba(251,191,36,.55); color:#fde68a; }

    .big{
      border:1px dashed rgba(251,191,36,.55);
      background: rgba(251,191,36,.08);
    }
    .big .korean{ font-size:22px; }

    .divider{ height:1px; background: var(--line); margin:12px 0; }
    .help{ font-size:12px; color:#c7d2fe; margin:8px 0 0; }
    .small{ font-size:12px; color:#c7d2fe; }

    .step{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:start;
    }
    .stepControls{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .mini{ padding:8px 10px; border-radius:10px; font-size:13px; }
    .copyOk{ color:#bbf7d0; }

    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 980px){ .twoCol{ grid-template-columns:1fr; } }
  </style>
</head>
<body>

  <nav class="topnav">
    <div class="brand">
      <strong>Builder Universal — Interactiv</strong>
      <span>Motor general de combinare (conectori + transformări KO)</span>
    </div>
    <div class="navlinks">
      <!-- Ajustează href-urile la paginile tale reale -->
      <a href="index.html">Home</a>
      <a class="active" href="builder-universal.html">Builder</a>
      <a href="exercises.html">Exercises</a>
      <a href="lessons.html">Lessons</a>
      <a href="glossary.html">Glossary</a>
    </div>
  </nav>

  <header>
    <h1>Construiește & Extinde propoziții</h1>
    <p>Click pe propoziții → Workspace → aplică reguli pe pasul activ → COMBINE cu motor general</p>
  </header>

  <div class="wrap">
    <div class="grid">

      <!-- LEFT -->
      <section class="panel">
        <h2>1) Set</h2>
        <div class="row">
          <select id="setSelect"></select>
          <button class="ghost mini" id="resetBtn">Reset</button>
          <button class="ghost mini" id="randomBtn">Random</button>
          <span class="pill">Nivel: <strong id="levelLabel">A1</strong></span>
        </div>
        <p class="help">
          Click pe o propoziție din “Bază” ca să o adaugi în Workspace.
          Selectează un pas din Workspace ca să devină “activ”.
        </p>

        <div class="divider"></div>

        <div class="twoCol">
          <div>
            <h2>2) Propoziții de bază (click = adaugă)</h2>
            <div class="cards" id="baseCards"></div>
          </div>

          <div>
            <h2>3) Workspace (pași)</h2>
            <div class="cards" id="workspace"></div>

            <div class="divider"></div>

            <h2>4) Editare pas activ</h2>
            <div class="card">
              <div class="meta" style="margin-top:0;">
                <span class="tag active" id="activeStepLabel">Pas activ: —</span>
                <button class="ghost mini" id="undoBtn">Undo</button>
              </div>
              <div class="divider"></div>

              <div class="row">
                <span class="pill"><strong>ADD</strong></span>
                <select id="addSelect"></select>
                <button class="primary mini" id="applyAdd">Aplică</button>
              </div>
              <p class="help">Se aplică pe pasul activ (nu pe tot finalul).</p>

              <div class="divider"></div>

              <div class="row">
                <span class="pill"><strong>MODIFY</strong></span>
                <select id="modifySelect"></select>
                <button class="primary mini" id="applyModify">Aplică</button>
              </div>

              <div class="divider"></div>

              <div class="row">
                <span class="pill"><strong>CHANGE</strong></span>
                <select id="changeSelect"></select>
                <button class="primary mini" id="applyChange">Aplică</button>
              </div>

              <div class="divider"></div>

              <div class="row">
                <span class="pill"><strong>Edit manual</strong></span>
                <button class="ghost mini" id="applyManual">Aplică textul</button>
              </div>
              <textarea id="manualKo" placeholder="KO pentru pasul activ…"></textarea>
              <textarea id="manualRo" placeholder="RO pentru pasul activ…"></textarea>
              <p class="help">Dacă motorul nu nimerește perfect, editezi fin aici.</p>
            </div>
          </div>
        </div>

        <div class="divider"></div>

        <h2>5) COMBINE (motor general)</h2>
        <div class="card">
          <div class="row">
            <span class="pill"><strong>Conector</strong></span>
            <select id="combineSelect"></select>
            <button class="primary mini" id="buildBtn">Construiește finalul</button>
          </div>
          <p class="help">
            Motorul convertește fiecare pas (KO) într-o formă conectivă (ex. -고 / -아서/어서 / -(으)니까 / -는데 / -더니 / -기 전에),
            apoi construiește propoziția finală.
          </p>
        </div>
      </section>

      <!-- RIGHT -->
      <aside class="panel">
        <h2>Preview (final + meta)</h2>

        <div class="card big">
          <div class="korean" id="previewKo">—</div>
          <div class="romanian" id="previewRo">—</div>
          <div class="meta" id="previewMeta"></div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="ghost mini" id="copyKo">Copiază KO</button>
          <button class="ghost mini" id="copyRo">Copiază RO</button>
          <span class="small" id="copyStatus"></span>
        </div>

        <div class="divider"></div>

        <h2>Istoric (session)</h2>
        <div class="cards" id="history"></div>
        <div class="row" style="margin-top:10px;">
          <button class="ghost mini" id="saveBtn">Salvează finalul</button>
          <button class="danger mini" id="clearHistoryBtn">Șterge istoric</button>
        </div>
      </aside>

    </div>
  </div>

  <script>
    /***********************
     * DATA
     ***********************/
    const SETS = [
      {
        id: "shower",
        title: "Duș (acțiuni + reacție)",
        level: "A1→A2",
        base: [
          { id:"b1", ko:"비누칠했어요.", ro:"M-am săpunit (am făcut spumă)."},
          { id:"b2", ko:"물을 틀었어요.", ro:"Am dat drumul la apă."},
          { id:"b3", ko:"물이 차가웠어요.", ro:"Apa era rece."},
          { id:"b4", ko:"놀랐어요.", ro:"Am fost surprins(ă)."}
        ],
        add: [
          { label:"몸에 (pe corp)", type:"prefixObject", target:"비누칠했어요.", out:"몸에 비누칠했어요.", ro:"M-am săpunit pe corp." },
          { label:"따뜻한 (caldă) + 물", type:"replace", find:"물을", repl:"따뜻한 물을", roHint:"apă caldă" },
          { label:"깜짝 (brusc/foarte)", type:"prefixAdverb", target:"놀랐어요.", out:"깜짝 놀랐어요.", ro:"Am fost foarte surprins(ă)." }
        ],
        modify: [
          { label:"물 → 따뜻한 물", type:"replace", find:"물을", repl:"따뜻한 물을", roHint:"apă caldă" },
          { label:"놀랐어요 → 깜짝 놀랐어요", type:"replaceSentence", from:"놀랐어요.", to:"깜짝 놀랐어요.", roHint:"foarte surprins(ă)" }
        ],
        change: [
          { label:"(Info) Negativ / rezultat", type:"infoOnly", note:"În acest set nu există exemple cu 있다/없다 sau 어지다. Folosește alt set pentru CHANGE real." }
        ],
        combine: [
          { label:"-고 (și)", id:"go", roJoin:"și" },
          { label:"-아/어/여서 (cauză→rezultat)", id:"so", roJoin:"așa că" },
          { label:"-(으)니까 (motiv)", id:"nikka", roJoin:"pentru că" },
          { label:"-는데 (context/contrast)", id:"neunde", roJoin:"dar" },
          { label:"-더니 (după ce...)", id:"deoni", roJoin:"și apoi" },
          { label:"-기 전에 (înainte de)", id:"before", roJoin:"înainte să" }
        ]
      },

      {
        id: "mascara",
        title: "Mascara & timp (negativ + rezultat)",
        level: "A1→A2",
        base: [
          { id:"m1", ko:"시간이 있었어요.", ro:"Am avut timp."},
          { id:"m2", ko:"마스카라를 발랐어요.", ro:"Am aplicat mascara."},
          { id:"m3", ko:"번졌어요.", ro:"S-a întins (s-a șters)."}
        ],
        add: [
          { label:"오래된 + 마스카라", type:"replace", find:"마스카라를", repl:"오래된 마스카라를", roHint:"mascara veche" },
          { label:"대충 (în grabă)", type:"insertBeforeVerb", verb:"발랐어요.", insert:"대충 ", roHint:"în grabă" },
          { label:"다 (complet)", type:"prefixAdverb", target:"번졌어요.", out:"다 번졌어요.", ro:"S-a întins complet." }
        ],
        modify: [
          { label:"마스카라 → 오래된 마스카라", type:"replace", find:"마스카라를", repl:"오래된 마스카라를", roHint:"mascara veche" }
        ],
        change: [
          { label:"시간이 있었어요 → 시간이 없었어요", type:"replaceSentence", from:"시간이 있었어요.", to:"시간이 없었어요.", roHint:"nu am avut timp" }
        ],
        combine: [
          { label:"-고 (și)", id:"go", roJoin:"și" },
          { label:"-아/어/여서 (cauză→rezultat)", id:"so", roJoin:"așa că" },
          { label:"-(으)니까 (motiv)", id:"nikka", roJoin:"pentru că" },
          { label:"-는데 (context/contrast)", id:"neunde", roJoin:"dar" },
          { label:"-더니 (după ce...)", id:"deoni", roJoin:"și apoi" },
          { label:"-기 전에 (înainte de)", id:"before", roJoin:"înainte să" }
        ]
      },

      {
        id: "glasses",
        title: "Ochelari (imperativ + motiv)",
        level: "A1→A2",
        base: [
          { id:"g1", ko:"안경이 더러워요.", ro:"Ochelarii sunt murdari."},
          { id:"g2", ko:"써요.", ro:"Îi pun (ochelarii)."},
          { id:"g3", ko:"닦아요.", ro:"Îi șterg / lustruiesc."}
        ],
        add: [
          { label:"제 (ai mei)", type:"replace", find:"안경이", repl:"제 안경이", roHint:"ochelarii mei" },
          { label:"너무 (prea)", type:"insertAfterSubject", subject:"안경이", insert:" 너무", roHint:"prea" }
        ],
        modify: [
          { label:"써요 → 쓰세요 (imperativ)", type:"replaceSentence", from:"써요.", to:"쓰세요.", roHint:"pune-i" },
          { label:"닦아요 → 닦으세요 (imperativ)", type:"replaceSentence", from:"닦아요.", to:"닦으세요.", roHint:"șterge-i" }
        ],
        change: [
          { label:"(Info) -기 전에", type:"infoOnly", note:"Poți crea manual: 쓰기 전에 닦으세요." }
        ],
        combine: [
          { label:"-고 (și)", id:"go", roJoin:"și" },
          { label:"-아/어/여서 (cauză→rezultat)", id:"so", roJoin:"așa că" },
          { label:"-(으)니까 (motiv)", id:"nikka", roJoin:"pentru că" },
          { label:"-는데 (context/contrast)", id:"neunde", roJoin:"dar" },
          { label:"-더니 (după ce...)", id:"deoni", roJoin:"și apoi" },
          { label:"-기 전에 (înainte de)", id:"before", roJoin:"înainte să" }
        ]
      },

      {
        id: "alarm",
        title: "Alarmă (timp + rezultat + deja)",
        level: "A1→A2",
        base: [
          { id:"a1", ko:"알람이 울렸어요.", ro:"A sunat alarma."},
          { id:"a2", ko:"일어났어요.", ro:"M-am trezit."},
          { id:"a3", ko:"졸려요.", ro:"Îmi e somn."}
        ],
        add: [
          { label:"시끄러운 (zgomotoasă)", type:"replace", find:"알람이", repl:"시끄러운 알람이", roHint:"alarmă zgomotoasă" },
          { label:"새벽 5시에", type:"prefixTime", target:"알람이 울렸어요.", out:"새벽 5시에 알람이 울렸어요.", ro:"La 5 dimineața a sunat alarma." },
          { label:"너무 일찍", type:"replaceSentence", from:"일어났어요.", to:"너무 일찍 일어났어요.", roHint:"prea devreme" },
          { label:"벌써", type:"replaceSentence", from:"졸려요.", to:"벌써 졸려요.", roHint:"deja" }
        ],
        modify: [],
        change: [],
        combine: [
          { label:"-고 (și)", id:"go", roJoin:"și" },
          { label:"-아/어/여서 (cauză→rezultat)", id:"so", roJoin:"așa că" },
          { label:"-(으)니까 (motiv)", id:"nikka", roJoin:"pentru că" },
          { label:"-는데 (context/contrast)", id:"neunde", roJoin:"dar" },
          { label:"-더니 (după ce...)", id:"deoni", roJoin:"și apoi" },
          { label:"-기 전에 (înainte de)", id:"before", roJoin:"înainte să" }
        ]
      }
    ];

    /***********************
     * STATE
     ***********************/
    let currentSet = SETS[0];
    let workspace = [];      // [{ko, ro, tags:[{kind,label}]}]
    let activeIndex = -1;

    let finalKo = "";
    let finalRo = "";
    let history = [];

    let undoStack = []; // deep copies of {workspace, activeIndex}

    const el = (id) => document.getElementById(id);

    function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }
    function pushUndo(){
      undoStack.push(deepCopy({workspace, activeIndex}));
      if(undoStack.length > 60) undoStack.shift();
    }
    function undo(){
      const last = undoStack.pop();
      if(!last) return;
      workspace = last.workspace;
      activeIndex = last.activeIndex;
      syncManualEditors();
      renderAll();
    }

    function init(){
      const s = el("setSelect");
      s.innerHTML = "";
      SETS.forEach(set=>{
        const opt = document.createElement("option");
        opt.value = set.id;
        opt.textContent = set.title;
        s.appendChild(opt);
      });
      s.value = currentSet.id;

      s.addEventListener("change", ()=>{
        const picked = SETS.find(x=>x.id===s.value);
        if(picked){ currentSet = picked; resetAll(); }
      });

      el("resetBtn").addEventListener("click", ()=>resetAll());
      el("randomBtn").addEventListener("click", ()=>{
        currentSet = SETS[Math.floor(Math.random()*SETS.length)];
        el("setSelect").value = currentSet.id;
        resetAll(true);
      });

      el("applyAdd").addEventListener("click", ()=>applyRuleToActive("add"));
      el("applyModify").addEventListener("click", ()=>applyRuleToActive("modify"));
      el("applyChange").addEventListener("click", ()=>applyRuleToActive("change"));

      el("applyManual").addEventListener("click", ()=>{
        if(activeIndex < 0 || !workspace[activeIndex]) return;
        pushUndo();
        workspace[activeIndex].ko = (el("manualKo").value || "").trim();
        workspace[activeIndex].ro = (el("manualRo").value || "").trim();
        workspace[activeIndex].tags.push({kind:"MANUAL", label:"Edit manual"});
        renderAll();
      });

      el("undoBtn").addEventListener("click", ()=>undo());

      el("buildBtn").addEventListener("click", ()=>buildFinalFromWorkspace());

      el("copyKo").addEventListener("click", ()=>copyText(finalKo, "KO copiat."));
      el("copyRo").addEventListener("click", ()=>copyText(finalRo, "RO copiat."));

      el("saveBtn").addEventListener("click", ()=>saveToHistory());
      el("clearHistoryBtn").addEventListener("click", ()=>{ history = []; renderHistory(); });

      resetAll();
    }

    function resetAll(){
      undoStack = [];
      workspace = [];
      activeIndex = -1;

      // preset: base sentences into workspace
      currentSet.base.forEach(b=>{
        workspace.push({ ko:b.ko, ro:b.ro, tags:[{kind:"BASE", label:"Base"}] });
      });

      activeIndex = workspace.length ? 0 : -1;

      renderAll();
      syncManualEditors();

      // auto build
      buildFinalFromWorkspace(true);
    }

    function renderAll(){
      el("levelLabel").textContent = currentSet.level || "A1";
      renderBase();
      renderWorkspace();
      renderSelects();
      renderActiveLabel();
      renderPreview();
      renderHistory();
    }

    function renderBase(){
      const wrap = el("baseCards");
      wrap.innerHTML = "";
      currentSet.base.forEach((b)=>{
        const c = document.createElement("div");
        c.className = "card clickable";
        c.innerHTML = `
          <div class="korean">${escapeHtml(b.ko)}</div>
          <div class="romanian">${escapeHtml(b.ro)}</div>
          <div class="meta"><span class="tag">Click → Adaugă</span></div>
        `;
        c.addEventListener("click", ()=>{
          pushUndo();
          workspace.push({ ko:b.ko, ro:b.ro, tags:[{kind:"BASE", label:"Adăugat din bază"}] });
          activeIndex = workspace.length - 1;
          syncManualEditors();
          renderAll();
        });
        wrap.appendChild(c);
      });

      const hint = document.createElement("div");
      hint.className = "card";
      hint.innerHTML = `<div class="romanian">Tip: adaugă pași extra, reordonează, apoi COMBINE.</div>`;
      wrap.appendChild(hint);
    }

    function renderWorkspace(){
      const wrap = el("workspace");
      wrap.innerHTML = "";

      if(!workspace.length){
        const empty = document.createElement("div");
        empty.className = "card";
        empty.innerHTML = `<div class="romanian">Workspace gol. Click pe o propoziție din “Bază”.</div>`;
        wrap.appendChild(empty);
        return;
      }

      workspace.forEach((st, idx)=>{
        const c = document.createElement("div");
        c.className = "card step";
        const activeTag = (idx === activeIndex) ? `<span class="tag active">ACTIV</span>` : "";
        c.innerHTML = `
          <div>
            <div class="korean">${escapeHtml(st.ko)}</div>
            <div class="romanian">${escapeHtml(st.ro)}</div>
            <div class="meta">
              ${activeTag}
              <span class="tag">#${idx+1}</span>
              ${st.tags.slice(-2).map(t=>`<span class="tag">${escapeHtml(t.kind)}</span>`).join("")}
            </div>
          </div>
          <div class="stepControls">
            <button class="ghost mini" data-act="select">Select</button>
            <button class="ghost mini" data-act="up">↑</button>
            <button class="ghost mini" data-act="down">↓</button>
            <button class="danger mini" data-act="del">Șterge</button>
          </div>
        `;

        c.querySelector('[data-act="select"]').addEventListener("click", ()=>{
          activeIndex = idx;
          syncManualEditors();
          renderAll();
        });

        c.querySelector('[data-act="up"]').addEventListener("click", ()=>{
          if(idx === 0) return;
          pushUndo();
          const tmp = workspace[idx-1];
          workspace[idx-1] = workspace[idx];
          workspace[idx] = tmp;
          activeIndex = idx-1;
          syncManualEditors();
          renderAll();
        });

        c.querySelector('[data-act="down"]').addEventListener("click", ()=>{
          if(idx >= workspace.length-1) return;
          pushUndo();
          const tmp = workspace[idx+1];
          workspace[idx+1] = workspace[idx];
          workspace[idx] = tmp;
          activeIndex = idx+1;
          syncManualEditors();
          renderAll();
        });

        c.querySelector('[data-act="del"]').addEventListener("click", ()=>{
          pushUndo();
          workspace.splice(idx,1);
          if(activeIndex >= workspace.length) activeIndex = workspace.length-1;
          syncManualEditors();
          renderAll();
        });

        wrap.appendChild(c);
      });
    }

    function renderSelects(){
      fillSelect("addSelect", currentSet.add);
      fillSelect("modifySelect", currentSet.modify);
      fillSelect("changeSelect", currentSet.change);
      fillSelect("combineSelect", currentSet.combine);
    }

    function fillSelect(id, arr){
      const sel = el(id);
      sel.innerHTML = "";
      if(!arr?.length){
        sel.appendChild(new Option("— nu există —", ""));
        return;
      }
      arr.forEach((x,i)=> sel.appendChild(new Option(x.label, String(i))));
    }

    function renderActiveLabel(){
      el("activeStepLabel").textContent = (activeIndex >= 0)
        ? `Pas activ: #${activeIndex+1}`
        : "Pas activ: —";
    }

    function renderPreview(){
      el("previewKo").textContent = finalKo || "—";
      el("previewRo").textContent = finalRo || "—";

      const meta = el("previewMeta");
      meta.innerHTML = "";
      meta.appendChild(tagSpan(`Pași: ${workspace.length}`, "ok"));
      meta.appendChild(tagSpan(`Set: ${currentSet.title}`, ""));
    }

    function renderHistory(){
      const h = el("history");
      h.innerHTML = "";
      if(!history.length){
        const empty = document.createElement("div");
        empty.className = "card";
        empty.innerHTML = `<div class="romanian">Nu ai nimic salvat în sesiunea aceasta.</div>`;
        h.appendChild(empty);
        return;
      }
      history.slice().reverse().forEach(item=>{
        const c = document.createElement("div");
        c.className = "card";
        c.innerHTML = `
          <div class="korean">${escapeHtml(item.ko)}</div>
          <div class="romanian">${escapeHtml(item.ro)}</div>
          <div class="meta">
            <span class="tag">${escapeHtml(item.setTitle)}</span>
            <button class="ghost mini">Reîncarcă</button>
          </div>
        `;
        c.querySelector("button").addEventListener("click", ()=>{
          finalKo = item.ko;
          finalRo = item.ro;
          renderPreview();
        });
        h.appendChild(c);
      });
    }

    function syncManualEditors(){
      if(activeIndex < 0 || !workspace[activeIndex]){
        el("manualKo").value = "";
        el("manualRo").value = "";
        return;
      }
      el("manualKo").value = workspace[activeIndex].ko || "";
      el("manualRo").value = workspace[activeIndex].ro || "";
    }

    function applyRuleToActive(listName){
      if(activeIndex < 0 || !workspace[activeIndex]) return;

      const selId = (listName === "add") ? "addSelect"
                  : (listName === "modify") ? "modifySelect"
                  : "changeSelect";

      const idx = parseInt(el(selId).value, 10);
      const rule = currentSet[listName]?.[idx];
      if(!rule) return;

      pushUndo();
      const st = workspace[activeIndex];

      const res = applyRuleToSentence(rule, st.ko, st.ro);
      if(!res.ok){
        // anulăm undo dacă nu s-a aplicat
        undoStack.pop();
        return;
      }

      st.ko = res.ko;
      st.ro = res.ro;
      st.tags.push({kind: listName.toUpperCase(), label: rule.label});

      syncManualEditors();
      renderAll();
    }

    function applyRuleToSentence(rule, ko, ro){
      let newKo = ko || "";
      let newRo = ro || "";

      if(rule.type === "infoOnly"){
        newRo = (newRo || "") + ` (Notă: ${rule.note})`;
        return {ok:true, ko:newKo, ro:newRo};
      }

      if(rule.type === "replace"){
        if(newKo.includes(rule.find)){
          newKo = newKo.replace(rule.find, rule.repl);
          if(rule.roHint) newRo = addHint(newRo, rule.roHint);
          return {ok:true, ko:newKo, ro:newRo};
        }
        return {ok:false, ko, ro};
      }

      if(rule.type === "replaceSentence"){
        if(newKo.includes(rule.from)){
          newKo = newKo.replace(rule.from, rule.to);
          if(rule.roHint) newRo = addHint(newRo, rule.roHint);
          return {ok:true, ko:newKo, ro:newRo};
        }
        return {ok:false, ko, ro};
      }

      if(rule.type === "prefixObject" || rule.type === "prefixAdverb" || rule.type === "prefixTime"){
        if(newKo.includes(rule.target)){
          newKo = newKo.replace(rule.target, rule.out);
          if(rule.ro) newRo = rule.ro;
          return {ok:true, ko:newKo, ro:newRo};
        }
        newKo = rule.out;
        if(rule.ro) newRo = rule.ro;
        return {ok:true, ko:newKo, ro:newRo};
      }

      if(rule.type === "insertBeforeVerb"){
        if(newKo.includes(rule.verb)){
          newKo = newKo.replace(rule.verb, rule.insert + rule.verb);
          if(rule.roHint) newRo = addHint(newRo, rule.roHint);
          return {ok:true, ko:newKo, ro:newRo};
        }
        return {ok:false, ko, ro};
      }

      if(rule.type === "insertAfterSubject"){
        const token = rule.subject;
        const i = newKo.indexOf(token);
        if(i !== -1){
          const before = newKo.slice(0, i + token.length);
          const after  = newKo.slice(i + token.length);
          newKo = before + rule.insert + after;
          if(rule.roHint) newRo = addHint(newRo, rule.roHint);
          return {ok:true, ko:newKo, ro:newRo};
        }
        return {ok:false, ko, ro};
      }

      return {ok:false, ko, ro};
    }

    /***********************
     *  MOTOR GENERAL: KO → conectiv
     *  Heuristici A1–A2, extensibile
     ***********************/
    function normalizeKoSentence(s){
      return (s || "").trim().replace(/\s+/g," ");
    }
    function stripFinalPunct(s){
      return (s || "").replace(/[.?!]$/,"").trim();
    }

    // Returnează {stem, tenseHint} din propoziție, dacă e posibil.
    // Heuristic: caută terminații polite uzuale.
    function splitPoliteEnding(koNoPunct){
      // Ordinea contează (mai specific întâi)
      const patterns = [
        { end:"했어요", stem:"했", type:"past" },
        { end:"했어", stem:"했", type:"past" },
        { end:"했어요", stem:"했", type:"past" },
        { end:"했어요", stem:"했", type:"past" },

        { end:"었어요", stem:"었", type:"past" },
        { end:"았어요", stem:"았", type:"past" },
        { end:"였어요", stem:"였", type:"past" },

        { end:"해요", stem:"해", type:"pres" },
        { end:"해", stem:"해", type:"pres" },

        { end:"어요", stem:"어", type:"pres" },
        { end:"아요", stem:"아", type:"pres" },
        { end:"여요", stem:"여", type:"pres" },

        { end:"이에요", stem:"이", type:"cop" },
        { end:"예요", stem:"", type:"cop" }
      ];

      for(const p of patterns){
        if(koNoPunct.endsWith(p.end)){
          const base = koNoPunct.slice(0, koNoPunct.length - p.end.length);
          return { base, end:p.end, type:p.type };
        }
      }
      return { base: koNoPunct, end:"", type:"unknown" };
    }

    // Convertește o propoziție (KO) în clauză conectivă pentru un anumit conector.
    // connectorId: go | so | nikka | neunde | deoni | before
    function toConnective(koSentence, connectorId){
      const s = normalizeKoSentence(koSentence);
      const noPunct = stripFinalPunct(s);
      const { base, end, type } = splitPoliteEnding(noPunct);

      // fallback: dacă nu găsim ending, doar adăugăm conectorul “ca text”
      const rawFallback = (suffix) => `${noPunct}${suffix}`;

      // Ajutor: pentru multe cazuri, putem folosi “base + ending transform”
      const endsWith = (x) => noPunct.endsWith(x);

      // 1) -고
      if(connectorId === "go"){
        // Dacă era imperativ (쓰세요/닦으세요) nu e în patterns; îl tratăm separat:
        if(endsWith("세요")){
          // ex: 닦으세요 -> 닦고 (heuristic)
          const b = noPunct.slice(0, -2); // scoate "요"
          return `${b}고`;
        }
        if(end){
          // ex: 틀었어요 -> 틀었 + 고
          return `${base}${end.replace(/요$/,"")}고`.replace(/고고$/,"고");
        }
        return rawFallback("고");
      }

      // 2) -아서/어서/여서 (so)
      if(connectorId === "so"){
        // 하다-family: 해요/했어요 -> 해서
        if(endsWith("해요")) return `${noPunct.slice(0,-2)}서`;    // 해요 -> 해서
        if(endsWith("했어요")) return `${noPunct.slice(0,-3)}서`; // 했어요 -> 해서 (ok pentru A2)
        if(endsWith("여요")) return `${noPunct.slice(0,-2)}서`;   // 여요 -> 여서

        // Past: ...았어요/었어요/였어요 -> ...아서/어서/여서
        if(endsWith("았어요")) return `${noPunct.slice(0,-3)}아서`;
        if(endsWith("었어요")) return `${noPunct.slice(0,-3)}어서`;
        if(endsWith("였어요")) return `${noPunct.slice(0,-3)}여서`;

        // Present: ...아요/어요 -> ...아서/어서
        if(endsWith("아요")) return `${noPunct.slice(0,-2)}아서`;
        if(endsWith("어요")) return `${noPunct.slice(0,-2)}어서`;

        // Copula: 예요/이에요 -> (이)어서 (simplu)
        if(endsWith("이에요")) return `${noPunct.slice(0,-3)}이어서`;
        if(endsWith("예요")) return `${noPunct.slice(0,-2)}여서`;

        // Imperativ:
        if(endsWith("세요")) return rawFallback("서");

        return rawFallback("서");
      }

      // 3) -(으)니까
      if(connectorId === "nikka"){
        if(endsWith("해요")) return `${noPunct.slice(0,-2)}니까`;     // 해요 -> 하니까? (heuristic simplu: 해니까/하니까)
        if(endsWith("했어요")) return `${noPunct.slice(0,-3)}으니까`; // 했어요 -> 했으니까

        if(endsWith("았어요")) return `${noPunct.slice(0,-3)}으니까`; // 봤어요 -> 봤으니까 (ok)
        if(endsWith("었어요")) return `${noPunct.slice(0,-3)}으니까`;
        if(endsWith("였어요")) return `${noPunct.slice(0,-3)}으니까`;

        if(endsWith("아요")) return `${noPunct.slice(0,-2)}니까`;     // 가요 -> 가니까 (ok-ish)
        if(endsWith("어요")) return `${noPunct.slice(0,-2)}니까`;     // 먹어요 -> 먹으니까? (heuristic: 먹니까; acceptabil A2 ca aproximare)
        if(endsWith("여요")) return `${noPunct.slice(0,-2)}니까`;

        if(endsWith("이에요")) return `${noPunct.slice(0,-3)}이니까`;
        if(endsWith("예요")) return `${noPunct.slice(0,-2)}니까`;

        if(endsWith("세요")) return rawFallback("니까");

        return rawFallback("니까");
      }

      // 4) -는데
      if(connectorId === "neunde"){
        if(endsWith("해요")) return `${noPunct.slice(0,-2)}는데`;      // 해요 -> 하는데/해는데 (heuristic: 해는데)
        if(endsWith("했어요")) return `${noPunct.slice(0,-3)}는데`;   // 했어요 -> 했는데

        if(endsWith("았어요")) return `${noPunct.slice(0,-3)}는데`;
        if(endsWith("었어요")) return `${noPunct.slice(0,-3)}는데`;
        if(endsWith("였어요")) return `${noPunct.slice(0,-3)}는데`;

        if(endsWith("아요")) return `${noPunct.slice(0,-2)}는데`;
        if(endsWith("어요")) return `${noPunct.slice(0,-2)}는데`;
        if(endsWith("여요")) return `${noPunct.slice(0,-2)}는데`;

        if(endsWith("이에요")) return `${noPunct.slice(0,-3)}인데`;
        if(endsWith("예요")) return `${noPunct.slice(0,-2)}인데`;

        if(endsWith("세요")) return rawFallback("는데");

        return rawFallback("는데");
      }

      // 5) -더니 (deoni)
      if(connectorId === "deoni"){
        // ideal: acțiune înainte → rezultat observat după
        if(endsWith("했어요")) return `${noPunct.slice(0,-3)}더니`;
        if(endsWith("았어요")) return `${noPunct.slice(0,-3)}더니`;
        if(endsWith("었어요")) return `${noPunct.slice(0,-3)}더니`;
        if(endsWith("였어요")) return `${noPunct.slice(0,-3)}더니`;

        // dacă e prezent, încă îl acceptăm: ...더니
        if(endsWith("해요")) return `${noPunct.slice(0,-2)}더니`;
        if(endsWith("아요")) return `${noPunct.slice(0,-2)}더니`;
        if(endsWith("어요")) return `${noPunct.slice(0,-2)}더니`;

        return rawFallback("더니");
      }

      // 6) -기 전에 (before)
      if(connectorId === "before"){
        // Heuristic: scoate polite ending și adaugă "기 전에"
        // 해요 -> 하기 전에 (preferabil), dar aici simplificăm:
        if(endsWith("해요")) return `${noPunct.slice(0,-2)}기 전에`.replace(/해기 전에$/,"하기 전에");
        if(endsWith("했어요")) return `${noPunct.slice(0,-3)}기 전에`.replace(/했기 전에$/,"하기 전에");

        if(endsWith("아요")) return `${noPunct.slice(0,-2)}기 전에`;
        if(endsWith("어요")) return `${noPunct.slice(0,-2)}기 전에`;
        if(endsWith("여요")) return `${noPunct.slice(0,-2)}기 전에`;

        if(endsWith("았어요")) return `${noPunct.slice(0,-3)}기 전에`;
        if(endsWith("었어요")) return `${noPunct.slice(0,-3)}기 전에`;
        if(endsWith("였어요")) return `${noPunct.slice(0,-3)}기 전에`;

        if(endsWith("세요")) return `${noPunct.slice(0,-2)}기 전에`; // 쓰세요 -> 쓰기 전에 (ok-ish)

        return `${noPunct}기 전에`;
      }

      // default
      return noPunct;
    }

    // Construiește finalul:
    // - transformă toate propozițiile, mai puțin ultima, în conective
    // - ultima rămâne propoziție încheiată (cu punct)
    function buildFinalFromWorkspace(silent=false){
      if(!workspace.length){
        finalKo = "—";
        finalRo = "—";
        renderPreview();
        return;
      }

      const idx = parseInt(el("combineSelect").value, 10);
      const combRule = currentSet.combine?.[idx] || currentSet.combine?.[0] || { id:"go", roJoin:"și" };
      const connectorId = combRule.id;

      const koParts = workspace.map(x => normalizeKoSentence(x.ko));
      const roParts = workspace.map(x => (x.ro || "").trim().replace(/\s+/g," "));

      // KO: conective pentru toate în afară de ultima
      const koClauses = [];
      for(let i=0;i<koParts.length;i++){
        const isLast = (i === koParts.length - 1);
        const s = normalizeKoSentence(koParts[i]);
        if(!s) continue;

        if(isLast){
          // final sentence: ensure punctuation
          let last = s.trim();
          if(!/[.?!]$/.test(last)) last += ".";
          koClauses.push(last);
        }else{
          koClauses.push(toConnective(s, connectorId));
        }
      }

      // Adăugăm virgule/spații minim:
      // ex: A서 B고 C는데 D.
      // Punem spațiu între clauze.
      finalKo = koClauses.join(" ").replace(/\s+/g," ").trim();

      // RO: simplu, dar lizibil. Pentru A1–A2 e ok.
      // Toate, mai puțin ultima, se termină fără punct; le legăm cu roJoin.
      const roJoin = combRule.roJoin || "și";
      const cleanRo = roParts.map(s => (s || "").replace(/[.?!]$/,"").trim()).filter(Boolean);
      if(cleanRo.length === 1){
        finalRo = cleanRo[0] + ".";
      }else{
        let ro = cleanRo[0];
        for(let i=1;i<cleanRo.length;i++){
          ro = `${ro} ${roJoin} ${cleanRo[i]}`;
        }
        finalRo = ro.trim() + ".";
      }

      renderPreview();
      if(!silent){
        // opțional: feedback mic
      }
    }

    function saveToHistory(){
      if(!finalKo || finalKo === "—") return;
      history.push({ ko: finalKo, ro: finalRo, setTitle: currentSet.title });
      renderHistory();
    }

    function addHint(ro, hint){
      if(!ro) return ro;
      if(ro.includes(hint)) return ro;
      return ro + ` (hint: ${hint})`;
    }

    function tagSpan(text, kind){
      const span = document.createElement("span");
      span.className = "tag " + (kind || "");
      span.textContent = text;
      return span;
    }

    async function copyText(txt, okMsg){
      try{
        await navigator.clipboard.writeText(txt || "");
        el("copyStatus").textContent = okMsg;
        el("copyStatus").className = "small copyOk";
        setTimeout(()=>{ el("copyStatus").textContent=""; }, 1200);
      }catch(e){
        el("copyStatus").textContent = "Nu pot copia (browser restrictions).";
        el("copyStatus").className = "small";
      }
    }

    function escapeHtml(str){
      return (str ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    init();
  </script>
</body>
</html>
