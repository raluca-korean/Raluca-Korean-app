<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Raluca Korean â€“ Study App v2.0</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
   :root {
  --bg: #f5f5f7;
  --card-bg: #ffffff;
  --accent: #2563eb;
  --accent-soft: #e0edff;
  --accent-strong: #1d4ed8;
  --text-main: #111827;
  --text-soft: #6b7280;
  --border: #e5e7eb;
  --border-strong: #d1d5db;
  --overlay-bg: rgba(15,23,42,0.28);
  --radius-lg: 18px;
  --radius-md: 12px;
  --shadow-soft: 0 14px 30px rgba(15,23,42,0.06);
  --shadow-strong: 0 18px 40px rgba(15,23,42,0.1);
  --font-main: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
    "Segoe UI", sans-serif;
}

/* ===== Layout general ================================================== */

*,
*::before,
*::after {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
  min-height: 100vh;
  font-family: var(--font-main);
  color: var(--text-main);
  background:
    radial-gradient(circle at top, #ffffff 0, #f5f5f7 55%, #e5e7eb 100%);
}
.app {
  max-width: 1040px;
  margin: 0 auto;
  /* spaÈ›iu pentru nav + zona de gesturi iOS */
  padding: 16px 16px calc(90px + env(safe-area-inset-bottom));
  display: flex;
  flex-direction: column;
  gap: 16px;
}
    /* ca sÄƒ funcÈ›ioneze .hidden din JS */
.hidden {
  display: none !important;
}

/* ===== Header brand ===================================================== */

.rk-header {
  padding: 8px 4px 4px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.rk-header-main {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

.rk-header-main h1 {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--text-main);
}

.rk-badge {
  font-size: 11px;
  font-weight: 600;
  padding: 4px 9px;
  border-radius: 999px;
  background: #f9fafb;
  border: 1px solid var(--border);
  color: var(--text-soft);
}

#subtitle {
  margin: 0;
  font-size: 12px;
  color: var(--text-soft);
}

/* ===== Screen switching ================================================= */

.screen {
  display: none;
  flex-direction: column;
  gap: 12px;
  flex: 1;
  min-height: 0;
}

.screen.active {
  display: flex;
}

/* ===== Carduri principale =============================================== */

.card,
.table-block,
.preview-card {
  background: var(--card-bg);
  border-radius: var(--radius-lg);
  border: 1px solid var(--border);
  box-shadow: var(--shadow-soft);
}

.card {
  padding: 12px 14px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.card h2 {
  margin: 0;
  font-size: 15px;
  font-weight: 600;
  color: var(--text-main);
}

/* ===== Panou mod / toggles ============================================== */

.mode-panel {
  background: transparent;
  border-radius: var(--radius-lg);
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.mode-row {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.section-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-soft);
}

.part-toggles {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

/* ===== Chip-uri SUBJ/TIME/PLACE etc. ==================================== */

.chip {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 9px;
  border-radius: 999px;
  font-size: 11px;
  background: #f3f4f6;
  color: var(--text-soft);
  border: 1px solid var(--border);
}

.chip input {
  margin: 0;
}

/* ===== Textarea & inputuri ============================================== */

textarea {
  width: 100%;
  border-radius: var(--radius-md);
  border: 1px solid var(--border-strong);
  background: #f9fafb;
  padding: 10px 12px;
  font-size: 13px;
  line-height: 1.4;
  color: var(--text-main);
  outline: none;
  resize: vertical;
  min-height: 72px;
}

textarea::placeholder {
  color: #9ca3af;
}

textarea:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 1px var(--accent-soft);
}

/* ===== Butoane ========================================================== */

button {
  border-radius: 999px;
  border: none;
  padding: 7px 14px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  background: var(--accent);
  color: #ffffff;
  display: inline-flex;
  align-items: center;
  gap: 4px;
  box-shadow: var(--shadow-soft);
}

button.secondary {
  background: #f3f4f6;
  color: var(--text-main);
  box-shadow: none;
}

button.small-mode-btn {
  font-size: 11px;
  padding: 4px 10px;
}

button.small-mode-btn.active {
  background: var(--accent-soft);
  color: var(--accent-strong);
}

button:disabled {
  opacity: 0.45;
  box-shadow: none;
  cursor: default;
}

/* ===== Bloc tabel (SUBJECT / TIME / PLACEâ€¦) ============================= */

.table-block {
  padding: 10px 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.table-title {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-soft);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.page-indicator {
  font-size: 11px;
  color: var(--text-soft);
}

/* ===== Coloanele â€tileâ€ ================================================= */

.table-horizontal {
  display: flex;
  flex-direction: row;
  gap: 8px;
  overflow-x: auto;
  padding: 4px 0 2px;
}

.col {
  min-width: 110px;
  max-width: 140px;
  flex: 0 0 auto;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: #f9fafb;
  padding: 7px 7px 9px;
  display: flex;
  flex-direction: column;
  cursor: pointer;
  touch-action: manipulation;
  transition:
    transform 0.15s ease,
    box-shadow 0.15s ease,
    border-color 0.15s ease,
    background 0.15s ease;
}

.col:hover,
.col:active {
  transform: translateY(-1px);
  box-shadow: var(--shadow-strong);
  border-color: var(--accent-soft);
  background: #ffffff;
}

.col.dimmed {
  opacity: 0.4;
  box-shadow: none;
}

.col-header {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--text-soft);
  margin-bottom: 4px;
  border-bottom: 1px solid var(--border);
  padding-bottom: 2px;
}

.col-body-label {
  font-size: 10px;
  color: #9ca3af;
  margin-bottom: 2px;
}

.col-body-main {
  font-size: 15px;
  font-weight: 600;
  color: var(--text-main);
  margin-bottom: 2px;
}

.col-body-extra {
  font-size: 11px;
  color: var(--text-soft);
}

/* ===== Controale builder ================================================ */

.controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
  padding-top: 6px;
  border-top: 1px dashed var(--border);
}

.btn-group {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

/* ===== Preview propoziÈ›ie =============================================== */

.preview-card {
  padding: 10px 12px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.preview-title {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-soft);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.preview-ko {
  font-size: 16px;
  font-weight: 600;
  color: var(--text-main);
  margin-top: 2px;
}

.preview-ro {
  font-size: 12px;
  color: var(--text-soft);
  margin-top: 2px;
}

.preview-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 6px;
}

/* Hinturi pe care le-ai vrut ascunse */
.legend {
  display: none;
}
#naturalHint {
  display: none;
}

/* ===== ExerciÈ›ii ======================================================== */

.small-label {
  font-size: 11px;
  color: var(--text-soft);
}

.exercise-question {
  font-size: 14px;
  font-weight: 600;
  margin-top: 4px;
}

.exercise-options {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-top: 4px;
}

.exercise-options label {
  font-size: 13px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.exercise-feedback {
  font-size: 12px;
  margin-top: 6px;
  color: var(--text-soft);
}

/* ===== Glosar & favorite ================================================= */

.fav-list {
  margin-top: 4px;
  max-height: 160px;
  overflow-y: auto;
  padding-right: 2px;
}

.fav-item {
  padding: 5px 7px;
  border-radius: var(--radius-md);
  border: 1px solid var(--border);
  background: #f9fafb;
  font-size: 11px;
  margin-bottom: 4px;
}

.fav-ko {
  font-weight: 600;
  margin-bottom: 2px;
}

.fav-ro {
  color: var(--text-soft);
}

.glossary-search {
  display: flex;
  gap: 6px;
  align-items: center;
  margin-top: 4px;
}

.glossary-search input {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border-strong);
  padding: 6px 10px;
  font-size: 12px;
  background: #f9fafb;
}

.glossary-list {
  margin-top: 6px;
  max-height: 260px;
  overflow-y: auto;
  padding-right: 2px;
}

.glossary-item {
  padding: 6px 8px;
  border-radius: var(--radius-md);
  border: 1px solid var(--border);
  background: #f9fafb;
  margin-bottom: 4px;
  font-size: 12px;
  display: flex;
  justify-content: space-between;
  gap: 8px;
}

.glossary-ko {
  font-weight: 600;
}

.glossary-ro {
  color: var(--text-soft);
}

.glossary-cat {
  font-size: 10px;
  color: var(--text-soft);
}

/* ===== 3 cuvinte/zi ===================================================== */

#dailyWordsBox > div {
  border-radius: var(--radius-md);
  border: 1px solid var(--border);
  background: #f9fafb;
}

/* ===== Bottom nav (tabs) =============================================== */

.bottom-nav {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 6px 10px;
  background: rgba(248,250,252,0.96);
  border-top: 1px solid var(--border);
  backdrop-filter: blur(18px);
  display: flex;
  justify-content: space-around;
  gap: 8px;
  z-index: 500;
}

.nav-btn {
  position: relative;
  flex: 1;
  max-width: 140px;
  border: none;
  background: transparent;
  padding: 4px 0 0;
  cursor: pointer;
  color: var(--text-soft);
  font-size: 11px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}

.nav-btn span.icon {
  font-size: 18px;
}

.nav-btn::before {
  content: "";
  position: absolute;
  inset: 0;
  top: -3px;
  margin: 0 6px;
  border-radius: 12px 12px 0 0;
  background: transparent;
  border: 1px solid transparent;
  border-bottom: none;
  transition:
    background 0.16s ease,
    border-color 0.16s ease,
    transform 0.16s ease,
    box-shadow 0.16s ease;
  z-index: -1;
}

.nav-btn.active {
  color: var(--accent-strong);
  font-weight: 600;
}

.nav-btn.active::before {
  background: #ffffff;
  border-color: var(--border);
  box-shadow: 0 -4px 12px rgba(15,23,42,0.06);
  transform: translateY(-2px);
}

/* ===== Overlay + panel (lista de cuvinte) =============================== */

.overlay {
  position: fixed;
  inset: 0;
  background: var(--overlay-bg);
  display: flex;
  justify-content: center;
  align-items: flex-end;
  z-index: 1000;
}

.overlay.hidden {
  display: none !important;
}

.panel {
  width: 100%;
  max-width: 900px;
  background: #f9fafb;
  border-radius: 20px 20px 0 0;
  border: 1px solid var(--border);
  box-shadow: var(--shadow-strong);
  padding: 10px 12px 14px;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  border-bottom: 1px solid var(--border);
  padding-bottom: 6px;
}

.panel-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-main);
}

.panel-sub {
  font-size: 11px;
  color: var(--text-soft);
}

.panel-close {
  background: transparent;
  color: var(--text-soft);
  box-shadow: none;
  padding: 4px 6px;
}

.panel-input-row {
  display: flex;
  gap: 6px;
  margin-bottom: 6px;
}

.panel-input-row input {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border-strong);
  padding: 6px 10px;
  font-size: 12px;
  background: #ffffff;
}

.panel-list {
  max-height: 260px;
  overflow-y: auto;
  border-radius: var(--radius-md);
  border: 1px solid var(--border);
  background: #f9fafb;
  padding: 4px;
}

.panel-item {
  padding: 4px 8px;
  border-radius: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 13px;
  cursor: pointer;
}

.panel-item:hover {
  background: #e5f0ff;
}

.panel-item-main {
  font-weight: 600;
}

.panel-item-extra {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 2px;
}

.panel-item-tag {
  font-size: 10px;
  color: var(--text-soft);
}

/* ===== Responsive ======================================================= */

@media (max-width: 640px) {
  .app {
    padding-inline: 10px;
  }

  .card,
  .table-block,
  .preview-card {
    border-radius: 14px;
  }

  .table-horizontal {
    gap: 6px;
  }

  .col {
    min-width: 100px;
  }
}
  </style>
</head>
<body>
  <div class="app">
    <header class="rk-header">
  <div class="rk-header-main">
    <h1>Raluca Korean</h1>
    <span class="rk-badge">Study App v2.0</span>
  </div>
  <p id="subtitle">Builder propoziÈ›ii + particule + audio + conjugÄƒri</p>
</header>

    <!-- SCREEN 1: BUILDER -->
    <div class="screen active" id="screen-builder">
      <div class="mode-panel">
        <div class="mode-row">
  <span class="section-label">Mod afiÈ™are</span>
  <div>
    <button class="secondary small-mode-btn" data-mode="simple">Simplu</button>
    <button class="secondary small-mode-btn active" data-mode="topik">TOPIK</button>
  </div>
</div>

<div class="card">
  <h2>RomÃ¢nÄƒ â†’ CoreeanÄƒ</h2>
  <textarea id="roInput" rows="3" placeholder="Scrie propoziÈ›ia Ã®n romÃ¢nÄƒ aici..."></textarea>
  <button id="roTranslateBtn">Tradu Ã®n coreeanÄƒ</button>

  <div class="preview-ko" id="roToKoResult"></div>
  <div class="preview-ro" id="roCorrected"></div>
</div>
        <div class="mode-row">
          <span class="section-label">PropoziÈ›ia 1 â€“ ce pÄƒrÈ›i foloseÈ™te?</span>
          <div class="part-toggles" id="togglesP1"></div>
          
        </div>
        <div class="mode-row">
          <label>
            <input type="checkbox" id="enableP2" />
            ActiveazÄƒ PropoziÈ›ia 2 (fraza)
          </label>
          <div class="part-toggles" id="togglesP2"></div>
        </div>
      </div>

      <div class="table-block">
        <div class="table-title">
          <span>PropoziÈ›ia 1</span>
          <span class="page-indicator" id="pageInfo"></span>
        </div>
        <div class="table-horizontal" id="tableP1"></div>

        <div class="table-title hidden" id="titleP2">
          <span>PropoziÈ›ia 2 (continuare / frazÄƒ)</span>
        </div>
        <div class="table-horizontal hidden" id="tableP2"></div>

        <div class="controls">
          <div class="btn-group">
            <button id="prevBtn">â¬… Prev (rÃ¢nd model)</button>
            <button id="nextBtn">Next â¡</button>
          </div>
          <button class="secondary" id="resetBtn">Reset pÄƒrÈ›i de propoziÈ›ie</button>
        </div>
        <div class="legend">
          â¤ Tap scurt pe coloanÄƒ = treci la urmÄƒtorul cuvÃ¢nt.  
          â¤ Èšine apÄƒsat pe coloanÄƒ = deschizi lista completÄƒ (cu traduceri + cÄƒutare).  
          â¤ â­ la CONJUGÄ‚RI = gramaticÄƒ de legÄƒturÄƒ (cere propoziÈ›ia 2).  
          â¤ Sistem de <b>conjugare realÄƒ</b>: verbul se uneÈ™te cu finalul (ex: ê°€ë‹¤ + -ê³  ìˆì–´ìš” â†’ ê°€ê³  ìˆì–´ìš”).
        </div>

        <div class="preview-card">
          <div class="preview-title">
            <span>PropoziÈ›ia / fraza (coreeanÄƒ, cu particule & verb conjugat)</span>
          </div>
          <div class="preview-ko" id="previewKo">(alege cuvinte din tabel)</div>

          <div class="preview-title">
            <span>Traducere aproximativÄƒ (romÃ¢nÄƒ â€“ pe pÄƒrÈ›i)</span>
            <button id="toggleRoBtn" class="secondary" style="padding:3px 8px;font-size:10px;">
              Ascunde traducerea
            </button>
          </div>
          <div class="preview-ro" id="previewRo"></div>

          <div class="preview-natural" id="naturalHint"></div>

          <div class="preview-buttons">
            <button id="randomBtn">ğŸ² Random propoziÈ›ie</button>
            <button id="speakBtn">ğŸ”Š Audio coreeanÄƒ</button>
            <button id="favBtn" class="secondary">â­ SalveazÄƒ propoziÈ›ia</button>
          </div>
        </div>
      </div>
    </div>
    

    <!-- SCREEN 2: EXERCIÈšII TOPIK -->
    <div class="screen" id="screen-exercises">
      <div class="card">
        <h2>ğŸ“ ExerciÈ›ii TOPIK â€“ propoziÈ›ii</h2>
        <div class="small-label">Alege tipul de exerciÈ›iu:</div>
        <select id="exerciseType">
          <option value="verb">Alege VERBUL corect</option>
          <option value="particle">Alege PARTICULA corectÄƒ (simplu)</option>
          <option value="particlePlus">Particule multiple (ì€/ëŠ”, ì´/ê°€, ì„/ë¥¼, ì—/ì—ì„œ)</option>
          <option value="conjug">Alege CONJUGAREA corectÄƒ</option>
        </select>

        <div class="exercise-question" id="exerciseQuestion">
          ApasÄƒ â€Ãntrebare nouÄƒâ€ ca sÄƒ Ã®ncepi.
        </div>
        <div class="exercise-options" id="exerciseOptions"></div>

        <div class="btn-group">
          <button id="checkAnswerBtn">VerificÄƒ rÄƒspunsul</button>
          <button class="secondary" id="nextQuestionBtn">Ãntrebare nouÄƒ</button>
        </div>
        <div class="exercise-feedback" id="exerciseFeedback"></div>
      </div>
      <div class="legend">
        â¤ Pentru â€Particule multipleâ€ ai mai multe spaÈ›ii (1), (2), (3).  
        â¤ Toate trebuie corecte ca sÄƒ fie propoziÈ›ia corectÄƒ.
      </div>
    </div>

    <!-- SCREEN 3: GLOSAR + FAVORITE -->
    <div class="screen" id="screen-glossary">
      <div class="card">
        <h2>ğŸ“š Glosar coreeanâ€“romÃ¢n</h2>

<!-- ğŸ“… 3 cuvinte/zi -->
<div class="card" style="margin-top:8px;">
  <h2>ğŸ“… 3 cuvinte/zi</h2>

  <div class="small-label" id="dailyDateLabel">Azi</div>

  <div id="dailyWordsBox" style="display:flex;flex-direction:column;gap:6px;margin-top:6px;"></div>

  <div class="btn-group" style="margin-top:8px;">
    <button class="secondary" id="dailyPrevBtn">â¬… Ieri</button>
    <button class="secondary" id="dailyNextBtn">MÃ¢ine â¡</button>
    <button id="dailyMarkBtn">âœ… Am Ã®nvÄƒÈ›at azi</button>
  </div>

  <div class="small-label" id="dailyProgress" style="margin-top:6px;"></div>
</div>

        <div class="small-label">PropoziÈ›ii favorite:</div>
        <div id="favoritesList" class="fav-list"></div>

        <div class="small-label" style="margin-top:6px;">CautÄƒ Ã®n glosar (coreeanÄƒ sau romÃ¢nÄƒ):</div>
        <div class="glossary-search">
          <input type="text" id="glossarySearch" placeholder="ex: ê°€ë‹¤ sau a merge" />
        </div>
        <div class="glossary-list" id="glossaryList"></div>
      </div>
    </div>
  </div>

  <!-- bottom nav -->
  <nav class="bottom-nav">
    <button class="nav-btn active" data-target="builder">
      <span class="icon">ğŸ—</span>
      <span>Builder</span>
    </button>
    <button class="nav-btn" data-target="exercises">
      <span class="icon">ğŸ“</span>
      <span>ExerciÈ›ii</span>
    </button>
    <button class="nav-btn" data-target="glossary">
      <span class="icon">ğŸ“š</span>
      <span>Glosar</span>
    </button>
  </nav>

  <!-- overlay panel -->
  <div class="overlay hidden" id="overlay">
    <div class="panel">
      <div class="panel-header">
        <div>
          <div class="panel-title" id="panelTitle"></div>
          <div class="panel-sub" id="panelSub"></div>
        </div>
        <button class="panel-close" id="closePanelBtn">âœ•</button>
      </div>

      <!-- CÄƒutare Ã®n lista de cuvinte -->
      <div class="panel-input-row">
        <input type="text" id="panelSearchInput" placeholder="CautÄƒ Ã®n listÄƒ (primele litere)..." />
      </div>

      <!-- CuvÃ¢nt nou + traducere -->
      <div class="panel-input-row">
        <input type="text" id="newWordInput" placeholder="CuvÃ¢nt nou (coreeanÄƒ sau numÄƒr)..." />
      </div>
      <div class="panel-input-row">
        <input type="text" id="newWordTransInput" placeholder="Traducere Ã®n romÃ¢nÄƒ (ex: unu, azi) â€“ opÈ›ional" />
        <button id="addWordBtn" class="secondary">+ Add</button>
      </div>

      <div class="panel-list" id="panelList"></div>
    </div>
  </div>

  <script>
    let LAST_RO_SENTENCE = "";
/* === LISTE DE CUVINTE (de bazÄƒ) === */
const subjects = [
  "ì €","ë‚˜","ë„ˆ","ìš°ë¦¬","ë„ˆí¬","ì‚¬ëŒ","í•™ìƒ","ì„ ìƒë‹˜","ì§ì›","ì „ë¬¸ê°€","ì§€ì›ì","ê´€ë¦¬ì",
  "ë¶€ëª¨ë‹˜","ì•„ì´","ì–´ë¥¸","ì‹œë¯¼","ê³ ê°","ì˜ì‚¬","ê°„í˜¸ì‚¬","ì—°êµ¬ì","ê´€ê³„ì","ëŒ€í‘œ","íšŒì¥",
  "ì‚¬ìš©ì","ì°¸ê°€ì","ìš´ì „ì","ì£¼ë¯¼","í™˜ì"
];
const times = [
  "ì˜¤ëŠ˜","ì–´ì œ","ë‚´ì¼","ì§€ê¸ˆ","ë°©ê¸ˆ","ì¡°ê¸ˆ í›„ì—","ê³§","ìµœê·¼ì—","ìš”ì¦˜","ë§ˆì¹¨ë‚´","ê²°êµ­",
  "ì´ì „ì—","ì´í›„ì—","ë‹¹ì‹œì—","í•œë™ì•ˆ","ê³„ì†","ê°€ë”","í•­ìƒ","ìì£¼","ì ì ","ì°¨ì¸°","ì¼ì°","ëŠ¦ê²Œ"
];
    const places = [
  "ì§‘","í•™êµ","íšŒì‚¬","ì‹ë‹¹","ì¹´í˜","ë„ì„œê´€","ë³‘ì›","ì‹œì¥","ë°±í™”ì ","ê³µí•­","ê¸°ì°¨ì—­",
  "ë²„ìŠ¤ì •ë¥˜ì¥","ì—°êµ¬ì†Œ","ê¸°ê´€","ì§€ì—­ì‚¬íšŒ","í™˜ê²½","ëŒ€ê¸°ì—…","íšŒì˜ì‹¤","ë²•ì›","ê²½ì°°ì„œ",
  "í•´ë³€","ë°”ë‹¤","ë°”ë‹·ê°€","ì‚°","ê³µì›","ì€í–‰"
];
const mods = [
  "ì˜","ì—´ì‹¬íˆ","ì¡°ìš©íˆ","ì²œì²œíˆ","ë¹¨ë¦¬","ì •ë§","ì•„ì£¼","ë„ˆë¬´","ë§ì´","ì¡°ê¸ˆ","ê°‘ìê¸°","ë¯¸ë¦¬",
  "ë²Œì¨","ì•„ê¹Œ","ë°©ê¸ˆ","ê¸ˆë°©","ê³§","í•­ìƒ","ìì£¼","ê°€ë”","ë“œë¬¼ê²Œ","ìƒë‹¹íˆ","ê½¤","ë„ëŒ€ì²´","ì ˆëŒ€ë¡œ",
  "ì ê·¹ì ìœ¼ë¡œ","ì¶©ë¶„íˆ","íŠ¹íˆ","ì˜¤íˆë ¤","ì ì ","ì°¨ì¸°","ê³„ì†"
];
const objects = [
  "ì±…","ì»¤í”¼","ë¬¼","ìŒì‹","ì˜í™”","ê°€ë°©","ì „í™”","ì˜·","ìë£Œ","ë°ì´í„°","ê³„íš","ì¡°ê±´","ìƒí™©","ë¬¸ì œ",
  "í•´ê²°ì±…","ìš”ì•½","ë³´ê³ ì„œ","ë¬¸ì„œ","ì»´í“¨í„°","ë…¸íŠ¸ë¶","í¸ì§€","ì„ ë¬¼","ì˜ê²¬","ì •ë³´","ê´€ê³„","ê²°ê³¼",
  "ì›ì¸","ë°©ë²•","ì œí’ˆ","ì„œë¹„ìŠ¤","ì •ì±…","ë¬¸í™”","ì±„ì†Œ","ê²¬ê³¼ë¥˜"
];
const numerals = new Array(60).fill("");
const counters = [
  "ê°œ","ëª…","ê¶Œ","ì¥","ëŒ€","ë³‘","ì”","ë§ˆë¦¬","ë²ˆ","ì‚´","ì†¡ì´","ì¤„","ì ","ê±´","íšŒ","ê°€ì§€","ìª½"
];
const verbs = [
  "ê°€ë‹¤","ì˜¤ë‹¤","ë¨¹ë‹¤","ë§ˆì‹œë‹¤","ë³´ë‹¤","ì½ë‹¤","ì“°ë‹¤","ë°°ìš°ë‹¤","ì‚¬ë‹¤","ì£¼ë‹¤","ë°›ë‹¤","ì¼í•˜ë‹¤",
  "ê³µë¶€í•˜ë‹¤","ìš”ë¦¬í•˜ë‹¤","ì²­ì†Œí•˜ë‹¤","ì¤€ë¹„í•˜ë‹¤","ë„ì™€ì£¼ë‹¤","ì‚¬ìš©í•˜ë‹¤","í•„ìš”í•˜ë‹¤","ì¢‹ì•„í•˜ë‹¤",
  "ì‹«ì–´í•˜ë‹¤","ê¸°ë‹¤ë¦¬ë‹¤","ì‰¬ë‹¤","ë§Œë‚˜ë‹¤","ê±·ë‹¤","ë‹¬ë¦¬ë‹¤","ì•‰ë‹¤","ì„œë‹¤","ê²°ì •í•˜ë‹¤","ì œì•ˆí•˜ë‹¤",
  "ì „ë‹¬í•˜ë‹¤","ìœ ì§€í•˜ë‹¤","ë°œìƒí•˜ë‹¤","ì¦ê°€í•˜ë‹¤","ê°ì†Œí•˜ë‹¤","ì¸ì •í•˜ë‹¤","ë¶„ì„í•˜ë‹¤","ê´€ì°°í•˜ë‹¤",
  "í•´ê²°í•˜ë‹¤","ì—°êµ¬í•˜ë‹¤","í˜‘ë ¥í•˜ë‹¤","ìš”ì²­í•˜ë‹¤","ì¶©ì¡±í•˜ë‹¤","ë¹„êµí•˜ë‹¤","ì„¤ëª…í•˜ë‹¤","ì˜ˆìƒí•˜ë‹¤"
];
const conjugations = [
  "-ì•„ìš”/ì–´ìš”","-ì•˜ì–´ìš”/ì—ˆì–´ìš”","-ê³  ìˆì–´ìš”","-ê³  ì‹¶ì–´ìš”","-(ìœ¼)ì„¸ìš”","-(ìœ¼)ã„¹ ê±°ì˜ˆìš”",
  "-ì§€ ë§ˆì„¸ìš”","-ì•„/ì–´ ì£¼ì„¸ìš”","-ì•„/ì–´ì•¼ ë¼ìš”","-(ìœ¼)ã„¹ ìˆ˜ ìˆì–´ìš”","-(ìœ¼)ã„¹ ìˆ˜ ì—†ì–´ìš”",
  "-ë”ë¼ê³ ìš”","-ë„¤ìš”","-êµ°ìš”","-ê³  ë‚˜ì„œ","-ê¸° ì „ì—","-(ìœ¼)ë©´ì„œ","-(ìœ¼)ë©°",
  "-(ìœ¼)ã„¹ì§€ë„ ëª°ë¼ìš”","-(ìœ¼)ã„¹ê²Œìš”","-(ìœ¼)ã„¹ë˜ìš”?","-(ìœ¼)ã„¹ê¹Œìš”?","-ëŠ” ê²Œ ì–´ë•Œìš”?",
  "-ëŠ” ì¤‘ì´ì—ìš”","-ì•„/ì–´ë„ ë¼ìš”","-(ìœ¼)ë©´ ì•ˆ ë¼ìš”","-(ìœ¼)ë‚˜","-(ìœ¼)ë¯€ë¡œ","-(ìœ¼)ã„´/ëŠ” ë§Œí¼",
  "-(ìœ¼)ã„¹ìˆ˜ë¡","-(ìœ¼)ã„´/ëŠ”ë°ë„","-(ìœ¼)ã„¹ì§€ë¼ë„","-(ìœ¼)ã„´/ëŠ” ë°˜ë©´ì—","-ë„ë¡ í•˜ë‹¤",
  "-ê²Œ ë˜ë‹¤","-ì•„/ì–´ì§€ë‹¤","-ê¸° ë§ˆë ¨ì´ë‹¤","-ê¸°ì—","-ê¸¸ë˜","-ê³  ë§ë‹¤","-ê³ ì í•˜ë‹¤","-(ìœ¼)ã„¹ ë¿ì´ë‹¤"
];

/* === TRADUCERI (coreeanÄƒ â†’ romÃ¢nÄƒ) === */
const translations = {
  subject:{ "ì €":"eu (formal)","ë‚˜":"eu (informal)","ë„ˆ":"tu","ìš°ë¦¬":"noi","ë„ˆí¬":"voi",
    "ì‚¬ëŒ":"persoanÄƒ","í•™ìƒ":"student/Äƒ","ì„ ìƒë‹˜":"profesor","ì§ì›":"angajat",
    "ë¶€ëª¨ë‹˜":"pÄƒrinÈ›i","ì•„ì´":"copil","ì–´ë¥¸":"adult","ê³ ê°":"client","ì˜ì‚¬":"medic",
    "ê°„í˜¸ì‚¬":"asistentÄƒ","ì—°êµ¬ì":"cercetÄƒtor","ëŒ€í‘œ":"reprezentant","í™˜ì":"pacient"
  },
  time:{ "ì˜¤ëŠ˜":"astÄƒzi","ì–´ì œ":"ieri","ë‚´ì¼":"mÃ¢ine","ì§€ê¸ˆ":"acum","ë°©ê¸ˆ":"tocmai acum",
    "ì¡°ê¸ˆ í›„ì—":"puÈ›in mai tÃ¢rziu","ê³§":"Ã®n curÃ¢nd","ìµœê·¼ì—":"recent","ìš”ì¦˜":"Ã®n ultima vreme",
    "ë§ˆì¹¨ë‚´":"Ã®n cele din urmÄƒ","ê²°êµ­":"pÃ¢nÄƒ la urmÄƒ","ì´ì „ì—":"Ã®nainte","ì´í›„ì—":"dupÄƒ",
    "ë‹¹ì‹œì—":"atunci","í•œë™ì•ˆ":"o perioadÄƒ","ê³„ì†":"continuÄƒ","ê°€ë”":"din cÃ¢nd Ã®n cÃ¢nd",
    "í•­ìƒ":"Ã®ntotdeauna","ìì£¼":"des","ì ì ":"din ce Ã®n ce","ì°¨ì¸°":"treptat",
    "ì¼ì°":"devreme","ëŠ¦ê²Œ":"tÃ¢rziu"
  },
  place:{ 
  "ì§‘":"acasÄƒ",
  "í•™êµ":"È™coalÄƒ",
  "íšŒì‚¬":"firmÄƒ / companie",
  "ì‹ë‹¹":"restaurant",
  "ì¹´í˜":"cafenea",
  "ë„ì„œê´€":"bibliotecÄƒ",
  "ë³‘ì›":"spital",
  "ì‹œì¥":"piaÈ›Äƒ",
  "ë°±í™”ì ":"magazin universal",
  "ê³µí•­":"aeroport",
  "ê¸°ì°¨ì—­":"garÄƒ",
  "ë²„ìŠ¤ì •ë¥˜ì¥":"staÈ›ie de autobuz",
  "ì—°êµ¬ì†Œ":"laborator",
  "ê¸°ê´€":"instituÈ›ie",
  "ì§€ì—­ì‚¬íšŒ":"comunitate",
  "í™˜ê²½":"mediu",
  "ëŒ€ê¸°ì—…":"corporaÈ›ie mare",
  "íšŒì˜ì‹¤":"salÄƒ de È™edinÈ›e",
  "ë²•ì›":"instanÈ›Äƒ",
  "ê²½ì°°ì„œ":"secÈ›ie de poliÈ›ie",
  "í•´ë³€":"plajÄƒ",              // ğŸ‘ˆ NOU
  "ë°”ë‹¤":"mare",               // ğŸ‘ˆ NOU
  "ë°”ë‹·ê°€":"malul mÄƒrii / plajÄƒ", // ğŸ‘ˆ NOU
  "í•´ë³€":"plajÄƒ",
  "ì‚°":"munte",
  "ê³µì›":"parc",
  "ì€í–‰":"bancÄƒ"
}
  },
  mod:{ "ì˜":"bine","ì—´ì‹¬íˆ":"cu sÃ¢rguinÈ›Äƒ","ì¡°ìš©íˆ":"Ã®n liniÈ™te","ì²œì²œíˆ":"Ã®ncet",
    "ë¹¨ë¦¬":"repede","ì •ë§":"cu adevÄƒrat","ì•„ì£¼":"foarte","ë„ˆë¬´":"prea / foarte",
    "ë§ì´":"mult","ì¡°ê¸ˆ":"puÈ›in","ê°‘ìê¸°":"brusc","ë¯¸ë¦¬":"Ã®n avans","ë²Œì¨":"deja",
    "ì•„ê¹Œ":"mai devreme","ë°©ê¸ˆ":"chiar acum","ê¸ˆë°©":"imediat","ê³§":"Ã®n curÃ¢nd",
    "í•­ìƒ":"mereu","ìì£¼":"des","ê°€ë”":"din cÃ¢nd Ã®n cÃ¢nd","ë“œë¬¼ê²Œ":"rar",
    "ìƒë‹¹íˆ":"destul de","ê½¤":"biniÈ™or","ë„ëŒ€ì²´":"(deloc / Ã®n Ã®ntrebÄƒri)",
    "ì ˆëŒ€ë¡œ":"niciodatÄƒ (interdicÈ›ie)","ì ê·¹ì ìœ¼ë¡œ":"activ","ì¶©ë¶„íˆ":"suficient",
    "íŠ¹íˆ":"Ã®n special","ì˜¤íˆë ¤":"mai degrabÄƒ","ì ì ":"din ce Ã®n ce","ì°¨ì¸°":"treptat",
    "ê³„ì†":"Ã®n mod continuu"
  },
    object:{ 
    "ì±…":"carte","ì»¤í”¼":"cafea","ë¬¼":"apÄƒ","ìŒì‹":"mÃ¢ncare","ì˜í™”":"film",
    "ê°€ë°©":"geantÄƒ","ì „í™”":"telefon","ì˜·":"haine","ìë£Œ":"materiale","ë°ì´í„°":"date",
    "ê³„íš":"plan","ì¡°ê±´":"condiÈ›ie","ìƒí™©":"situaÈ›ie","ë¬¸ì œ":"problemÄƒ",
    "í•´ê²°ì±…":"soluÈ›ie","ìš”ì•½":"rezumat","ë³´ê³ ì„œ":"raport","ë¬¸ì„œ":"document",
    "ì»´í“¨í„°":"calculator","ë…¸íŠ¸ë¶":"laptop","í¸ì§€":"scrisoare","ì„ ë¬¼":"cadou",
    "ì˜ê²¬":"opinie","ì •ë³´":"informaÈ›ie","ê´€ê³„":"relaÈ›ie","ê²°ê³¼":"rezultat",
    "ì›ì¸":"cauzÄƒ","ë°©ë²•":"metodÄƒ","ì œí’ˆ":"produs","ì„œë¹„ìŠ¤":"serviciu",
    "ì •ì±…":"politicÄƒ","ë¬¸í™”":"culturÄƒ",
    "ì±„ì†Œ":"legume",
    "ê²¬ê³¼ë¥˜":"alune / nuci","ëˆ":"bani"
  },
  numeral:{},
  counter:{ "ê°œ":"bucatÄƒ","ëª…":"persoanÄƒ","ê¶Œ":"volum (carte)","ì¥":"foaie / paginÄƒ",
    "ëŒ€":"aparat / vehicul","ë³‘":"sticlÄƒ","ì”":"canÄƒ / pahar",
    "ë§ˆë¦¬":"animal","ë²ˆ":"datÄƒ","ì‚´":"ani (vÃ¢rstÄƒ)","ì†¡ì´":"buchet / ciorchine",
    "ì¤„":"rÃ¢nd / È™ir","ì ":"punct","ê±´":"caz","íšŒ":"datÄƒ (ocazie)",
    "ê°€ì§€":"fel / tip","ìª½":"paginÄƒ / direcÈ›ie"
  },
  verb:{
    "ê°€ë‹¤":"a merge","ì˜¤ë‹¤":"a veni","ë¨¹ë‹¤":"a mÃ¢nca","ë§ˆì‹œë‹¤":"a bea","ë³´ë‹¤":"a vedea / a se uita",
    "ì½ë‹¤":"a citi","ì“°ë‹¤":"a scrie","ë°°ìš°ë‹¤":"a Ã®nvÄƒÈ›a","ì‚¬ë‹¤":"a cumpÄƒra","ì£¼ë‹¤":"a da",
    "ë°›ë‹¤":"a primi","ì¼í•˜ë‹¤":"a lucra","ê³µë¶€í•˜ë‹¤":"a studia","ìš”ë¦¬í•˜ë‹¤":"a gÄƒti",
    "ì²­ì†Œí•˜ë‹¤":"a face curat","ì¤€ë¹„í•˜ë‹¤":"a pregÄƒti","ë„ì™€ì£¼ë‹¤":"a ajuta",
    "ì‚¬ìš©í•˜ë‹¤":"a folosi","í•„ìš”í•˜ë‹¤":"a fi necesar","ì¢‹ì•„í•˜ë‹¤":"a plÄƒcea",
    "ì‹«ì–´í•˜ë‹¤":"a nu plÄƒcea / a urÃ®","ê¸°ë‹¤ë¦¬ë‹¤":"a aÈ™tepta","ì‰¬ë‹¤":"a se odihni",
    "ë§Œë‚˜ë‹¤":"a se Ã®ntÃ¢lni","ê±·ë‹¤":"a merge pe jos","ë‹¬ë¦¬ë‹¤":"a alerga",
    "ì•‰ë‹¤":"a se aÈ™eza","ì„œë‹¤":"a sta Ã®n picioare","ê²°ì •í•˜ë‹¤":"a decide",
    "ì œì•ˆí•˜ë‹¤":"a propune","ì „ë‹¬í•˜ë‹¤":"a transmite","ìœ ì§€í•˜ë‹¤":"a menÈ›ine",
    "ë°œìƒí•˜ë‹¤":"a se produce","ì¦ê°€í•˜ë‹¤":"a creÈ™te","ê°ì†Œí•˜ë‹¤":"a scÄƒdea",
    "ì¸ì •í•˜ë‹¤":"a recunoaÈ™te","ë¶„ì„í•˜ë‹¤":"a analiza","ê´€ì°°í•˜ë‹¤":"a observa",
    "í•´ê²°í•˜ë‹¤":"a rezolva","ì—°êµ¬í•˜ë‹¤":"a cerceta","í˜‘ë ¥í•˜ë‹¤":"a colabora",
    "ìš”ì²­í•˜ë‹¤":"a solicita","ì¶©ì¡±í•˜ë‹¤":"a satisface","ë¹„êµí•˜ë‹¤":"a compara",
    "ì„¤ëª…í•˜ë‹¤":"a explica","ì˜ˆìƒí•˜ë‹¤":"a anticipa"
  },
  conjug:{
    "-ì•„ìš”/ì–´ìš”":"prezent politicos",
    "-ì•˜ì–´ìš”/ì—ˆì–´ìš”":"trecut politicos",
    "-ê³  ìˆì–´ìš”":"acÈ›iune Ã®n desfÄƒÈ™urare",
    "-ê³  ì‹¶ì–´ìš”":"vreau sÄƒ...",
    "-(ìœ¼)ì„¸ìš”":"imperativ / onorific",
    "-(ìœ¼)ã„¹ ê±°ì˜ˆìš”":"viitor",
    "-ì§€ ë§ˆì„¸ìš”":"nu faceÈ›i..., vÄƒ rog",
    "-ì•„/ì–´ ì£¼ì„¸ìš”":"vÄƒ rog sÄƒ...",
    "-ì•„/ì–´ì•¼ ë¼ìš”":"trebuie sÄƒ...",
    "-(ìœ¼)ã„¹ ìˆ˜ ìˆì–´ìš”":"pot sÄƒ...",
    "-(ìœ¼)ã„¹ ìˆ˜ ì—†ì–´ìš”":"nu pot sÄƒ...",
    "-ë”ë¼ê³ ìš”":"am observat cÄƒ...",
    "-ë„¤ìš”":"exclamativ (observaÈ›ie surprinsÄƒ)",
    "-êµ°ìš”":"exclamativ (constatare)",
    "-ê³  ë‚˜ì„œ":"dupÄƒ ce...",
    "-ê¸° ì „ì—":"Ã®nainte sÄƒ...",
    "-(ìœ¼)ë©´ì„œ":"Ã®n timp ce...",
    "-(ìœ¼)ë©°":"È™i (Ã®n timp ce)",
    "-(ìœ¼)ã„¹ì§€ë„ ëª°ë¼ìš”":"s-ar putea sÄƒ...",
    "-(ìœ¼)ã„¹ê²Œìš”":"voi face (pentru tine)",
    "-(ìœ¼)ã„¹ë˜ìš”?":"ai chef sÄƒ...? / vreau sÄƒ...",
    "-(ìœ¼)ã„¹ê¹Œìš”?":"sÄƒ facem...?",
    "-ëŠ” ê²Œ ì–´ë•Œìš”?":"ce-ar fi sÄƒ...?",
    "-ëŠ” ì¤‘ì´ì—ìš”":"sunt Ã®n mijlocul acÈ›iunii",
    "-ì•„/ì–´ë„ ë¼ìš”":"poÈ›i sÄƒ..., e Ã®n regulÄƒ",
    "-(ìœ¼)ë©´ ì•ˆ ë¼ìš”":"nu ai voie sÄƒ...",
    "-ë„ë¡ í•˜ë‹¤":"sÄƒ faci Ã®n aÈ™a fel Ã®ncÃ¢t sÄƒ...",
    "-ê²Œ ë˜ë‹¤":"ajungi sÄƒ...",
    "-ì•„/ì–´ì§€ë‹¤":"a deveni...",
    "-ê¸°ì—":"pentru cÄƒ..., fiindcÄƒ",
    "-ê¸¸ë˜":"pentru cÄƒ (am vÄƒzut / simÈ›it eu)",
    "-ê³  ë§ë‹¤":"Ã®n cele din urmÄƒ ajunge sÄƒ...",
    "-ê³ ì í•˜ë‹¤":"a intenÈ›iona sÄƒ...",
    "-(ìœ¼)ã„¹ ë¿ì´ë‹¤":"doar..., nimic altceva"
  }
};

/* === SALVARE CUVINTE NOI === */
const STORAGE_KEY="ralucaKoreanCustomWords_v2";
const customData={
  subject:[],time:[],place:[],mod:[],object:[],
  numeral:[],counter:[],verb:[],conjug:[]
};
function loadCustomData(){
  try{
    const raw=localStorage.getItem(STORAGE_KEY);
    if(!raw)return;
    const saved=JSON.parse(raw);
    Object.keys(customData).forEach(k=>{
      if(Array.isArray(saved[k]))customData[k]=saved[k];
    });
    Object.entries(customData).forEach(([key,arr])=>{
      arr.forEach(entry=>{
        if(!entry||!entry.word)return;
        const w=entry.word,ro=entry.ro||"";
        let ref=null;
        if(key==="subject")ref=subjects;
        else if(key==="time")ref=times;
        else if(key==="place")ref=places;
        else if(key==="mod")ref=mods;
        else if(key==="object")ref=objects;
        else if(key==="numeral")ref=numerals;
        else if(key==="counter")ref=counters;
        else if(key==="verb")ref=verbs;
        else if(key==="conjug")ref=conjugations;
        if(ref&&!ref.includes(w))ref.push(w);
        if(!translations[key])translations[key]={};
        if(ro)translations[key][w]=ro;
      });
    });
  }catch(e){}
}
    // ================= RO -> KO (parser simplu din dicÈ›ionarul app-ului) =================
const roInput = document.getElementById("roInput");

// reverse map: romÃ¢nÄƒ -> coreeanÄƒ (din translations)
function stripDiacritics(s){
  return (s||"")
    .replace(/Äƒ/g,"a").replace(/Ã¢/g,"a").replace(/Ã®/g,"i")
    .replace(/È™/g,"s").replace(/ÅŸ/g,"s")
    .replace(/È›/g,"t").replace(/Å£/g,"t");
}

function normRo(s){
  return stripDiacritics(
    (s||"")
      .toLowerCase()
      .replace(/[.,!?;]/g," ")
  )
  .replace(/\s+/g," ")
  .trim();
}
function buildReverseMap(){
  const rev = {
    subject:{}, time:{}, place:{}, mod:{},
    object:{}, counter:{}, verb:{}, conjug:{}
  };

  Object.entries(translations).forEach(([cat, map])=>{
    if(!rev[cat]) return;

    Object.entries(map).forEach(([ko, ro])=>{
      if(!ro) return;

      // ex: "a cumpÄƒra" â†’ "a cumpara"
      const norm = normRo(ro);

      // cheia de bazÄƒ (ce aveai È™i Ã®nainte)
      if(!rev[cat][norm]) rev[cat][norm] = ko;

      // ğŸ‘‡ Ã®n plus: suport pentru forme de tip "cumpÄƒr", "sÄƒ cumpÄƒr"
      if(norm.startsWith("a ")){
        // "a cumpara" â†’ "cumpara"
        const base = norm.replace(/^a\s+/, ""); 
        if(base){
          // "cumpara" â†’ "cumpar" (tÄƒiem ultima vocalÄƒ a infinitivului)
          const stem = base.replace(/[aei]$/, ""); 
          if(stem){
            // "cumpar" â†’ prinde "cumpÄƒr legume"
            if(!rev[cat][stem]) rev[cat][stem] = ko;

            // "sa cumpar" â†’ prinde "sÄƒ cumpÄƒr legume"
            const saKey = "sa " + stem;
            if(!rev[cat][saKey]) rev[cat][saKey] = ko;
          }
        }
      }
    });
  });

  return rev;
}
let REV = buildReverseMap();

// detecteazÄƒ conjugarea din romÃ¢nÄƒ (foarte practic)
function detectConjFromRo(ro){
  const t = normRo(ro);
// 1) INTENÈšIE / OBLIGAÈšIE / ABILITATE
if(/\bvreau sa\b/.test(t))        return "-ê³  ì‹¶ì–´ìš”";       // vreau sÄƒ...
if(/\btrebuie sa\b/.test(t))      return "-ì•„/ì–´ì•¼ ë¼ìš”";    // trebuie sÄƒ...
if(/\bnu pot sa\b/.test(t))       return "-(ìœ¼)ã„¹ ìˆ˜ ì—†ì–´ìš”"; // nu pot sÄƒ...
if(/\bpot sa\b/.test(t))          return "-(ìœ¼)ã„¹ ìˆ˜ ìˆì–´ìš”"; // pot sÄƒ...

  // 2) FUTUR (mÃ¢ine, voi, o sÄƒ...)
  if(/\b(maine|mÃ¢ine)\b/.test(t) ||
     /\bvoi\b/.test(t) ||
     /\bo sÄƒ\b/.test(t)){
    return "-(ìœ¼)ã„¹ ê±°ì˜ˆìš”";  // viitor
  }

  // 3) TRECUT (ieri, deja, tocmai, am mers / am mÃ¢ncat)
  if(/\b(ieri|deja|tocmai)\b/.test(t) ||
     /\bam\b/.test(t)){     // "am mers, am mÃ¢ncat..."
    return "-ì•˜ì–´ìš”/ì—ˆì–´ìš”"; // trecut politicos
  }

  // 4) NEGATIV â€“ variantÄƒ simplÄƒ (imperativ negativ)
  if(/\bnu\b/.test(t))        return "-ì§€ ë§ˆì„¸ìš”";

  // 5) FALLBACK: prezent politicos
  return "-ì•„ìš”/ì–´ìš”";
}

// cautÄƒ cel mai bun match RO Ã®n reverse map (match pe â€œincludeâ€, nu doar exact)
function findKoByRo(cat, text){
  const t = normRo(text);
  const keys = Object.keys(REV[cat]||{});
  // preferÄƒm potriviri mai lungi
  keys.sort((a,b)=>b.length-a.length);
  for(const k of keys){
    if(k && t.includes(k)) return REV[cat][k];
  }
  return null;
}
    // ==== FORME ROMÃ‚NEÈ˜TI â†’ INFINITIV (pt. detectarea verbului) ====
const RO_FORM_TO_INF = {
  // MERGE / PLECA -> tratÄƒm ca "a merge" (=> ê°€ë‹¤)
  "plec":"a merge","pleci":"a merge","pleacÄƒ":"a merge","pleaca":"a merge",
  "pleca":"a merge","plecam":"a merge","plecaÈ›i":"a merge",
  "merg":"a merge","mergi":"a merge","merge":"a merge","mergem":"a merge","mergeÈ›i":"a merge",

  // VENI
  "vin":"a veni","vii":"a veni","vine":"a veni","venim":"a veni","veniÈ›i":"a veni",

  // MÃ‚NCA
  "mÄƒnÃ¢nc":"a mÃ¢nca","mananc":"a mÃ¢nca",
  "mÄƒnÃ¢nci":"a mÃ¢nca","mananci":"a mÃ¢nca",
  "mÄƒnÃ¢ncÄƒ":"a mÃ¢nca","mananca":"a mÃ¢nca",

  // BEA
  "beau":"a bea","bei":"a bea","bea":"a bea","bem":"a bea","beÈ›i":"a bea",

  // CITI
  "citesc":"a citi","citeÈ™ti":"a citi","citesti":"a citi",
  "citeÈ™te":"a citi","citeste":"a citi",
  "citim":"a citi","citiÈ›i":"a citi","cititi":"a citi",

  // SCRIE
  "scriu":"a scrie","scrii":"a scrie","scrie":"a scrie",
  "scriem":"a scrie","scrieÈ›i":"a scrie","scrieti":"a scrie"
};

// foarte simplu: gÄƒseÈ™te subiect (eu/tu/noi/voi) + cuvinte pe care le È™tie glosarul
function parseRoToState(roSentence){
  const msg = [];
  const t = normRo(roSentence);

  // SUBJECT
  let subj = "";
  if(/\beu\b/.test(t))      subj = "ì €";
  else if(/\btu\b/.test(t)) subj = "ë„ˆ";
  else if(/\bnoi\b/.test(t))subj = "ìš°ë¦¬";
  else if(/\bvoi\b/.test(t))subj = "ë„ˆí¬";

  // TIME
  const time =
    findKoByRo("time", roSentence) ||
    (/\bastazi\b/.test(t) ? "ì˜¤ëŠ˜" : "") ||
    (/\bmaine\b/.test(t)  ? "ë‚´ì¼" : "") ||
    (/\bieri\b/.test(t)   ? "ì–´ì œ" : "");

  // PLACE
  let place = findKoByRo("place", roSentence);
  if(!place && /\bbanc(Äƒ|a)\b/i.test(roSentence)) place = "ì€í–‰";
  // piaÈ›Äƒ / piata â†’ ì‹œì¥
  if(!place && /\bpiat[Äƒa]\b/i.test(roSentence))  place = "ì‹œì¥";

  // MOD / OBJECT
  const mod    = findKoByRo("mod", roSentence);
  const object = findKoByRo("object", roSentence);

  // VERB (1) din dicÈ›ionar
  let verb = findKoByRo("verb", roSentence);

  // VERB (2) infinitiv "a ___"
  if(!verb){
    const m = t.match(/\ba\s+([a-zÄƒÃ¢Ã®È™È›]+)/i);
    if(m){
      const inf = ("a " + m[1]).toLowerCase();
      verb = REV.verb[inf] || "";
    }
  }

  // VERB (3) forme conjugate (merg, plec, citesc...)
  if(!verb){
    for(const w of t.split(" ")){
      const inf = RO_FORM_TO_INF[w];
      if(inf && REV.verb[inf]){
        verb = REV.verb[inf];
        break;
      }
    }
  }

  // VERB (4) sinonime manuale (pleca, sosi, ajunge)
  if(!verb){
    if(/\bpleca\b/.test(t) ||
       /\bplec\b/.test(t) ||
       /\bpleci\b/.test(t) ||
       /\bplecam\b/.test(t) ||
       /\bplecaÈ›i\b/.test(t)) {
      verb = "ê°€ë‹¤";           // pleca â†’ a merge
    } else if(/\bsosi\b/.test(t) ||
              /\bajunge\b/.test(t) ||
              /\bajuns\b/.test(t)) {
      verb = "ì˜¤ë‹¤";           // sosi / ajunge â†’ a veni
    }
  }

  const conj = detectConjFromRo(roSentence);

  if(!subj) msg.push("â€¢ Nu am detectat clar subiectul (eu/tu/noi/voi).");
  if(!verb) msg.push("â€¢ Nu am gÄƒsit verb Ã®n dicÈ›ionar (Ã®ncearcÄƒ È™i infinitiv: â€a mergeâ€, â€a veniâ€).");

  return {
    state: {
      subject: subj,
      time,
      place:  place  || "",
      mod:    mod    || "",
      object: object || "",
      numeral:"",
      counter:"",
      verb:   verb   || "",
      conjug: conj   || "-ì•„ìš”/ì–´ìš”"
    },
    msg
  };
}
function saveCustomData(){
  try{localStorage.setItem(STORAGE_KEY,JSON.stringify(customData));}catch(e){}
}
loadCustomData();

/* === HANGUL helperi pt conjugare === */
const H_BASE=0xAC00;
const JONG=["","ã„±","ã„²","ã„³","ã„´","ã„µ","ã„¶","ã„·","ã„¹","ã„º","ã„»","ã„¼","ã„½","ã„¾","ã„¿","ã…€",
            "ã…","ã…‚","ã…„","ã……","ã…†","ã…‡","ã…ˆ","ã…Š","ã…‹","ã…Œ","ã…","ã…"];
const JUNG=["ã…","ã…","ã…‘","ã…’","ã…“","ã…”","ã…•","ã…–","ã…—","ã…˜","ã…™","ã…š","ã…›",
            "ã…œ","ã…","ã…","ã…Ÿ","ã… ","ã…¡","ã…¢","ã…£"];

function decomposeLastSyl(word){
  if(!word)return null;
  const ch=word.charCodeAt(word.length-1);
  const code=ch-H_BASE;
  if(code<0||code>11171)return null;
  const jong=code%28;
  const jung=((code-jong)/28)%21;
  const cho=Math.floor((code-jong)/28/21);
  return{cho,jung,jong,prefix:word.slice(0,-1)};
}
function hasBatchim(s){
  const d=decomposeLastSyl(s);
  return d?d.jong!==0:false;
}
function getVerbStem(dict){
  if(!dict)return"";
  return dict.endsWith("ë‹¤")?dict.slice(0,-1):dict;
}

/* verbe speciale */
const specialVerbMap={
  "ê°€ë‹¤":{present:"ê°€ìš”",past:"ê°”ì–´ìš”"},
  "ì˜¤ë‹¤":{present:"ì™€ìš”",past:"ì™”ì–´ìš”"},
  "ë³´ë‹¤":{present:"ë´ìš”",past:"ë´¤ì–´ìš”"},
  "í•˜ë‹¤":{present:"í•´ìš”",past:"í–ˆì–´ìš”"},
  "ë¨¹ë‹¤":{past:"ë¨¹ì—ˆì–´ìš”"},
  "ì½ë‹¤":{past:"ì½ì—ˆì–´ìš”"},
  "ë§ˆì‹œë‹¤":{past:"ë§ˆì…¨ì–´ìš”"},
  "ì‚´ë‹¤":{past:"ì‚´ì•˜ì–´ìš”"}
};

function presentPolite(dict){
  if(specialVerbMap[dict]?.present)return specialVerbMap[dict].present;
  if(dict==="í•˜ë‹¤")return"í•´ìš”";
  const stem=getVerbStem(dict);
  const d=decomposeLastSyl(stem);
  if(!d)return stem+"ìš”";
  const v=JUNG[d.jung];
  const aGroup=["ã…","ã…‘","ã…—","ã…›","ã…˜","ã…™","ã…š"].includes(v);
  if(stem.length===1&&aGroup)return stem+"ìš”";
  return stem+(aGroup?"ì•„ìš”":"ì–´ìš”");
}
function pastPolite(dict){
  if(specialVerbMap[dict]?.past)return specialVerbMap[dict].past;
  if(dict==="í•˜ë‹¤")return"í–ˆì–´ìš”";
  const stem=getVerbStem(dict);
  const d=decomposeLastSyl(stem);
  if(!d)return stem+"ì—ˆì–´ìš”";
  const v=JUNG[d.jung];
  const aGroup=["ã…","ã…‘","ã…—","ã…›","ã…˜","ã…™","ã…š"].includes(v);
  if(aGroup)return stem+"ì•˜ì–´ìš”";
  return stem+"ì—ˆì–´ìš”";
}
function stemPlusAeo(dict){
  if(dict==="í•˜ë‹¤")return"í•´";
  const stem=getVerbStem(dict);
  const d=decomposeLastSyl(stem);
  if(!d)return stem;
  const v=JUNG[d.jung];
  const aGroup=["ã…","ã…‘","ã…—","ã…›","ã…˜","ã…™","ã…š"].includes(v);
  if(stem.length===1&&aGroup)return stem;
  return stem+(aGroup?"ì•„":"ì–´");
}

/* FUTUR -(ìœ¼)ã„¹â€¦ cu compunerea corectÄƒ a lui ã„¹ */
function futureL(dict){
  const stem=getVerbStem(dict);
  const d=decomposeLastSyl(stem);
  if(!d)return stem+"á†¯"; // fallback rar
  if(d.jong===0){
    // fÄƒrÄƒ batchim â†’ punem ã„¹ ca ë°›ì¹¨: ì â†’ ì˜, ê°€ â†’ ê°ˆ
    const newCode=H_BASE + d.cho*21*28 + d.jung*28 + 8; // index 8 = ã„¹
    const ch=String.fromCharCode(newCode);
    return d.prefix+ch;
  }else{
    // cu batchim â†’ adÄƒugÄƒm "ì„" separat: ë¨¹ë‹¤ â†’ ë¨¹ì„
    return stem+"ì„";
  }
}

/* conjugÄƒri care leagÄƒ P2 */
const linkingConjugations=new Set([
  "-ê³  ë‚˜ì„œ","-ê¸° ì „ì—","-(ìœ¼)ë©´ì„œ","-(ìœ¼)ë©°",
  "-(ìœ¼)ë‚˜","-(ìœ¼)ë¯€ë¡œ","-(ìœ¼)ã„´/ëŠ” ë§Œí¼",
  "-(ìœ¼)ã„¹ìˆ˜ë¡","-(ìœ¼)ã„´/ëŠ”ë°ë„","-(ìœ¼)ã„¹ì§€ë¼ë„",
  "-(ìœ¼)ã„´/ëŠ” ë°˜ë©´ì—","-ë„ë¡ í•˜ë‹¤","-ê¸°ì—","-ê¸¸ë˜","-ê³  ë§ë‹¤","-ê³ ì í•˜ë‹¤"
]);
const isLinkingConj=v=>linkingConjugations.has(v);

/* ce conjugÄƒri â€tragâ€ spre trecut / viitor */
const timePastWords=new Set(["ì–´ì œ","ì´ì „ì—","ë‹¹ì‹œì—","í•œë™ì•ˆ","ìµœê·¼ì—","ë§ˆì¹¨ë‚´","ê²°êµ­","ë°©ê¸ˆ"]);
const timeFutureWords=new Set(["ë‚´ì¼","ì¡°ê¸ˆ í›„ì—","ê³§","ì´í›„ì—"]);
const conjPastLike=new Set(["-ì•˜ì–´ìš”/ì—ˆì–´ìš”","-ë”ë¼ê³ ìš”"]);
const conjFutureLike=new Set(["-(ìœ¼)ã„¹ ê±°ì˜ˆìš”","-(ìœ¼)ã„¹ê²Œìš”","-(ìœ¼)ã„¹ë˜ìš”?","-(ìœ¼)ã„¹ì§€ë„ ëª°ë¼ìš”"]);
function conjugationType(cj){
  if(!cj)return"none";
  if(conjPastLike.has(cj))return"past";
  if(conjFutureLike.has(cj))return"future";
  return"present";
}

/* === VERB + CONJUGARE â†’ expresie finalÄƒ coreeanÄƒ === */
function buildVerbPhrase(dictVerb,cj){
  if(!dictVerb&&!cj)return"";
  if(!dictVerb)return cj||"";
  if(!cj)return dictVerb;

  if(cj==="-ì•„ìš”/ì–´ìš”")return presentPolite(dictVerb);
  if(cj==="-ì•˜ì–´ìš”/ì—ˆì–´ìš”")return pastPolite(dictVerb);
  if(cj==="-(ìœ¼)ì„¸ìš”")return futureL(dictVerb)+"ì„¸ìš”";
  if(cj==="-(ìœ¼)ã„¹ ê±°ì˜ˆìš”")return futureL(dictVerb)+" ê±°ì˜ˆìš”";
  if(cj==="-(ìœ¼)ã„¹ê²Œìš”")return futureL(dictVerb)+"ê²Œìš”";
  if(cj==="-(ìœ¼)ã„¹ë˜ìš”?")return futureL(dictVerb)+"ë˜ìš”?";
  if(cj==="-(ìœ¼)ã„¹ê¹Œìš”?")return futureL(dictVerb)+"ê¹Œìš”?";
  if(cj==="-(ìœ¼)ã„¹ ìˆ˜ ìˆì–´ìš”")return futureL(dictVerb)+" ìˆ˜ ìˆì–´ìš”";
  if(cj==="-(ìœ¼)ã„¹ ìˆ˜ ì—†ì–´ìš”")return futureL(dictVerb)+" ìˆ˜ ì—†ì–´ìš”";
  if(cj==="-(ìœ¼)ã„¹ì§€ë„ ëª°ë¼ìš”")return futureL(dictVerb)+"ì§€ë„ ëª°ë¼ìš”";

  if(cj==="-ê³  ìˆì–´ìš”")return getVerbStem(dictVerb)+"ê³  ìˆì–´ìš”";
  if(cj==="-ê³  ì‹¶ì–´ìš”")return getVerbStem(dictVerb)+"ê³  ì‹¶ì–´ìš”";
  if(cj==="-ì§€ ë§ˆì„¸ìš”")return getVerbStem(dictVerb)+"ì§€ ë§ˆì„¸ìš”";
  if(cj==="-ì•„/ì–´ ì£¼ì„¸ìš”")return stemPlusAeo(dictVerb)+" ì£¼ì„¸ìš”";
  if(cj==="-ì•„/ì–´ì•¼ ë¼ìš”")return stemPlusAeo(dictVerb)+"ì•¼ ë¼ìš”";
  if(cj==="-ëŠ” ì¤‘ì´ì—ìš”")return getVerbStem(dictVerb)+"ëŠ” ì¤‘ì´ì—ìš”";
  if(cj==="-ì•„/ì–´ë„ ë¼ìš”")return stemPlusAeo(dictVerb)+"ë„ ë¼ìš”";

  if(cj==="-ê²Œ ë˜ë‹¤")return getVerbStem(dictVerb)+"ê²Œ ë¼ìš”";
  if(cj==="-ì•„/ì–´ì§€ë‹¤")return stemPlusAeo(dictVerb)+"ì§€ë‹¤";

  if(isLinkingConj(cj)){
    if(cj==="-ê³  ë‚˜ì„œ")return getVerbStem(dictVerb)+"ê³  ë‚˜ì„œ";
    if(cj==="-ê¸° ì „ì—")return getVerbStem(dictVerb)+"ê¸° ì „ì—";
    if(cj.includes("ë©´ì„œ"))return getVerbStem(dictVerb)+"ë©´ì„œ";
    if(cj.includes("ë©°"))return getVerbStem(dictVerb)+"ë©°";
    if(cj==="-ë„ë¡ í•˜ë‹¤")return getVerbStem(dictVerb)+"ë„ë¡ í•´ìš”";
    if(cj==="-ê³  ë§ë‹¤")return getVerbStem(dictVerb)+"ê³  ë§ì•˜ì–´ìš”";
    if(cj==="-ê³ ì í•˜ë‹¤")return getVerbStem(dictVerb)+"ê³ ì í•´ìš”";
    if(cj==="-ê¸°ì—")return getVerbStem(dictVerb)+"ê¸°ì—";
    if(cj==="-ê¸¸ë˜")return getVerbStem(dictVerb)+"ê¸¸ë˜";
    return getVerbStem(dictVerb)+cj.replace(/^-/, "");
  }

  // fallback â€“ verb + final, fÄƒrÄƒ spaÈ›iu È™i fÄƒrÄƒ â€-â€
return getVerbStem(dictVerb)+cj.replace(/^-/, "");
}

/* === RESTUL APP-ULUI (builder, preview etc.) === */

const glossaryEntries=[];
const columns=[
  {key:"subject",title:"SUBJECT",ko:"ì£¼ì–´",data:subjects,hint:"Cine?",allowCustom:true},
  {key:"time",title:"TIME",ko:"ì‹œê°„",data:times,hint:"CÃ¢nd?",allowCustom:true},
  {key:"place",title:"PLACE",ko:"ì¥ì†Œ",data:places,hint:"Unde?",allowCustom:true},
  {key:"mod",title:"MOD",ko:"ë°©ë²•",data:mods,hint:"Cum?",allowCustom:true},
  {key:"object",title:"OBJECT",ko:"ëª©ì ì–´",data:objects,hint:"Ce?",allowCustom:true},
  {key:"numeral",title:"NUMERAL",ko:"",data:numerals,hint:"NumÄƒr",allowCustom:true},
  {key:"counter",title:"COUNTER",ko:"ìˆ˜ëŸ‰ì‚¬",data:counters,hint:"Clasificator",allowCustom:true},
  {key:"verb",title:"VERB",ko:"ë™ì‚¬",data:verbs,hint:"AcÈ›iune",allowCustom:true},
  {key:"conjug",title:"CONJUGÄ‚RI",ko:"",data:conjugations,hint:"FormÄƒ verbalÄƒ",allowCustom:true}
];
const maxLen=Math.max(...columns.map(c=>c.data.length));

let index=0;
const stateP1={},stateP2={},activeP1={},activeP2={};
columns.forEach(col=>{
  stateP1[col.key]=col.data[0]||"";
  stateP2[col.key]=col.data[0]||"";
  activeP1[col.key]=true;
  activeP2[col.key]=true;
});

/* referinÈ›e DOM (presupunem cÄƒ restul HTML e ca Ã®n versiunea ta actualÄƒ) */
const tableP1=document.getElementById("tableP1");
const tableP2=document.getElementById("tableP2");
const titleP2=document.getElementById("titleP2");
const togglesP1=document.getElementById("togglesP1");
const togglesP2=document.getElementById("togglesP2");
const enableP2=document.getElementById("enableP2");
const prevBtn=document.getElementById("prevBtn");
const nextBtn=document.getElementById("nextBtn");
const resetBtn=document.getElementById("resetBtn");
const pageInfoEl=document.getElementById("pageInfo");
const previewKo=document.getElementById("previewKo");
const previewRo=document.getElementById("previewRo");
const naturalHint=document.getElementById("naturalHint");
const toggleRoBtn=document.getElementById("toggleRoBtn");
const randomBtn=document.getElementById("randomBtn");
const speakBtn=document.getElementById("speakBtn");
const favBtn=document.getElementById("favBtn");
const overlay=document.getElementById("overlay");
const panelTitle=document.getElementById("panelTitle");
const panelSub=document.getElementById("panelSub");
const panelList=document.getElementById("panelList");
const closePanelBtn=document.getElementById("closePanelBtn");
const panelSearchInput=document.getElementById("panelSearchInput");
const newWordInput=document.getElementById("newWordInput");
const newWordTransInput=document.getElementById("newWordTransInput");
const addWordBtn=document.getElementById("addWordBtn");
const modeButtons=document.querySelectorAll(".small-mode-btn");
const subtitleEl=document.getElementById("subtitle");
const screens={
  builder:document.getElementById("screen-builder"),
  exercises:document.getElementById("screen-exercises"),
  glossary:document.getElementById("screen-glossary")
};
const navButtons=document.querySelectorAll(".nav-btn");

/* mod simplu / TOPIK */
let currentMode="topik";
const simpleColumnsSet={subject:true,time:true,object:true,verb:true,conjug:true};
function isColumnVisible(key){
  return currentMode==="topik"||!!simpleColumnsSet[key];
}
modeButtons.forEach(btn=>{
  btn.addEventListener("click",()=>{
    currentMode=btn.dataset.mode;
    modeButtons.forEach(b=>b.classList.toggle("active",b===btn));
    render();
  });
});
    const roTranslateBtn = document.getElementById("roTranslateBtn");
if(roTranslateBtn){
  roTranslateBtn.addEventListener("click",()=>{
    const txt = roInput.value;
    LAST_RO_SENTENCE = txt;

    // 1) parsez fraza romÃ¢nÄƒ â†’ SUBJ / TIME / PLACE / VERB / CONJUGARE
    const parsed = parseRoToState(txt);

    // 2) umplu PropoziÈ›ia 1 cu ce a gÄƒsit parserul
    Object.assign(stateP1, parsed.state);
    render();   // re-desenÄƒm tabelul + propoziÈ›ia de jos

    // 3) afiÈ™ez sus rezultatul Roâ†’Ko + romÃ¢na corectatÄƒ
    const res = translateRoToKo(txt);
    document.getElementById("roToKoResult").textContent = res.ko;
    document.getElementById("roCorrected").textContent = res.roFixed;
  });
}
/* navigare ecrane */
function setScreen(name){
  Object.entries(screens).forEach(([k,el])=>{
    el.classList.toggle("active",k===name);
  });
  navButtons.forEach(btn=>btn.classList.toggle("active",btn.dataset.target===name));
  if(name==="builder")subtitleEl.textContent="Builder propoziÈ›ii + particule + audio + conjugÄƒri";
  else if(name==="exercises")subtitleEl.textContent="ExerciÈ›ii TOPIK â€“ verb, particulÄƒ, conjugare";
  else subtitleEl.textContent="Glosar + propoziÈ›ii favorite";
}
navButtons.forEach(btn=>btn.addEventListener("click",()=>setScreen(btn.dataset.target)));

/* toggles P1 / P2 */
function createToggleChips(){
  columns.forEach(col=>{
    const chip1=document.createElement("label");
    chip1.className="chip";
    const cb1=document.createElement("input");
    cb1.type="checkbox";cb1.checked=true;cb1.dataset.key=col.key;cb1.dataset.clause="p1";
    chip1.appendChild(cb1);chip1.append(col.title);togglesP1.appendChild(chip1);

    const chip2=document.createElement("label");
    chip2.className="chip";
    const cb2=document.createElement("input");
    cb2.type="checkbox";cb2.checked=true;cb2.dataset.key=col.key;cb2.dataset.clause="p2";
    chip2.appendChild(cb2);chip2.append(col.title);togglesP2.appendChild(chip2);
  });
  const sync=(wrapper,map)=>{
    wrapper.addEventListener("change",e=>{
      const cb=e.target;if(cb.tagName!=="INPUT")return;
      map[cb.dataset.key]=cb.checked;render();
    });
  };
  sync(togglesP1,activeP1);
  sync(togglesP2,activeP2);
}
createToggleChips();

enableP2.addEventListener("change",()=>{
  const on=enableP2.checked;
  if(on){titleP2.classList.remove("hidden");tableP2.classList.remove("hidden");}
  else{titleP2.classList.add("hidden");tableP2.classList.add("hidden");}
  updatePreview();
});

/* helper particule */
const pronouns=new Set(["ì €","ë‚˜","ë„ˆ","ìš°ë¦¬","ë„ˆí¬"]);
function addSubjectWithParticle(word){
  if(!word)return"";
  const b=hasBatchim(word);
  if(pronouns.has(word))return word+(b?"ì€":"ëŠ”");
  return word+(b?"ì´":"ê°€");
}
const timeAdverbsNoParticle=new Set(["ì˜¤ëŠ˜","ì–´ì œ","ë‚´ì¼","ì§€ê¸ˆ","ë°©ê¸ˆ","ìš”ì¦˜","í•­ìƒ","ìì£¼","ê°€ë”","ê³„ì†","ì ì ","ì°¨ì¸°"]);
function addTimeWithParticle(word){
  if(!word)return"";
  if(timeAdverbsNoParticle.has(word))return word;
  return word+"ì—";
}
function addPlaceWithParticle(word, verbKo){
  if(!word) return "";

  // verbe de miÈ™care â€“ merg la / vin la â†’ ì—
  const motionVerbs = new Set(["ê°€ë‹¤","ì˜¤ë‹¤","ë‚˜ê°€ë‹¤","ë“¤ì–´ê°€ë‹¤","ëŒì•„ê°€ë‹¤","ëŒì•„ì˜¤ë‹¤"]);

  if(verbKo && motionVerbs.has(verbKo)) {
    return word + "ì—";
  }
  // altfel, locul acÈ›iunii â†’ ì—ì„œ
  return word + "ì—ì„œ";
}
function addObjectWithParticle(word){
  if(!word)return"";
  return word+(hasBatchim(word)?"ì„":"ë¥¼");
}
// ================= PARTICLE PICKERS (pentru exerciÈ›ii particlePlus) =================

function pickSubjectParticle(word){
  if(!word) return "ì€/ëŠ”";
  const b = hasBatchim(word);
  // pronume: ì €/ë‚˜/ë„ˆ/ìš°ë¦¬/ë„ˆí¬ -> ì€/ëŠ”
  if(pronouns.has(word)) return b ? "ì€" : "ëŠ”";
  // rest -> ì´/ê°€
  return b ? "ì´" : "ê°€";
}

function pickObjectParticle(word){
  if(!word) return "ì„/ë¥¼";
  return hasBatchim(word) ? "ì„" : "ë¥¼";
}

// TIME: majoritatea adverbelor nu cer particulÄƒ
function pickTimeParticle(word){
  if(!word) return "";
  if(timeAdverbsNoParticle.has(word)) return "";
  return "ì—";
}

// PLACE: pentru exerciÈ›ii â€“ locul acÈ›iunii
function pickPlaceParticle(word){
  if(!word) return "ì—ì„œ";
  return "ì—ì„œ";
}
/* desenare coloane */
function renderClauseRow(container,activeMap,state,clauseId){
  container.innerHTML="";
  columns.forEach(col=>{
    if(!isColumnVisible(col.key))return;
    const colDiv=document.createElement("div");
    colDiv.className="col";
    if(!activeMap[col.key])colDiv.classList.add("dimmed");
    colDiv.dataset.key=col.key;
    colDiv.dataset.clause=clauseId;

    const header=document.createElement("div");
    header.className="col-header";
    header.textContent=col.title+(col.ko?` (${col.ko})`:"");
    colDiv.appendChild(header);

    const label=document.createElement("div");
    label.className="col-body-label";
    label.textContent=col.hint||"";
    colDiv.appendChild(label);

    const main=document.createElement("div");
    main.className="col-body-main";
    main.textContent=state[col.key]||"";
    colDiv.appendChild(main);

    const extra=document.createElement("div");
    extra.className="col-body-extra";
    if(col.key==="conjug"&&state[col.key]&&isLinkingConj(state[col.key]))extra.textContent="â­ cere propoziÈ›ia 2";
    colDiv.appendChild(extra);
    container.appendChild(colDiv);
  });
}

/* === CONSTRUIRE propoziÈ›ie + traducere pe pÄƒrÈ›i === */
const labelsRo={
  subject:"SUBJECT",
  time:"TIME",
  place:"PLACE",
  mod:"MOD",
  object:"OBJECT",
  numeral:"NUMÄ‚R",
  counter:"COUNTER",
  verb:"VERB"
};
function buildClauseSentence(state,activeMap,conjOverride){
  const koParts = [];
  const roSegs  = [];
  const use = (key) => activeMap[key] !== false && isColumnVisible(key);

  // SUBJECT
  const subj = state.subject;
  if (subj && use("subject")) {
    koParts.push(addSubjectWithParticle(subj));
    const ro = (translations.subject && translations.subject[subj]) || subj;
    roSegs.push(`${labelsRo.subject}: ${ro}`);
  }

  // TIME
  const t = state.time;
  if (t && use("time")) {
    koParts.push(addTimeWithParticle(t));
    const ro = (translations.time && translations.time[t]) || t;
    roSegs.push(`${labelsRo.time}: ${ro}`);
  }

  // avem nevoie de verb & conjugare pentru loc
  const v      = state.verb;
  const cjUsed = conjOverride || state.conjug;

  // PLACE
  const p = state.place;
  if (p && use("place")) {
    koParts.push(addPlaceWithParticle(p, v));
    const ro = (translations.place && translations.place[p]) || p;
    roSegs.push(`${labelsRo.place}: ${ro}`);
  }

  // MOD
  const m = state.mod;
  if (m && use("mod")) {
    koParts.push(m);
    const ro = (translations.mod && translations.mod[m]) || m;
    roSegs.push(`${labelsRo.mod}: ${ro}`);
  }

  // OBJECT
  const obj = state.object;
  if (obj && use("object")) {
    koParts.push(addObjectWithParticle(obj));
    const ro = (translations.object && translations.object[obj]) || obj;
    roSegs.push(`${labelsRo.object}: ${ro}`);
  }

  // NUMERAL
  const num = state.numeral;
  if (num && use("numeral")) {
    koParts.push(num);
    const ro = (translations.numeral && translations.numeral[num]) || num;
    roSegs.push(`${labelsRo.numeral}: ${ro}`);
  }

  // COUNTER
  const cnt = state.counter;
  if (cnt && use("counter")) {
    koParts.push(cnt);
    const ro = (translations.counter && translations.counter[cnt]) || cnt;
    roSegs.push(`${labelsRo.counter}: ${ro}`);
  }

  // VERB + CONJUGARE
  if (v || cjUsed) {
    const vp = buildVerbPhrase(v, cjUsed);
    if (vp) {
      koParts.push(vp);
      const roVerb = (translations.verb && translations.verb[v]) || v || "";
      const cjExp  = (translations.conjug && translations.conjug[cjUsed]) || "";
      let combined = roVerb || "";
      if (cjExp) combined += ` (${cjExp})`;
      roSegs.push(`${labelsRo.verb}: ${combined}`);
    }
  }

  return {
    ko:     koParts.join(" "),
    roText: roSegs.join(" / "),
    time:   t,
    conj:   cjUsed
  };
}

// conjugÄƒri RO (minim dar util, pentru verbele din app)
    // ==== CONJUGARE ROMÃ‚NEASCÄ‚ (simplÄƒ) ====
const RO_FORMS = {
  "a merge":   { "1sg":"merg","2sg":"mergi","3sg":"merge","1pl":"mergem","2pl":"mergeÈ›i","3pl":"merg" },
  "a veni":    { "1sg":"vin","2sg":"vii","3sg":"vine","1pl":"venim","2pl":"veniÈ›i","3pl":"vin" },
  "a mÃ¢nca":   { "1sg":"mÄƒnÃ¢nc","2sg":"mÄƒnÃ¢nci","3sg":"mÄƒnÃ¢ncÄƒ","1pl":"mÃ¢ncÄƒm","2pl":"mÃ¢ncaÈ›i","3pl":"mÄƒnÃ¢ncÄƒ" },
  "a bea":     { "1sg":"beau","2sg":"bei","3sg":"bea","1pl":"bem","2pl":"beÈ›i","3pl":"beau" },
  "a citi":    { "1sg":"citesc","2sg":"citeÈ™ti","3sg":"citeÈ™te","1pl":"citim","2pl":"citiÈ›i","3pl":"citesc" },
  "a scrie":   { "1sg":"scriu","2sg":"scrii","3sg":"scrie","1pl":"scriem","2pl":"scrieÈ›i","3pl":"scriu" },
  "a merge pe jos": {
    "1sg":"merg pe jos","2sg":"mergi pe jos","3sg":"merge pe jos",
    "1pl":"mergem pe jos","2pl":"mergeÈ›i pe jos","3pl":"merg pe jos"
  },
  // ğŸ‘‡ nou
  "a pleca": {
    "1sg":"plec","2sg":"pleci","3sg":"pleacÄƒ",
    "1pl":"plecÄƒm","2pl":"plecaÈ›i","3pl":"pleacÄƒ"
  }
};
function stripInfinitive(roVerb){
  return (roVerb || "").replace(/^\s*a\s+/i, "").trim();
}

function roConjExactTemplate(cj){
  const map = {
    "-ì•„ìš”/ì–´ìš”":         v => `${v}`,
    "-ì•˜ì–´ìš”/ì—ˆì–´ìš”":     v => `${v} (Ã®n trecut)`,
    "-ê³  ìˆì–´ìš”":         v => `${v} acum`,
    "-ê³  ì‹¶ì–´ìš”":         v => `vreau sÄƒ ${v}`,
    "-(ìœ¼)ã„¹ ê±°ì˜ˆìš”":      v => `voi ${v}`,
    "-ì§€ ë§ˆì„¸ìš”":         v => `nu ${v}, te rog`,
    "-ì•„/ì–´ì•¼ ë¼ìš”":       v => `trebuie sÄƒ ${v}`,
    "-(ìœ¼)ã„¹ ìˆ˜ ìˆì–´ìš”":   v => `pot sÄƒ ${v}`,
    "-(ìœ¼)ã„¹ ìˆ˜ ì—†ì–´ìš”":   v => `nu pot sÄƒ ${v}`,
    "-ê¸° ì „ì—":           v => `Ã®nainte sÄƒ ${v}`,
    "-ê³  ë‚˜ì„œ":           v => `dupÄƒ ce ${v}`,
    "-(ìœ¼)ë©´ì„œ":           v => `Ã®n timp ce ${v}`,
    "-(ìœ¼)ã„¹ê¹Œìš”?":        v => `sÄƒ ${v}?`
  };
  return map[cj] || null;
}

function roPersonFromSubjectKo(subjKo){
  if(subjKo==="ì €"||subjKo==="ë‚˜") return "1sg";
  if(subjKo==="ë„ˆ")               return "2sg";
  if(subjKo==="ìš°ë¦¬")             return "1pl";
  if(subjKo==="ë„ˆí¬")             return "2pl";
  return "3sg";
}

function roAgreeVerb(roVerbInf, subjKo, verbKo){
  let inf = (roVerbInf || "").trim().toLowerCase();
  const person = roPersonFromSubjectKo(subjKo);

  // special: dacÄƒ Ã®n fraza originalÄƒ apare "pleca" È™i verbul coreean e ê°€ë‹¤,
  // folosim "a pleca" ca infinitiv
  if(verbKo === "ê°€ë‹¤" &&
     LAST_RO_SENTENCE.toLowerCase().includes("pleca")){
    inf = "a pleca"; // deocamdatÄƒ nu Ã®l conjugÄƒm special, doar Ã®l pÄƒstrÄƒm la infinitiv
  }

  const forms = RO_FORMS[inf];
  if(forms && forms[person]) return forms[person];

  // fallback: scoatem "a " È™i folosim forma de dicÈ›ionar
  return stripInfinitive(roVerbInf);
}

function buildRoVerbPhrase(roVerbInf, cj, subjKo, verbKo){
  const v = roAgreeVerb(roVerbInf, subjKo, verbKo);
  if(!v && !cj) return "";
  if(!cj) return v;

  const fn = roConjExactTemplate(cj);
  if(fn) return fn(v || "(verbul)");

  const cjExp = (translations.conjug && translations.conjug[cj]) || cj;
  return (v ? v + " " : "") + `(${cjExp})`;
}

/* PropoziÈ›ie romÃ¢neascÄƒ naturalÄƒ â€“ Ordine: Timp â†’ Subiect â†’ Loc â†’ Mod â†’ Obiect â†’ Verb */
function buildNaturalRomanian(state, activeMap){
  const use = (key) =>
    activeMap[key] !== false && isColumnVisible(key) && state[key];

  const getRo = (catKey, stateKey) => {
    const dict = translations[catKey] || {};
    const raw  = state[stateKey];
    if (!raw) return "";
    return dict[raw] || raw;
  };

  const timeRo    = use("time")    ? getRo("time", "time")       : "";
  const subjRo    = use("subject") ? getRo("subject", "subject") : "";
  const placeRaw  = use("place")   ? getRo("place", "place")     : "";
  const modRo     = use("mod")     ? getRo("mod", "mod")         : "";
  const objectRo  = use("object")  ? getRo("object", "object")   : "";
  const numeralRo = use("numeral") ? (state.numeral || "")       : "";

  // obiect = numÄƒr + substantiv
  let objectPhrase = "";
  if (objectRo) {
    const objPieces = [];
    if (numeralRo) objPieces.push(numeralRo);
    objPieces.push(objectRo);
    objectPhrase = objPieces.join(" ");
  }

  // locul: â€acasÄƒâ€ rÄƒmÃ¢ne, restul devin â€la Xâ€
  let placePhrase = "";
  if (placeRaw) {
    if (placeRaw === "acasÄƒ") {
      placePhrase = placeRaw;
    } else if (/^(la |Ã®n |in )/i.test(placeRaw)) {
      placePhrase = placeRaw;
    } else {
      placePhrase = "la " + placeRaw;
    }
  }

  // verb + timp (doar formÄƒ simplÄƒ, fÄƒrÄƒ paranteze)
  const verbRaw   = state.verb || "";
  const verbRoInf =
    (translations.verb && translations.verb[verbRaw]) || verbRaw || "";
  const conjUsed =
    (activeMap.conjug !== false && isColumnVisible("conjug"))
      ? (state.conjug || "")
      : "";

  let verbPhrase = "";
  if (activeMap.verb !== false && isColumnVisible("verb")) {
    const cType = conjugationType(conjUsed); // "present" / "past" / "future"
    const person = roPersonFromSubjectKo(state.subject);
    
    // forme la trecut pentru cele mai folosite verbe
   const RO_PAST = {
  "a merge":   { "1sg":"am mers","2sg":"ai mers","3sg":"a mers","1pl":"am mers","2pl":"aÈ›i mers","3pl":"au mers" },
  "a veni":    { "1sg":"am venit","2sg":"ai venit","3sg":"a venit","1pl":"am venit","2pl":"aÈ›i venit","3pl":"au venit" },
  "a mÃ¢nca":   { "1sg":"am mÃ¢ncat","2sg":"ai mÃ¢ncat","3sg":"a mÃ¢ncat","1pl":"am mÃ¢ncat","2pl":"aÈ›i mÃ¢ncat","3pl":"au mÃ¢ncat" },
  "a bea":     { "1sg":"am bÄƒut","2sg":"ai bÄƒut","3sg":"a bÄƒut","1pl":"am bÄƒut","2pl":"aÈ›i bÄƒut","3pl":"au bÄƒut" },
  "a citi":    { "1sg":"am citit","2sg":"ai citit","3sg":"a citit","1pl":"am citit","2pl":"aÈ›i citit","3pl":"au citit" },
  "a scrie":   { "1sg":"am scris","2sg":"ai scris","3sg":"a scris","1pl":"am scris","2pl":"aÈ›i scris","3pl":"au scris" },
  "a cumpÄƒra": { "1sg":"am cumpÄƒrat","2sg":"ai cumpÄƒrat","3sg":"a cumpÄƒrat","1pl":"am cumpÄƒrat","2pl":"aÈ›i cumpÄƒrat","3pl":"au cumpÄƒrat" },
  // ğŸ‘‡ nou
  "a pleca":   { "1sg":"am plecat","2sg":"ai plecat","3sg":"a plecat","1pl":"am plecat","2pl":"aÈ›i plecat","3pl":"au plecat" }
};
    if (cType === "past") {
      const inf = (verbRoInf || "").toLowerCase().trim();
      const table = RO_PAST[inf];
      if (table && table[person]) {
        verbPhrase = table[person];     // ex: â€am mersâ€
      } else {
        verbPhrase = "am " + stripInfinitive(verbRoInf || "");
      }
    } else if (cType === "future") {
      const base = stripInfinitive(verbRoInf || "");
      verbPhrase = "voi " + base;       // simplificat
    } else {
      // prezent â€“ folosim logica existentÄƒ
      verbPhrase = roAgreeVerb(verbRoInf, state.subject, state.verb);
    }
  }

  // ordinea finalÄƒ: Timp â†’ Subiect â†’ Verb â†’ Mod â†’ Loc â†’ Obiect
  const parts = [];
  if (timeRo)       parts.push(timeRo);        // AstÄƒzi
  if (subjRo)       parts.push(subjRo);        // eu (formal)
  if (verbPhrase)   parts.push(verbPhrase);    // am mers / merg
  if (modRo)        parts.push(modRo);         // repede
  if (placePhrase)  parts.push(placePhrase);   // la È™coalÄƒ
  if (objectPhrase) parts.push(objectPhrase);  // cartea etc.

  if (!parts.length) return "";

  let sentence = parts.join(" ");
  sentence = sentence.replace(/\s+/g," ");
  sentence = sentence.charAt(0).toUpperCase() + sentence.slice(1);
  if (!/[.!?]$/.test(sentence)) sentence += ".";
  return sentence;
}
function analyzeNaturalnessP1(){
  const t=stateP1.time;
  const cj=stateP1.conjug;
  if(!t||!cj)return{ok:true,msg:"",suggestion:null};
  const tType=timePastWords.has(t)?"past":
              timeFutureWords.has(t)?"future":"neutral";
  const cType=conjugationType(cj);
  if(tType==="past"&&cType==="future"){
    const suggested="-ì•˜ì–´ìš”/ì—ˆì–´ìš”";
    const sent=buildClauseSentence(stateP1,activeP1,suggested);
    return{
      ok:false,
      msg:`â€${t}â€ (trecut) cu final viitor â€${cj}â€ nu se prea foloseÈ™te. Exemplu mai natural:`,
      suggestion:sent.ko
    };
  }
  if(tType==="future"&&cType==="past"){
    const suggested="-(ìœ¼)ã„¹ ê±°ì˜ˆìš”";
    const sent=buildClauseSentence(stateP1,activeP1,suggested);
    return{
      ok:false,
      msg:`â€${t}â€ (viitor) cu final de trecut â€${cj}â€ poate suna nenatural. Exemplu mai natural:`,
      suggestion:sent.ko
    };
  }
  return{ok:true,msg:"",suggestion:null};
}

let showRo=true;

function updatePreview() {
  // 1) PropoziÈ›ia 1 (P1)
  const c1 = buildClauseSentence(stateP1, activeP1, null);
  let fullKo = c1.ko || "";

  // 2) PropoziÈ›ia 2 (P2) â€“ doar dacÄƒ existÄƒ conjuncÈ›ie de legÄƒturÄƒ
  let c2 = null;
  if (
    enableP2.checked &&
    stateP1.conjug &&
    isLinkingConj(stateP1.conjug)
  ) {
    c2 = buildClauseSentence(stateP2, activeP2, null);
    if (c2.ko) {
      fullKo += " " + c2.ko;  // âœ AICI SE LIPESC P1 + P2
    }
  }

  // 3) DacÄƒ nu avem nimic de afiÈ™at
  if (!fullKo.trim()) {
    previewKo.textContent = "(alege cuvinte din tabel)";
    previewRo.textContent = "";
    naturalHint.textContent = "";
    return;
  }

  // AfiÈ™Äƒm coreeana completÄƒ
  previewKo.textContent = fullKo;

  // 4) TRADUCEREA ROMÃ‚NEASCÄ‚ NATURALÄ‚
  const ro1 = buildNaturalRomanian(stateP1, activeP1);
  const ro2 = c2 ? buildNaturalRomanian(stateP2, activeP2) : "";
  const fullRo = ro1 + (ro2 ? " " + ro2 : "");

  previewRo.textContent = showRo
    ? fullRo
    : "Â·Â·Â· traducere ascunsÄƒ Â·Â·Â·";

  // 5) Naturalitate
  const nat = analyzeNaturalnessP1();
  if (nat.ok) {
    naturalHint.textContent =
      "âœ… PropoziÈ›ie naturalÄƒ (dupÄƒ regulile simple din aplicaÈ›ie).";
  } else {
    naturalHint.textContent = `âš  ${nat.msg} ã€Œ${nat.suggestion}ã€`;
  }
}
    function loadRow(i){
  columns.forEach(col=>{
    stateP1[col.key]=col.data[i]||"";
  });
}
prevBtn.addEventListener("click",()=>{
  if(index>0){index--;loadRow(index);render();}
});
nextBtn.addEventListener("click",()=>{
  if(index<maxLen-1){index++;loadRow(index);render();}
});
resetBtn.addEventListener("click",()=>{
  [...togglesP1.querySelectorAll("input")].forEach(cb=>{cb.checked=true;activeP1[cb.dataset.key]=true;});
  [...togglesP2.querySelectorAll("input")].forEach(cb=>{cb.checked=true;activeP2[cb.dataset.key]=true;});
  render();
});
toggleRoBtn.addEventListener("click",()=>{
  showRo=!showRo;
  toggleRoBtn.textContent=showRo?"Ascunde traducerea":"AratÄƒ traducerea";
  updatePreview();
});

/* panel liste + adÄƒugare cuvÃ¢nt nou â€“ exact ca Ã®nainte (nu schimb logicÄƒ) */
let panelClause="p1",panelKey="subject";
function renderPanelList(col){
  panelList.innerHTML="";
  const key=col.key;
  const map=translations[key]||{};
  const filter=(panelSearchInput.value||"").trim().toLowerCase();
  const words=col.data.filter(w=>{
    if(!w)return false;
    if(!filter)return true; 
    return w.toLowerCase().startsWith(filter);
  });
  if(!words.length){
    const empty=document.createElement("div");
    empty.className="panel-item";
    empty.textContent="Nu existÄƒ cuvinte pentru filtrul introdus.";
    panelList.appendChild(empty);
    return;
  }
  words.forEach(word=>{
    const item=document.createElement("div");
    item.className="panel-item";
    const main=document.createElement("div");
    main.className="panel-item-main";
    main.textContent=word;
    item.appendChild(main);

    const extra=document.createElement("div");
    extra.className="panel-item-extra";
    const ro=map[word];
    if(ro){
      const tag=document.createElement("div");
      tag.className="panel-item-tag";
      tag.textContent=ro;
      extra.appendChild(tag);
    }
    if(key==="conjug"&&isLinkingConj(word)){
      const star=document.createElement("div");
      star.className="panel-item-tag";
      star.textContent="â­ P2";
      extra.appendChild(star);
    }
    item.appendChild(extra);

    item.addEventListener("click",()=>{
      const target=panelClause==="p1"?stateP1:stateP2;
      target[key]=word;
      if(key==="conjug"&&isLinkingConj(word)){
        enableP2.checked=true;
        titleP2.classList.remove("hidden");
        tableP2.classList.remove("hidden");
      }
      overlay.classList.add("hidden");
      render();
    });

    panelList.appendChild(item);
  });
}
function openPanel(clause,key){
  panelClause=clause;panelKey=key;
  const col=columns.find(c=>c.key===key);if(!col)return;
  panelTitle.textContent=(clause==="p1"?"PropoziÈ›ia 1 â€“ ":"PropoziÈ›ia 2 â€“ ")+col.title;
  panelSub.textContent=col.hint||"";
  panelSearchInput.value="";newWordInput.value="";newWordTransInput.value="";
  renderPanelList(col);
  overlay.classList.remove("hidden");
  panelSearchInput.focus();
}
closePanelBtn.addEventListener("click",()=>overlay.classList.add("hidden"));
overlay.addEventListener("click",e=>{if(e.target===overlay)overlay.classList.add("hidden");});
panelSearchInput.addEventListener("input",()=>{
  const col=columns.find(c=>c.key===panelKey);
  if(col)renderPanelList(col);
});
addWordBtn.addEventListener("click",()=>{
  const txt=newWordInput.value.trim();
  if(!txt)return;
  const roTxt=(newWordTransInput.value||"").trim();
  const col=columns.find(c=>c.key===panelKey);
  if(!col||!col.allowCustom)return;

  if(!col.data.includes(txt))col.data.push(txt);
  if(!translations[panelKey])translations[panelKey]={};
  if(roTxt)translations[panelKey][txt]=roTxt;

  if(!customData[panelKey])customData[panelKey]=[];
  const exists=customData[panelKey].some(e=>e.word===txt);
  if(!exists)customData[panelKey].push({word:txt,ro:roTxt});
  else customData[panelKey].forEach(e=>{if(e.word===txt)e.ro=roTxt;});
  saveCustomData();

  newWordInput.value="";newWordTransInput.value="";
  renderPanelList(col);
  REV = buildReverseMap();
});

/* click scurt = urmÄƒtorul cuvÃ¢nt; long press = panel */
function cycleColumnValue(clause,key){
  const col=columns.find(c=>c.key===key);if(!col)return;
  const arr=col.data;
  const state=clause==="p1"?stateP1:stateP2;
  const cur=state[key];
  let idx=arr.indexOf(cur);
  if(idx===-1)idx=0;
  let nextIdx=(idx+1)%arr.length;
  state[key]=arr[nextIdx]||"";
  render();
}
let longPressTimer=null,pressTarget=null;
function attachPressHandlers(tableEl){
  tableEl.addEventListener("pointerdown",e=>{
    const colDiv=e.target.closest(".col");if(!colDiv)return;
    e.preventDefault();
    pressTarget=colDiv;
    longPressTimer=setTimeout(()=>{
      if(pressTarget===colDiv){
        openPanel(colDiv.dataset.clause||"p1",colDiv.dataset.key);
        pressTarget=null;
      }
    },450);
  });
  tableEl.addEventListener("pointerup",e=>{
    const colDiv=e.target.closest(".col");
    if(longPressTimer){clearTimeout(longPressTimer);longPressTimer=null;}
    if(pressTarget&&colDiv===pressTarget){
      cycleColumnValue(colDiv.dataset.clause||"p1",colDiv.dataset.key);
    }
    pressTarget=null;
  });
  tableEl.addEventListener("pointerleave",()=>{
    if(longPressTimer){clearTimeout(longPressTimer);longPressTimer=null;}
    pressTarget=null;
  });
}
attachPressHandlers(tableP1);
attachPressHandlers(tableP2);

/* random, audio, favorite â€“ ca Ã®nainte */
randomBtn.addEventListener("click",()=>{
  columns.forEach(col=>{
    if(!activeP1[col.key]||!isColumnVisible(col.key))return;
    const arr=col.data.filter(x=>x!==""&&x!=null);
    if(!arr.length)return;
    stateP1[col.key]=arr[Math.floor(Math.random()*arr.length)];
  });
  render();
});
    speakBtn.addEventListener("click", () => {
  if (!("speechSynthesis" in window)) {
    alert("Browserul nu suportÄƒ audio.");
    return;
  }

  const text = previewKo.textContent;
  if (!text || text.includes("alege cuvinte")) return;

  const u = new SpeechSynthesisUtterance(text);
  u.lang = "ko-KR";

  // alegem PRIMA voce coreeanÄƒ disponibilÄƒ pentru Web Speech
  const voices = window.speechSynthesis.getVoices();
  const koVoices = voices.filter(v =>
    v.lang && v.lang.toLowerCase().startsWith("ko")
  );

  if (koVoices.length > 0) {
    u.voice = koVoices[0];   // din pÄƒcate, asta e vocea â€vecheâ€
  }

  window.speechSynthesis.cancel();
  window.speechSynthesis.speak(u);
});
const favorites=[];
const favoritesListEl=document.getElementById("favoritesList");
function renderFavorites(){
  if(!favoritesListEl)return;
  favoritesListEl.innerHTML="";
  if(!favorites.length){
    const div=document.createElement("div");
    div.className="small-label";
    div.textContent="Nu ai salvat Ã®ncÄƒ nicio propoziÈ›ie.";
    favoritesListEl.appendChild(div);
    return;
  }
  favorites.forEach(f=>{
    const item=document.createElement("div");
    item.className="fav-item";
    const ko=document.createElement("div");
    ko.className="fav-ko";
    ko.textContent=f.ko;
    const ro=document.createElement("div");
    ro.className="fav-ro";
    ro.textContent=f.ro;
    item.appendChild(ko);item.appendChild(ro);
    favoritesListEl.appendChild(item);
  });
}
favBtn.addEventListener("click",()=>{
  const ko=previewKo.textContent.trim();
  let ro=previewRo.textContent.trim();
  if(!ko||ko.includes("alege cuvinte"))return;
  if(ro.startsWith("Â·Â·Â·"))ro="";
  const exists=favorites.some(f=>f.ko===ko&&f.ro===ro);
  if(!exists)favorites.push({ko,ro});
  renderFavorites();
  favBtn.textContent="â­ Salvat!";
  setTimeout(()=>{favBtn.textContent="â­ SalveazÄƒ propoziÈ›ia";},800);
});

/* ================== EXERCIÈšII TOPIK â€“ modul nou ================== */

// Elemente din HTML pentru exerciÈ›ii
const exerciseTypeEl = document.getElementById("exerciseType");
const exerciseQuestionEl = document.getElementById("exerciseQuestion");
const exerciseOptionsEl = document.getElementById("exerciseOptions");
const exerciseFeedbackEl = document.getElementById("exerciseFeedback");
const checkAnswerBtn = document.getElementById("checkAnswerBtn");
const nextQuestionBtn = document.getElementById("nextQuestionBtn");

let currentExercise = null;

// helper random
function randItem(arr){
  return arr[Math.floor(Math.random()*arr.length)];
}

// Construim o propoziÈ›ie coreeanÄƒ simplÄƒ pentru exerciÈ›ii (fÄƒrÄƒ particule complicate)
function buildSimpleKoreanSentence(parts){
  const out = [];
  if(parts.time) out.push(parts.time);
  if(parts.subject) out.push(parts.subject);
  if(parts.place) out.push(parts.place);
  if(parts.mod) out.push(parts.mod);
  if(parts.object) out.push(parts.object);
  if(parts.verb) out.push(parts.verb);
  return out.join(" ");
}

// 1) ExerciÈ›iu: Alege VERBUL corect
function makeVerbExercise(){
  const subj = randItem(subjects);
  const t = randItem(times);
  const place = randItem(places);
  const obj = randItem(objects);
  const correctVerb = randItem(verbs);

  const sentenceKorean = buildSimpleKoreanSentence({
    time: t,
    subject: subj,
    place: place,
    object: obj,
    verb: "___"
  });

  // opÈ›iuni (4 verbe, 1 corect)
  const options = new Set();
  options.add(correctVerb);
  while(options.size < 4){
    options.add(randItem(verbs));
  }
  const optionsArr = Array.from(options).sort(() => Math.random()-0.5);

  currentExercise = {
    type: "verb",
    correct: correctVerb,
    options: optionsArr
  };

  exerciseQuestionEl.textContent = `Alege verbul corect pentru propoziÈ›ia:  ${sentenceKorean}`;
  renderExerciseOptions(optionsArr);
  exerciseFeedbackEl.textContent = "";
}

// 2) ExerciÈ›iu: Alege PARTICULA corectÄƒ â€“ simplificat
// De ex: ì˜¤ëŠ˜ ___ ì¹œêµ¬ë¥¼ ë§Œë‚˜ìš”.
// rÄƒspuns posibil: ì—, ì—ì„œ, ì„/ë¥¼ etc. (facem doar un exerciÈ›iu de recunoaÈ™tere)
const simpleParticles = ["ì€/ëŠ”","ì´/ê°€","ì„/ë¥¼","ì—","ì—ì„œ"];

// âœ… Distrageri (opÈ›iuni greÈ™ite) â€“ folosite ca â€œcapcaneâ€
const particleChoices = ["ì€","ëŠ”","ì´","ê°€","ì„","ë¥¼","ì—","ì—ì„œ"];
function makeParticleExercise(){
  const subj = randItem(subjects);
  const obj  = randItem(objects);
  const verb = randItem(verbs);

  // particula corectÄƒ pentru OBIECT (ì„/ë¥¼)
  const correct = pickObjectParticle(obj); // "ì„" sau "ë¥¼"

  // propoziÈ›ie cu UN SINGUR BLANK
  const sentence = `${subj} ${obj} ___ ${presentPolite(verb)}.`;

  // opÈ›iuni (4), 1 corect + 3 capcane
  const options = new Set([correct]);
  while(options.size < 4){
    options.add(randItem(particleChoices)); // ["ì€","ëŠ”","ì´","ê°€","ì„","ë¥¼","ì—","ì—ì„œ"]
  }
  const optionsArr = Array.from(options).sort(()=>Math.random()-0.5);

  currentExercise = { type:"particle", correct, options: optionsArr };

  exerciseQuestionEl.textContent = `Alege particula corectÄƒ:  ${sentence}`;
  renderExerciseOptions(optionsArr);
  exerciseFeedbackEl.textContent = "";
}
function makeParticlePlusExercise(){
  const t = randItem(times);
  const subj = randItem(subjects);
  const place = randItem(places);
  const obj = randItem(objects);
  const verb = randItem(verbs);

  // particule corecte
  const p1 = pickSubjectParticle(subj);   // (1) subiect
  const p2 = pickTimeParticle(t);         // (2) timp (poate fi "")
  const p3 = pickPlaceParticle(place);    // (3) loc
  const p4 = pickObjectParticle(obj);     // (4) obiect

  // PropoziÈ›ie: TIME(2) SUBJECT(1) PLACE(3) OBJECT(4) + verb politicos simplu
  const verbForm = presentPolite(verb);

  // DacÄƒ timpul nu are particulÄƒ, pÄƒstrÄƒm blank-ul dar acceptÄƒm â€œ(gol)â€ ca rÄƒspuns corect
  const sentence =
    `${t} (2) ${subj} (1) ${place} (3) ${obj} (4) ${verbForm}.`;

  // opÈ›iuni pentru fiecare blank
  function buildOptions(correct){
    const options = new Set();
    // includem corectul (sau "" dacÄƒ e cazul)
    options.add(correct);

    // dacÄƒ e blank de tip â€œpoate fi golâ€, oferim È™i opÈ›iunea "(fÄƒrÄƒ)"
    if(correct === "") options.add("(fÄƒrÄƒ)");

    while(options.size < 4){
      options.add(randItem(particleChoices));
    }
    return Array.from(options).sort(()=>Math.random()-0.5);
  }

  const opts1 = buildOptions(p1);
  const opts2 = buildOptions(p2); // poate conÈ›ine "(fÄƒrÄƒ)"
  const opts3 = buildOptions(p3);
  const opts4 = buildOptions(p4);

  currentExercise = {
    type: "particlePlus",
    correct: { p1, p2, p3, p4 },
    sentence,
    parts: { t, subj, place, obj, verb, verbForm },
    options: { p1: opts1, p2: opts2, p3: opts3, p4: opts4 }
  };

  exerciseQuestionEl.textContent = `CompleteazÄƒ particulele (TOATE trebuie corecte):  ${sentence}`;

  renderParticlePlusOptions(currentExercise.options);
  exerciseFeedbackEl.textContent = "";
}
// 3) ExerciÈ›iu: Alege CONJUGAREA corectÄƒ
function makeConjugExercise(){
  const verb = randItem(verbs);
  const cj = randItem(conjugations);

  const baseSentence = `${verb} (___)`;
  const options = new Set();
  options.add(cj);
  while(options.size < 4){
    options.add(randItem(conjugations));
  }
  const optionsArr = Array.from(options).sort(() => Math.random()-0.5);

  currentExercise = {
    type: "conjug",
    correct: cj,
    verb,
    options: optionsArr
  };

  exerciseQuestionEl.textContent =
    `Alege forma corectÄƒ pentru verbul:  ${verb}  (forma politicosÄƒ / gramaticalÄƒ potrivitÄƒ)`;
  renderExerciseOptions(optionsArr);
  exerciseFeedbackEl.textContent = "";
}

// RENDER opÈ›iuni Ã®n UI
function renderExerciseOptions(optionsArr){
  exerciseOptionsEl.innerHTML = "";
  optionsArr.forEach((opt, idx)=>{
    const id = "opt_"+idx+"_"+Date.now();
    const label = document.createElement("label");
    label.style.display = "flex";
    label.style.alignItems = "center";
    label.style.gap = "6px";
    const radio = document.createElement("input");
    radio.type = "radio";
    radio.name = "exerciseOption";
    radio.value = opt;
    radio.id = id;

    const span = document.createElement("span");
    span.textContent = opt;

    label.appendChild(radio);
    label.appendChild(span);
    exerciseOptionsEl.appendChild(label);
  });
}
function renderParticlePlusOptions(opts){
  exerciseOptionsEl.innerHTML = "";

  const makeBlock = (label, name, arr) => {
    const wrap = document.createElement("div");
    wrap.style.padding = "8px";
    wrap.style.border = "1px solid var(--border)";
    wrap.style.borderRadius = "12px";
    wrap.style.background = "#faf8ff";
    wrap.style.marginBottom = "6px";

    const title = document.createElement("div");
    title.style.fontWeight = "700";
    title.style.fontSize = "12px";
    title.style.color = "var(--accent-strong)";
    title.textContent = label;
    wrap.appendChild(title);

    arr.forEach((opt, idx)=>{
      const id = `${name}_${idx}_${Date.now()}`;
      const lab = document.createElement("label");
      lab.style.display = "flex";
      lab.style.alignItems = "center";
      lab.style.gap = "6px";
      lab.style.fontSize = "13px";
      lab.style.marginTop = "4px";

      const radio = document.createElement("input");
      radio.type = "radio";
      radio.name = name;
      radio.value = opt;
      radio.id = id;

      const span = document.createElement("span");
      span.textContent = opt;

      lab.appendChild(radio);
      lab.appendChild(span);
      wrap.appendChild(lab);
    });

    return wrap;
  };

  exerciseOptionsEl.appendChild(makeBlock("(1) Particula subiectului", "pPlus1", opts.p1));
  exerciseOptionsEl.appendChild(makeBlock("(2) Particula timpului", "pPlus2", opts.p2));
  exerciseOptionsEl.appendChild(makeBlock("(3) Particula locului", "pPlus3", opts.p3));
  exerciseOptionsEl.appendChild(makeBlock("(4) Particula obiectului", "pPlus4", opts.p4));
}
// Generator Ã®ntrebare nouÄƒ
function newExerciseQuestion(){
  const type = exerciseTypeEl ? exerciseTypeEl.value : "verb";

  if(type === "verb"){
    makeVerbExercise();
  } else if(type === "particle"){
    makeParticleExercise();
  } else if(type === "particlePlus"){
    makeParticlePlusExercise();
  } else if(type === "conjug" || type === "conjugation"){
    makeConjugExercise();
  } else {
    makeVerbExercise(); // fallback
  }
}

// Verificare rÄƒspuns
function checkExerciseAnswer(){
  if(!currentExercise){
    exerciseFeedbackEl.textContent = "Mai Ã®ntÃ¢i apasÄƒ â€Ãntrebare nouÄƒâ€.";
    return;
  }
    if(currentExercise.type === "particlePlus"){
    const getVal = (name) => {
      const chosen = Array.from(exerciseOptionsEl.querySelectorAll(`input[name='${name}']`)).find(x=>x.checked);
      return chosen ? chosen.value : null;
    };

    const a1 = getVal("pPlus1");
    const a2 = getVal("pPlus2");
    const a3 = getVal("pPlus3");
    const a4 = getVal("pPlus4");

    if(!a1 || !a2 || !a3 || !a4){
      exerciseFeedbackEl.textContent = "Te rog alege un rÄƒspuns pentru (1)(2)(3)(4).";
      return;
    }

    // â€œ(fÄƒrÄƒ)â€ = gol
    const norm = (v) => (v === "(fÄƒrÄƒ)" ? "" : v);

    const ok1 = norm(a1) === currentExercise.correct.p1;
    const ok2 = norm(a2) === currentExercise.correct.p2;
    const ok3 = norm(a3) === currentExercise.correct.p3;
    const ok4 = norm(a4) === currentExercise.correct.p4;

    if(ok1 && ok2 && ok3 && ok4){
      exerciseFeedbackEl.textContent = "âœ… Corect! Toate particulele sunt bune.";
    } else {
      const c = currentExercise.correct;
      const show = (x)=> x === "" ? "(fÄƒrÄƒ)" : x;
      exerciseFeedbackEl.textContent =
        `âŒ Nu e complet corect.\n` +
        `Corect: (1) ${c.p1} / (2) ${show(c.p2)} / (3) ${c.p3} / (4) ${c.p4}`;
    }
    return;
  }
  const chosen = Array.from(
    exerciseOptionsEl.querySelectorAll("input[name='exerciseOption']")
  ).find(x=>x.checked);

  if(!chosen){
    exerciseFeedbackEl.textContent = "Te rog sÄƒ alegi un rÄƒspuns.";
    return;
  }

  const val = chosen.value;
  const correct = currentExercise.correct;

  if(val === correct){
    exerciseFeedbackEl.textContent = "âœ… Corect! Bravo!";
  }else{
    exerciseFeedbackEl.textContent = `âŒ GreÈ™it. RÄƒspunsul corect era: ${correct}`;
  }
}

// LegÄƒm butoanele
if(nextQuestionBtn){
  nextQuestionBtn.addEventListener("click", newExerciseQuestion);
}
if(checkAnswerBtn){
  checkAnswerBtn.addEventListener("click", checkExerciseAnswer);
}

// La Ã®nceput: mesaj neutru
if(exerciseQuestionEl){
  exerciseQuestionEl.textContent = "ApasÄƒ â€Ãntrebare nouÄƒâ€ ca sÄƒ Ã®ncepi exerciÈ›iile.";
}
    
/* glosar simplu (nu schimb) */
const glossarySearch=document.getElementById("glossarySearch");
const glossaryList=document.getElementById("glossaryList");
function addGlossaryFrom(list,catKey,catLabel){
  const map=translations[catKey]||{};
  list.forEach(w=>{
    if(!w)return;
    const ro=map[w]||"(fÄƒrÄƒ traducere Ã®ncÄƒ)";
    glossaryEntries.push({ko:w,ro,category:catLabel});
  });
}
addGlossaryFrom(subjects,"subject","SUBJECT");
addGlossaryFrom(times,"time","TIME");
addGlossaryFrom(places,"place","PLACE");
addGlossaryFrom(mods,"mod","MOD");
addGlossaryFrom(objects,"object","OBJECT");
addGlossaryFrom(counters,"counter","COUNTER");
addGlossaryFrom(verbs,"verb","VERB");
addGlossaryFrom(conjugations,"conjug","CONJUGÄ‚RI");

function renderGlossary(filter){
  if(!glossaryList)return;
  filter=(filter||"").toLowerCase();
  glossaryList.innerHTML="";
  const filtered=glossaryEntries.filter(e=>{
    if(!filter)return true;
    return e.ko.toLowerCase().includes(filter)||e.ro.toLowerCase().includes(filter);
  });
  if(!filtered.length){
    const div=document.createElement("div");
    div.className="small-label";
    div.textContent="Nu s-a gÄƒsit nimic pentru cÄƒutarea introdusÄƒ.";
    glossaryList.appendChild(div);
    return;
  }
  filtered.forEach(e=>{
    const item=document.createElement("div");
    item.className="glossary-item";
    const left=document.createElement("div");
    const ko=document.createElement("div");
    ko.className="glossary-ko";ko.textContent=e.ko;
    const ro=document.createElement("div");
    ro.className="glossary-ro";ro.textContent=e.ro;
    left.appendChild(ko);left.appendChild(ro);
    const cat=document.createElement("div");
    cat.className="glossary-cat";cat.textContent=e.category;
    item.appendChild(left);item.appendChild(cat);
    glossaryList.appendChild(item);
  });
}
if(glossarySearch)glossarySearch.addEventListener("input",()=>renderGlossary(glossarySearch.value));

/* iniÈ›ializare */
function render(){
  renderClauseRow(tableP1,activeP1,stateP1,"p1");
  if(enableP2.checked)renderClauseRow(tableP2,activeP2,stateP2,"p2");
  pageInfoEl.textContent=`RÃ¢nd model: ${index+1} / ${maxLen}`;
  prevBtn.disabled=index===0;
  nextBtn.disabled=index===maxLen-1;
  updatePreview();
}
 function translateRoToKo(roText){
  LAST_RO_SENTENCE = roText || "";
  const original = (roText || "").trim();
  if(!original){
    return { ko:"", roFixed:"" };
  }

  // 1ï¸âƒ£ ÃncercÄƒm mai Ã®ntÃ¢i cazul FRAZÄ‚ cu "sÄƒ ... (È™i sÄƒ ...)"
  // ex: "Eu plec la piaÈ›Äƒ sÄƒ cumpÄƒr legume È™i sÄƒ coc alune"
  const saMatch = original.match(/\s+s[Äƒa]\s+/i);

  if(saMatch){
    // Partea din faÈ›Äƒ â†’ propoziÈ›ia 1 ("Eu plec la piaÈ›Äƒ")
    const mainPart = original.slice(0, saMatch.index).trim();
    // Tot ce vine dupÄƒ primul "sÄƒ" â†’ propoziÈ›ia de scop ("cumpÄƒr legume È™i sÄƒ coc alune")
    const restPart = original.slice(saMatch.index + saMatch[0].length).trim();

    if(mainPart && restPart){
      // Parsez propoziÈ›ia 1 cu parserul tÄƒu (subiect / timp / loc / verb)
      const mainParsed = parseRoToState(mainPart);
      const s = mainParsed.state || {};

      // Ãmpart dupÄƒ "È™i sÄƒ ..." â†’ maxim 2â€“3 verbe
      const segs = restPart.split(/\s+È™i\s+s[Äƒa]\s+/i);

      const subUnits = segs.map(seg=>{
        const verbKo   = findKoByRo("verb", seg)   || "";
        const objectKo = findKoByRo("object", seg) || "";
        return { verb:verbKo, object:objectKo };
      }).filter(u=>u.verb);   // pÄƒstrÄƒm doar segmentele unde am gÄƒsit verb

      // DacÄƒ avem verb la P1 + cel puÈ›in un verb de scop, construim fraza coreeanÄƒ
      if(s.verb && subUnits.length){
        const parts = [];

        // SUBIECT / TIMP / LOC / MOD â€“ folosesc exact helperii aplicaÈ›iei
        if(s.subject) parts.push(addSubjectWithParticle(s.subject));
        if(s.time)    parts.push(addTimeWithParticle(s.time));
        if(s.place)   parts.push(addPlaceWithParticle(s.place, s.verb));
        if(s.mod)     parts.push(s.mod);

        // Verbul de deplasare + ì„œ  (ex: ê°€ì„œ / ì™€ì„œ)
        // folosesc stemPlusAeo ca sÄƒ iasÄƒ ìì—°ìŠ¤ëŸ½ê²Œ: ê°€ë‹¤â†’ê°€ì„œ, ì˜¤ë‹¤â†’ì™€ì„œ, í•˜ë‹¤â†’í•´ì„œ
        parts.push(stemPlusAeo(s.verb) + "ì„œ");

        // Verbele de scop:
        //  - toate, mai puÈ›in ultimul â†’ "-ê³ "
        //  - ultimul â†’ prezent politicos
        subUnits.forEach((u, idx)=>{
          if(u.object) parts.push(addObjectWithParticle(u.object));
          if(u.verb){
            if(idx < subUnits.length-1){
              // verb intermediar: "-ê³ "
              parts.push(getVerbStem(u.verb) + "ê³ ");
            } else {
              // ultimul verb: prezent politicos
              parts.push(presentPolite(u.verb));
            }
          }
        });

        const koSentence = parts.join(" ");
        const roFixed = original.replace(/\s+/g," ");

        return {
          ko: koSentence,
          roFixed
        };
      }
    }
  }

  // 2ï¸âƒ£ DacÄƒ nu e frazÄƒ cu "sÄƒ..." sau nu reuÈ™im, mergem pe logica veche (propoziÈ›ie simplÄƒ)
  const parsed = parseRoToState(original);

  const koResult = buildClauseSentence(
    parsed.state,
    {
      subject:true,time:true,place:true,mod:true,
      object:true,numeral:false,counter:false,
      verb:true,conjug:true
    },
    null
  ).ko;

  const roFixed = buildNaturalRomanian(
    parsed.state,
    {
      subject:true,time:true,place:true,mod:true,
      object:true,verb:true,conjug:true
    }
  );

  return {
    ko: koResult || "(nu am putut construi propoziÈ›ia)",
    roFixed: roFixed || "(nu am putut corecta romÃ¢na)"
  };
}
    // ================== ğŸ“… 3 CUVINTE/ZI (integrat Ã®n program) ==================
const DAILY_KEY = "raluca_daily_words_v1";
const DAILY_LEARNED_KEY = "raluca_daily_learned_days_v1";

function todayLocalISO(d=new Date()){
  // YYYY-MM-DD Ã®n timezone local (stabil pt user)
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${yyyy}-${mm}-${dd}`;
}

function xmur3(str){
  let h=1779033703 ^ str.length;
  for(let i=0;i<str.length;i++){
    h=Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h=(h<<13)|(h>>>19);
  }
  return function(){
    h=Math.imul(h ^ (h>>>16), 2246822507);
    h=Math.imul(h ^ (h>>>13), 3266489909);
    h^=h>>>16;
    return h>>>0;
  }
}
function mulberry32(a){
  return function(){
    let t=a+=0x6D2B79F5;
    t=Math.imul(t ^ (t>>>15), t | 1);
    t^=t + Math.imul(t ^ (t>>>7), t | 61);
    return ((t ^ (t>>>14))>>>0)/4294967296;
  }
}
function shuffleSeeded(arr, seedStr){
  const seed = xmur3(seedStr)();
  const rand = mulberry32(seed);
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(rand()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
// ===== TOP cuvinte uzuale (poÈ›i extinde oricÃ¢nd) =====
const DAILY_TOP = [
  // SUBJECT (super frecvent)
  {ko:"ì €", cat:"subject"}, {ko:"ë‚˜", cat:"subject"}, {ko:"ë„ˆ", cat:"subject"}, {ko:"ìš°ë¦¬", cat:"subject"},

  // TIME
  {ko:"ì˜¤ëŠ˜", cat:"time"}, {ko:"ì–´ì œ", cat:"time"}, {ko:"ë‚´ì¼", cat:"time"}, {ko:"ì§€ê¸ˆ", cat:"time"},
  {ko:"ìš”ì¦˜", cat:"time"}, {ko:"ë°©ê¸ˆ", cat:"time"}, {ko:"ê³§", cat:"time"},

  // PLACE
  {ko:"ì§‘", cat:"place"}, {ko:"í•™êµ", cat:"place"}, {ko:"íšŒì‚¬", cat:"place"}, {ko:"ì¹´í˜", cat:"place"},
  {ko:"ì‹ë‹¹", cat:"place"}, {ko:"ë³‘ì›", cat:"place"}, {ko:"ë„ì„œê´€", cat:"place"}, {ko:"ì€í–‰", cat:"place"},

  // MOD
  {ko:"ì˜", cat:"mod"}, {ko:"ì²œì²œíˆ", cat:"mod"}, {ko:"ë¹¨ë¦¬", cat:"mod"}, {ko:"ì •ë§", cat:"mod"},
  {ko:"ì•„ì£¼", cat:"mod"}, {ko:"ë„ˆë¬´", cat:"mod"}, {ko:"ë§ì´", cat:"mod"}, {ko:"ì¡°ê¸ˆ", cat:"mod"},

  // OBJECT
  {ko:"ì±…", cat:"object"}, {ko:"ë¬¼", cat:"object"}, {ko:"ì»¤í”¼", cat:"object"}, {ko:"ìŒì‹", cat:"object"},
  {ko:"ê°€ë°©", cat:"object"}, {ko:"ì „í™”", cat:"object"}, {ko:"ëˆ", cat:"object"}, // (dacÄƒ vrei, Ã®l adÄƒugÄƒm È™i Ã®n listÄƒ + traduceri)
  {ko:"ì •ë³´", cat:"object"}, {ko:"ë¬¸ì œ", cat:"object"},

  // VERB (cele mai folosite Ã®n vorbire)
  {ko:"ê°€ë‹¤", cat:"verb"}, {ko:"ì˜¤ë‹¤", cat:"verb"}, {ko:"ë¨¹ë‹¤", cat:"verb"}, {ko:"ë§ˆì‹œë‹¤", cat:"verb"},
  {ko:"ë³´ë‹¤", cat:"verb"}, {ko:"ì½ë‹¤", cat:"verb"}, {ko:"ì“°ë‹¤", cat:"verb"}, {ko:"ì‚¬ë‹¤", cat:"verb"},
  {ko:"ì£¼ë‹¤", cat:"verb"}, {ko:"ë°›ë‹¤", cat:"verb"}, {ko:"ì¼í•˜ë‹¤", cat:"verb"}, {ko:"ê³µë¶€í•˜ë‹¤", cat:"verb"},
  {ko:"ì¢‹ì•„í•˜ë‹¤", cat:"verb"}, {ko:"ì‹«ì–´í•˜ë‹¤", cat:"verb"}, {ko:"ê¸°ë‹¤ë¦¬ë‹¤", cat:"verb"}, {ko:"ì‰¬ë‹¤", cat:"verb"},
  {ko:"ë§Œë‚˜ë‹¤", cat:"verb"}
];
function buildDailyPool(){
  // folosim strict TOP words (cele mai uzuale) + traduceri din dictionarul tÄƒu
  const out = [];

  const pickTranslation = (catKey, ko) => (translations[catKey] && translations[catKey][ko]) ? translations[catKey][ko] : "";

  DAILY_TOP.forEach(x=>{
    const catKey = x.cat;      // subject/time/place/mod/object/verb etc
    const ko = x.ko;

    // dacÄƒ nu existÄƒ Ã®n listele tale, Ã®l putem ignora sau Ã®l adÄƒugÄƒm (eu recomand sÄƒ Ã®l adaugi)
    out.push({
      ko,
      ro: pickTranslation(catKey, ko),
      cat: catKey.toUpperCase()
    });
  });

  // eliminÄƒm duplicate
  const seen = new Set();
  return out.filter(w=>{
    const k = w.ko+"|"+w.cat;
    if(seen.has(k)) return false;
    seen.add(k);
    return true;
  });
}
function getDailyState(){
  const raw = localStorage.getItem(DAILY_KEY);
  if(raw){
    try { return JSON.parse(raw); } catch(e){}
  }
  // generÄƒm o ordine fixÄƒ (shuffle) care rÄƒmÃ¢ne aceeaÈ™i
  const pool = buildDailyPool();
  const order = shuffleSeeded(pool, "RALUCA-DAILY-SEED-v1");
  const state = { order, createdAt: Date.now() };
  localStorage.setItem(DAILY_KEY, JSON.stringify(state));
  return state;
}

function getLearnedDays(){
  try {
    return JSON.parse(localStorage.getItem(DAILY_LEARNED_KEY) || "[]");
  } catch(e){
    return [];
  }
}
function setLearnedDays(arr){
  localStorage.setItem(DAILY_LEARNED_KEY, JSON.stringify(arr));
}

function dayOffset(baseISO, offset){
  const [y,m,d] = baseISO.split("-").map(Number);
  const dt = new Date(y, m-1, d);
  dt.setDate(dt.getDate() + offset);
  return todayLocalISO(dt);
}

let dailyOffset = 0;

function get3WordsForISO(iso){
  const { order } = getDailyState();
  if(!order || !order.length) return [];
  // index = (numÄƒrul zilei Ã®n an) * 3
  const [y,m,d] = iso.split("-").map(Number);
  const dt = new Date(y, m-1, d);
  const start = new Date(y, 0, 1);
  const dayNum = Math.floor((dt - start) / (1000*60*60*24)); // 0..365
  const baseIndex = (dayNum * 3) % order.length;

  return [
    order[baseIndex],
    order[(baseIndex+1) % order.length],
    order[(baseIndex+2) % order.length]
  ];
}

function renderDailyWords(){
  const iso = dayOffset(todayLocalISO(), dailyOffset);

  const dateLabel = document.getElementById("dailyDateLabel");
  const box = document.getElementById("dailyWordsBox");
  const progress = document.getElementById("dailyProgress");
  const markBtn = document.getElementById("dailyMarkBtn");

  if(!dateLabel || !box || !progress || !markBtn) return;

  dateLabel.textContent = dailyOffset===0 ? `Azi (${iso})` : `${dailyOffset<0?"Ieri/Mai devreme":"Mai tÃ¢rziu"} (${iso})`;

  const words = get3WordsForISO(iso);
  box.innerHTML = "";

  words.forEach(w=>{
    const row = document.createElement("div");
    row.style.padding = "8px";
    row.style.border = "1px solid var(--border)";
    row.style.borderRadius = "12px";
    row.style.background = "#faf8ff";
    row.innerHTML = `
      <div style="font-weight:700;font-size:14px;">${w.ko} <span style="font-size:10px;color:var(--accent-strong);">(${w.cat})</span></div>
      <div style="font-size:12px;color:var(--text-soft);">${w.ro || "(fÄƒrÄƒ traducere Ã®ncÄƒ)"}</div>
    `;
    box.appendChild(row);
  });

  const learned = getLearnedDays();
  const isLearned = learned.includes(iso);
  markBtn.textContent = isLearned ? "âœ… Marcat ca Ã®nvÄƒÈ›at" : "âœ… Am Ã®nvÄƒÈ›at azi";
  markBtn.disabled = isLearned;

  progress.textContent = `Zile bifate: ${learned.length}`;
}

function setupDailyUI(){
  const prev = document.getElementById("dailyPrevBtn");
  const next = document.getElementById("dailyNextBtn");
  const mark = document.getElementById("dailyMarkBtn");

  if(prev) prev.addEventListener("click", ()=>{ dailyOffset--; renderDailyWords(); });
  if(next) next.addEventListener("click", ()=>{ dailyOffset++; renderDailyWords(); });

  if(mark) mark.addEventListener("click", ()=>{
    const iso = dayOffset(todayLocalISO(), dailyOffset);
    const learned = getLearnedDays();
    if(!learned.includes(iso)){
      learned.push(iso);
      setLearnedDays(learned);
    }
    renderDailyWords();
  });

  renderDailyWords();
}
    loadRow(index);
setScreen("builder");
render();
setupDailyUI();
</script>
</body>
</html> 
