<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Raluca Korean ‚Äì Builder Multi-Clause Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root{
      --bg1:#dff3ff;
      --bg2:#ffe9ff;
      --bg3:#f4fffc;
      --bg4:#e8f0ff;

      --accent:#7b5dff;
      --card-bg:#ffffffcc;
      --text-main:#2f343b;
      --text-soft:#7a8088;
      --border:#e1d7c7;
    }

    *{box-sizing:border-box;}

    body{
      margin:0;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      color:var(--text-main);
      background:linear-gradient(120deg,var(--bg1),var(--bg2),var(--bg3),var(--bg4));
      background-size:380% 380%;
      animation:bgFlow 28s ease-in-out infinite;
    }
    @keyframes bgFlow{
      0%{background-position:0% 50%;}
      50%{background-position:100% 50%;}
      100%{background-position:0% 50%;}
    }

    .app{
      max-width:1040px;
      margin:0 auto;
      padding:18px 14px 80px;
    }

    .rk-header{
      position:relative;
      padding:12px 16px 16px;
      border-radius:26px;
      background:linear-gradient(120deg,#6fb8ff,#a774ff,#ff7fd1);
      color:#fff;
      box-shadow:0 18px 45px rgba(77,93,255,0.4);
    }
    .rk-header-main{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .rk-header-main h1{
      margin:0;
      font-size:20px;
      font-weight:900;
      letter-spacing:0.06em;
      text-transform:uppercase;
    }
    .rk-badge{
      font-size:11px;
      font-weight:600;
      padding:4px 9px;
      border-radius:999px;
      background:rgba(255,255,255,0.18);
      border:1px solid rgba(255,255,255,0.4);
    }
    #subtitle{
      margin:8px 0 0;
      font-size:12px;
      opacity:0.95;
    }

    .card{
      margin-top:16px;
      padding:16px 18px 18px;
      border-radius:22px;
      background:var(--card-bg);
      backdrop-filter:blur(16px);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 18px 40px rgba(0,0,0,0.12);
    }
    .card h2{
      margin:0 0 8px;
      font-size:16px;
      font-weight:800;
      letter-spacing:0.03em;
    }

    textarea{
      width:100%;
      border-radius:16px;
      border:1px solid var(--border);
      padding:10px 12px;
      font-size:14px;
      resize:vertical;
      min-height:70px;
      color:var(--text-main);
      background:#fff;
    }
    textarea:focus{
      outline:none;
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.9),
        0 0 0 3px rgba(149,120,255,0.5);
      border-color:rgba(149,120,255,0.7);
    }

    .btn-row{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    button{
      border:none;
      border-radius:999px;
      padding:8px 16px;
      font-size:12px;
      font-weight:800;
      cursor:pointer;
      color:#fff;
      background:linear-gradient(135deg,#6b8cff,#9b6bff);
      box-shadow:
        0 10px 24px rgba(108,110,210,0.4),
        0 0 0 1px rgba(255,255,255,0.7) inset;
      transition:transform .12s ease, box-shadow .12s ease, filter .12s ease;
    }
    button.secondary{
      background:linear-gradient(135deg,#ff9a6c,#ff5f8c);
    }
    button:hover{
      transform:translateY(-1px);
      box-shadow:0 12px 26px rgba(0,0,0,0.18);
      filter:brightness(1.03);
    }
    button:active{
      transform:translateY(1px) scale(0.98);
      box-shadow:0 6px 16px rgba(0,0,0,0.25);
      filter:brightness(0.97);
    }

    .section-title{
      margin-top:18px;
      margin-bottom:6px;
      font-size:13px;
      font-weight:800;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:#4b607d;
    }

    .table-block{
      margin-top:10px;
      padding:10px 10px 12px;
      border-radius:20px;
      background:var(--card-bg);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 14px 30px rgba(0,0,0,0.1);
    }
    .table-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:12px;
      font-weight:800;
      color:var(--text-soft);
      margin-bottom:6px;
    }
    .table-horizontal{
      display:flex;
      gap:8px;
      overflow-x:auto;
      padding-bottom:4px;
    }

    .col{
      min-width:110px;
      max-width:150px;
      flex:0 0 auto;
      border-radius:16px;
      padding:7px 7px 9px;
      background:radial-gradient(circle at top left,#fdfbf7,#f2ebde);
      border:1px solid #e2d7c8;
      box-shadow:0 10px 22px rgba(95,78,58,0.16);
    }
    .col-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:4px;
      font-size:10px;
      font-weight:900;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:#7b5dff;
      border-bottom:1px solid rgba(208,196,255,0.8);
      padding-bottom:2px;
      margin-bottom:3px;
    }
    .col-header::before{
      content:"";
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:16px;
      height:16px;
      border-radius:6px;
      background:#fff;
      font-size:11px;
      box-shadow:0 1px 3px rgba(0,0,0,0.06);
    }
    .col[data-key="subject"] .col-header::before{content:"üë§";}
    .col[data-key="time"]    .col-header::before{content:"‚è∞";}
    .col[data-key="place"]   .col-header::before{content:"üìç";}
    .col[data-key="mod"]     .col-header::before{content:"‚ú®";}
    .col[data-key="object"]  .col-header::before{content:"üéØ";}
    .col[data-key="numeral"] .col-header::before{content:"#Ô∏è‚É£";}
    .col[data-key="counter"] .col-header::before{content:"üî¢";}
    .col[data-key="verb"]    .col-header::before{content:"üöÄ";}
    .col[data-key="conj"]    .col-header::before{content:"üîó";}

    .col-body-label{
      font-size:10px;
      color:#938777;
      margin-bottom:1px;
    }
    .col-body-main{
      font-size:15px;
      font-weight:900;
      min-height:1.4em;
    }
    .col-body-main[contenteditable="true"]{
      outline:none;
      cursor:text;
    }
    .col-body-main:focus{
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.8),
        0 0 0 2px rgba(149,120,255,0.7);
      border-radius:6px;
    }

    .col-body-extra.example{
      margin-top:2px;
      font-size:10px;
      color:#b09b83;
    }
<label style="display:flex;gap:8px;align-items:center;font-size:12px;color:#4b607d;">
  <input type="checkbox" id="politeToggle" />
  Preview politicos (ultima clauzƒÉ √Æn -ÏïÑÏöî/Ïñ¥Ïöî)
</label>
    .preview-card{
      margin-top:14px;
      padding:12px 14px;
      border-radius:20px;
      background:var(--card-bg);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 16px 32px rgba(0,0,0,0.12);
    }
    .preview-title{
      font-size:12px;
      font-weight:900;
      color:#4b607d;
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:6px;
    }
    .preview-sentence{
      font-size:22px;
      font-weight:900;
      line-height:1.6;
      margin-bottom:4px;
      word-break:keep-all;
    }
    .preview-ro{
      font-size:12px;
      color:var(--text-soft);
    }

    .hint{
      margin-top:6px;
      font-size:11px;
      color:var(--text-soft);
      line-height:1.4;
    }
    code.k{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      background: rgba(255,255,255,0.7);
      border: 1px solid rgba(0,0,0,0.06);
      padding: 1px 6px;
      border-radius: 999px;
    }

    @media (max-width:600px){
      .rk-header-main h1{font-size:17px;}
      .col{min-width:95px;}
    }
  </style>
</head>

<body>
  <div class="app">
    <header class="rk-header">
      <div class="rk-header-main">
        <h1>RALUCA KOREAN</h1>
        <span class="rk-badge">Builder ‚Äì Multi Clause</span>
      </div>
      <p id="subtitle">
        Split pe conectori multipli + P2/P3/P4‚Ä¶ + endings lipite de verb (infinitiv √Æn tabel).
      </p>
    </header>

    <!-- Input -->
    <section class="card" id="roCard">
      <h2>Rom√¢nƒÉ / English ‚Üí CoreeanƒÉ (auto-fill)</h2>
      <div style="margin-bottom:6px;font-size:11px;color:var(--text-soft);display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
        <span>Limba propozi»õiei:</span>
        <select id="langSelect" style="padding:2px 8px;border-radius:999px;border:1px solid var(--border);font-size:11px;">
          <option value="ro" selected>Rom√¢nƒÉ</option>
          <option value="en">English</option>
        </select>
      </div>

      <textarea id="inputText" placeholder="Ex: AstƒÉzi merg la cafenea »ôi citesc o carte »ôi beau o cafea.
Today I go to the cafe and read a book and drink a coffee."></textarea>

      <div class="btn-row">
        <button id="autoFillBtn">CompleteazƒÉ automat builder-ul</button>
        <button id="clearBtn" class="secondary">CurƒÉ»õƒÉ tot</button>
      </div>

      <div class="hint">
        Reguli de bazƒÉ:
        <br>‚Ä¢ <b>»ôi / and</b> ‚Üí <code class="k">-Í≥†</code> (lipit de verbul dinainte).
        <br>‚Ä¢ <b>dar / but</b> ‚Üí <code class="k">-ÏßÄÎßå</code>
        <br>‚Ä¢ <b>pentru cƒÉ / because</b> ‚Üí <code class="k">-Ïñ¥ÏÑú</code> (po»õi schimba manual la <code class="k">-ÏïÑÏÑú</code>)
        <br>‚Ä¢ <b>dacƒÉ / if</b> ‚Üí <code class="k">-(Ïúº)Î©¥</code>
        <br>‚Ä¢ <b>c√¢nd / atunci c√¢nd / when</b> ‚Üí <code class="k">-(Ïúº)„Ñπ Îïå</code>
        <br>‚Ä¢ <b>ca sƒÉ / in order to / to</b> ‚Üí <code class="k">-(Ïúº)Î†§Í≥†</code>
      </div>
    </section>

    <h3 class="section-title">Builder (clauze)</h3>
    <div id="clausesHost"></div>

    <!-- Preview -->
    <section class="preview-card">
      <div class="preview-title">
        <span>Propozi»õia finalƒÉ √Æn coreeanƒÉ</span>
      </div>
      <div id="previewSentence" class="preview-sentence">Ï†Ä Í∞ÄÏöî</div>
      <div id="previewInfo" class="preview-ro"></div>
    </section>
  </div>

  <script>
  (function () {

    // =========================
    // A) Normalizare text
    // =========================
    function normalizeText(text) {
      if (!text) return "";
      let t = text.toLowerCase();
      t = t.replace(/≈ü/g, "»ô").replace(/≈£/g, "»õ");
      t = t.replace(/[.,!?;:]/g, " ");
      t = t.replace(/\s+/g, " ").trim();
      return t;
    }

    // =========================
    // B) Conectori RO/EN -> KO
    // (IMPORTANT: aici avem ending-uri vs conectori separa»õi)
    // =========================
    const CONNECTOR_MAP = [
      // RO (mai lungi primele)
      { keys: ["atunci c√¢nd", "cand", "c√¢nd"], type: "ending", ko: "-(Ïúº)„Ñπ Îïå" },
      { keys: ["de»ôi", "desi", "although", "even though"], type: "ending", ko: "-ÏßÄÎßå" }, // simplificat
      { keys: ["pentru cƒÉ", "pentru ca", "fiindcƒÉ", "fiindca", "because"], type: "ending", ko: "-Ïñ¥ÏÑú" },
      { keys: ["ca sƒÉ", "ca sa", "pentru a", "in order to", "to"], type: "ending", ko: "-(Ïúº)Î†§Í≥†" },
      { keys: ["dacƒÉ", "daca", "if"], type: "ending", ko: "-(Ïúº)Î©¥" },
      { keys: ["dar", "but"], type: "ending", ko: "-ÏßÄÎßå" },
      { keys: ["»ôi", "si", "and"], type: "ending", ko: "-Í≥†" },

      // conectori separa»õi (dacƒÉ user vrea sƒÉ-i scrie manual √Æn celulƒÉ)
      // (nu √Æi punem automat din text, ca sƒÉ nu stricƒÉm sensul)
    ];

    function findConnectorToken(textNorm) {
      // returneazƒÉ match-ul cel mai lung posibil
      for (const item of CONNECTOR_MAP) {
        for (const k of item.keys) {
          // conector ca "word boundary" aproximativ
          // ex: " »ôi " / " and "
          const re = new RegExp("(^|\\s)" + escapeRegExp(k) + "(\\s|$)", "i");
          const m = textNorm.match(re);
          if (m) return { token: k, ...item };
        }
      }
      return null;
    }

    function escapeRegExp(s) {
      return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    // Split pe MULTIPLE conectori: produce array de clauze + conectori √Æntre ele
    function splitIntoChain(raw, lang) {
      const original = (raw || "").replace(/\s+/g, " ").trim();
      const t = normalizeText(original);
      if (!t) return { clauses: [], links: [] };

      // Construim o regex care prinde ORICE conector relevant.
      // Important: ordonƒÉm cheile descrescƒÉtor ca lungime, ca sƒÉ prindƒÉ "atunci c√¢nd" √Ænainte de "c√¢nd".
      const allKeys = CONNECTOR_MAP.flatMap(x => x.keys);
      const uniq = Array.from(new Set(allKeys));
      uniq.sort((a,b) => b.length - a.length);

      const alternation = uniq.map(escapeRegExp).join("|");
      const re = new RegExp("\\s(" + alternation + ")\\s", "ig");

      // Split pƒÉstr√¢nd delimiter-ul
      const parts = [];
      let lastIndex = 0;
      let m;
      while ((m = re.exec(t)) !== null) {
        const before = t.slice(lastIndex, m.index).trim();
        const token  = (m[1] || "").trim();
        if (before) parts.push({ kind: "clause", text: before });
        parts.push({ kind: "conn", text: token });
        lastIndex = m.index + m[0].length;
      }
      const tail = t.slice(lastIndex).trim();
      if (tail) parts.push({ kind: "clause", text: tail });

      // Acum transformƒÉm √Æn chain: clauses[] »ôi links[] (link[i] este conector √Æntre clause[i] »ôi clause[i+1])
      const clauses = [];
      const links = [];
      for (let i=0; i<parts.length; i++) {
        if (parts[i].kind === "clause") clauses.push(parts[i].text);
        if (parts[i].kind === "conn")   links.push(parts[i].text);
      }

      // DacƒÉ avem conectori dar clauze lipsƒÉ (edge case), curƒÉ»õƒÉm
      while (links.length >= clauses.length) links.pop();

      // MapƒÉm fiecare link la KO recomandat
      const linkObjs = links.map(tok => {
        const mapped = CONNECTOR_MAP.find(x => x.keys.includes(tok));
        if (!mapped) return { raw: tok, type: "ending", ko: "-Í≥†" };
        return { raw: tok, type: mapped.type, ko: mapped.ko };
      });

      return { clauses, links: linkObjs };
    }

    // =========================
    // C) Reguli minime RO/EN -> sloturi
    // (extensibile)
    // =========================
    const RO_RULES = {
  subject: [
    { re: /\beu\s*\(formal\)|eu\s*-\s*formal\b/i, value: "Ï†Ä" },
    { re: /\beu\s*\(informal\)|eu\s*-\s*informal\b/i, value: "ÎÇò" },
    { re: /\beu\b/i, value: "Ï†Ä" },
    { re: /\btu\b/i, value: "ÎÑà" },
    { re: /\bel\b|\bea\b/i, value: "Í∑∏/Í∑∏ÎÖÄ" }, // simplificat
    { re: /\bnoi\b/i, value: "Ïö∞Î¶¨" },
  ],

  time: [
    { re: reWords(["azi","astƒÉzi"]), value: "Ïò§Îäò" },
    { re: reWords(["m√¢ine"]), value: "ÎÇ¥Ïùº" },
    { re: reWords(["ieri"]), value: "Ïñ¥Ï†ú" },
    { re: reWords(["acum"]), value: "ÏßÄÍ∏à" },
    { re: reWords(["diminea»õa","dimineata"]), value: "ÏïÑÏπ®Ïóê" },
    { re: reWords(["seara"]), value: "Ï†ÄÎÖÅÏóê" },
    { re: reWords(["noaptea"]), value: "Î∞§Ïóê" },
  ],

  place: [
    { re: reWords(["acasƒÉ","acasa"]), value: "Ïßë" },
    { re: reWords(["pia»õƒÉ","piata","market"]), value: "ÏãúÏû•" },
    { re: reWords(["cafenea","cafea"]), value: "Ïπ¥Ìéò" },
    { re: reWords(["magazin","supermarket","shop"]), value: "Í∞ÄÍ≤å" },
    { re: /la\s+»ôcoal[ƒÉa]|la\s+scoala|»ôcoal[ƒÉa]\b|scoala\b/i, value: "ÌïôÍµê" },
    { re: /la\s+serviciu|la\s+firm[ƒÉa]|birou|companie/i, value: "ÌöåÏÇ¨" },
    { re: reWords(["spital"]), value: "Î≥ëÏõê" },
    { re: reWords(["parc"]), value: "Í≥µÏõê" },
    { re: reWords(["restaurant"]), value: "ÏãùÎãπ" },
  ],

  mod: [
    { re: reWords(["bine","frumos","ok"]), value: "Ïûò" },
    { re: /√Æn\s+lini»ôte|in\s+liniste|lini»ôte|liniste/i, value: "Ï°∞Ïö©Ìûà" },
    { re: /cu\s+s√¢rguin»õƒÉ|cu\s+sarguinta|harnic|cu\s+mult\s+efort/i, value: "Ïó¥Ïã¨Ìûà" },
    { re: reWords(["√Æncet","incet"]), value: "Ï≤úÏ≤úÌûà" },
    { re: reWords(["repede","rapid"]), value: "Îπ®Î¶¨" },
  ],

  object: [
    { re: reWords(["cafea"]), value: "Ïª§Ìîº" },
    { re: reWords(["apƒÉ","apa","apƒÉ mineralƒÉ","apa minerala"]), value: "Î¨º" },
    { re: reWords(["ceai"]), value: "Ï∞®" },
    { re: reWords(["carte","cƒÉr»õi","carti"]), value: "Ï±Ö" },
    { re: reWords(["m√¢ncare","mancare","pr√¢nz","pranz","cinƒÉ","cina","mic dejun"]), value: "ÏùåÏãù" },
    { re: reWords(["telefon"]), value: "Ìï∏ÎìúÌè∞" },
    { re: reWords(["film"]), value: "ÏòÅÌôî" },
    { re: reWords(["muzicƒÉ","muzica"]), value: "ÏùåÏïÖ" },
  ],

  numeral: [
    { re: /\bo\s+(carte|cafea|ap[ƒÉa]|ceai)\b/i, value: "Ìïú" },
    { re: /\bdou[ƒÉa]\s+(car»õi|carti|cafele)\b/i, value: "Îëê" },
    { re: /\btrei\s+(car»õi|carti|cafele)\b/i, value: "ÏÑ∏" },
  ],

  counter: [
    { re: reWords(["carte","cƒÉr»õi","carti"]), value: "Í∂å" },
    { re: reWords(["cafea","apƒÉ","apa","ceai","m√¢ncare","mancare","telefon","film"]), value: "Í∞ú" },
  ],

  verb: [
    { re: /merg\b|a\s+merge|sƒÉ\s+merg|sa\s+merg/i, value: "Í∞ÄÎã§" },
    { re: /vin\b|a\s+veni|sƒÉ\s+vin|sa\s+vin/i, value: "Ïò§Îã§" },
    { re: /beau\b|a\s+bea|sƒÉ\s+beau|sa\s+beau/i, value: "ÎßàÏãúÎã§" },
    { re: /m[√¢ƒÉ]n[√¢a]nc\b|mananc|a\s+m[√¢ƒÉ]nca/i, value: "Î®πÎã§" },
    { re: /citesc|a\s+citi|sƒÉ\s+citesc|sa\s+citesc/i, value: "ÏùΩÎã§" },
    { re: /lucrez|a\s+lucra/i, value: "ÏùºÌïòÎã§" },

    // EXTINS:
    { re: /studiez|√ÆnvƒÉ»õ|invat|a\s+√ÆnvƒÉ»õa|a\s+invata/i, value: "Í≥µÎ∂ÄÌïòÎã§" },
    { re: /vƒÉd|vad|mƒÉ\s+uit|ma\s+uit|privesc|a\s+vedea/i, value: "Î≥¥Îã§" },
    { re: /scriu|a\s+scrie/i, value: "Ïì∞Îã§" },
    { re: /cumpƒÉr|cumpar|a\s+cumpƒÉra|a\s+cumpara/i, value: "ÏÇ¨Îã§" },
    { re: /fac|a\s+face/i, value: "ÌïòÎã§" },
    { re: /dorm|a\s+dormi/i, value: "ÏûêÎã§" },
    { re: /vorbesc|a\s+vorbi/i, value: "ÎßêÌïòÎã§" },
  ],
};

    const EN_RULES = {
      subject: [
        { re: /\bi\b/, value: "Ï†Ä" },
        { re: /\byou\b/, value: "ÎÑà" },
        { re: /\bwe\b/, value: "Ïö∞Î¶¨" },
      ],
      time: [
        { re: /\btoday\b/, value: "Ïò§Îäò" },
        { re: /\btomorrow\b/, value: "ÎÇ¥Ïùº" },
        { re: /\byesterday\b/, value: "Ïñ¥Ï†ú" },
        { re: /\bnow\b/, value: "ÏßÄÍ∏à" },
      ],
      place: [
        { re: /\bhome\b|house\b/, value: "Ïßë" },
        { re: /\bmarket\b|mart\b|grocery\b/, value: "ÏãúÏû•" },
        { re: /\bschool\b/, value: "ÌïôÍµê" },
        { re: /\bwork\b|company\b|office\b/, value: "ÌöåÏÇ¨" },
        { re: /\bcafe\b|coffee\s+shop\b/, value: "Ïπ¥Ìéò" },
      ],
      mod: [
        { re: /\bwell\b|okay\b/, value: "Ïûò" },
        { re: /\bslowly\b/, value: "Ï≤úÏ≤úÌûà" },
        { re: /\bfast\b|quickly\b/, value: "Îπ®Î¶¨" },
        { re: /\ba lot\b|\bmuch\b/, value: "ÎßéÏù¥" },
      ],
      object: [
        { re: /\bcoffee\b/, value: "Ïª§Ìîº" },
        { re: /\bwater\b/, value: "Î¨º" },
        { re: /\bbook\b|books\b/, value: "Ï±Ö" },
        { re: /\bfood\b|meal\b|lunch\b|dinner\b|breakfast\b/, value: "ÏùåÏãù" },
        { re: /\btea\b/, value: "Ï∞®" },
      ],
      numeral: [
        { re: /\ba\s+(book|coffee)\b|\bone\s+/, value: "Ìïú" },
        { re: /\btwo\s+/, value: "Îëê" },
        { re: /\bthree\s+/, value: "ÏÑ∏" },
      ],
      counter: [
        { re: /\bbook\b|books\b/, value: "Í∂å" },
        { re: /\bcoffee\b|water\b|tea\b|food\b|meal\b/, value: "Í∞ú" },
      ],
      verb: [
        { re: /\bgo\b|\bgoing\b/, value: "Í∞ÄÎã§" },
        { re: /\bcome\b|\bcoming\b/, value: "Ïò§Îã§" },
        { re: /\bdrink\b|\bdrinking\b/, value: "ÎßàÏãúÎã§" },
        { re: /\beat\b|\beating\b/, value: "Î®πÎã§" },
        { re: /\bread\b|\breading\b/, value: "ÏùΩÎã§" },
        { re: /\bwork\b|\bworking\b/, value: "ÏùºÌïòÎã§" },
      ],
    };

    function matchSlot(rules, textNorm) {
      if (!rules) return "";
      for (const rule of rules) {
        if (rule.re.test(textNorm)) return rule.value;
      }
      return "";
    }

    function parseToSlots(text, lang) {
      const t = normalizeText(text);
      const RULES = (lang === "en") ? EN_RULES : RO_RULES;
      if (!t) return {};

      return {
        subject: matchSlot(RULES.subject, t),
        time:    matchSlot(RULES.time, t),
        place:   matchSlot(RULES.place, t),
        mod:     matchSlot(RULES.mod, t),
        object:  matchSlot(RULES.object, t),
        numeral: matchSlot(RULES.numeral, t),
        counter: matchSlot(RULES.counter, t),
        verb:    matchSlot(RULES.verb, t),
      };
    }
function detectTableIds() {
  // cauta toate elementele cu id care incep cu "tableP" si le sorteaza numeric
  const els = Array.from(document.querySelectorAll('[id^="tableP"]'));
  const ids = els
    .map(e => e.id)
    .filter(id => /^tableP\d+$/.test(id))
    .sort((a,b) => parseInt(a.replace("tableP",""),10) - parseInt(b.replace("tableP",""),10));
  return ids.length ? ids : ["tableP1","tableP2"]; // fallback
}

let TABLE_IDS = []; // global
window.addEventListener("DOMContentLoaded", () => {
  TABLE_IDS = detectTableIds();
  // optional: console.log(TABLE_IDS);
});
    // =========================
    // D) UI: generare clauze dinamice
    // =========================
    const host = document.getElementById("clausesHost");

    function clauseBlockHTML(idx) {
      const label = (idx === 0) ? "Propozi»õia 1" : ("Propozi»õia " + (idx + 1));
      const id = "tableP" + (idx + 1);

      return `
        <section class="table-block" data-clause-index="${idx}">
          <div class="table-title">
            <span>${label}</span>
            <span style="font-size:11px;color:var(--text-soft);">VERB √Æn infinitiv ‚Ä¢ CONJ = ending sau conector</span>
          </div>

          <div id="${id}" class="table-horizontal">
            ${colHTML("subject","SUBJECT","eu/tu/noi‚Ä¶", true)}
            ${colHTML("time","TIME","azi/today‚Ä¶", true)}
            ${colHTML("place","PLACE","cafenea/cafe‚Ä¶", true)}
            ${colHTML("mod","MOD","bine/slowly‚Ä¶", true)}
            ${colHTML("object","OBJECT","cafea/coffee‚Ä¶", true)}
            ${colHTML("numeral","NUMERAL","una/two‚Ä¶", true)}
            ${colHTML("counter","COUNTER","Í∞ú/Í∂å‚Ä¶", true)}
            ${colHTML("verb","VERB","Í∞ÄÎã§, ÏùΩÎã§‚Ä¶", true)}
            ${colHTML("conj","CONJ / ENDING","-Í≥†, -ÏßÄÎßå, -Ïñ¥ÏÑú, Í∑∏Î¶¨Í≥†‚Ä¶", true, "ex: -Í≥†, -ÏßÄÎßå, -Ïñ¥ÏÑú, -(Ïúº)Î©¥, -(Ïúº)„Ñπ Îïå, -(Ïúº)Î†§Í≥†, Í∑∏Î¶¨Í≥†")}
          </div>
        </section>
      `;
    }

    function colHTML(key, title, hint, editable, example) {
      return `
        <div class="col" data-key="${key}">
          <div class="col-header">${title}</div>
          <div class="col-body-label">${hint}</div>
          <div class="col-body-main" ${editable ? 'contenteditable="true"' : ""}></div>
          ${example ? `<div class="col-body-extra example">${example}</div>` : ""}
        </div>
      `;
    }

    function ensureClauseCount(n) {
      const current = host.querySelectorAll("[data-clause-index]").length;
      if (current === n) return;

      // dacƒÉ trebuie mai multe: adƒÉugƒÉm
      if (current < n) {
        for (let i=current; i<n; i++) {
          host.insertAdjacentHTML("beforeend", clauseBlockHTML(i));
        }
      } else {
        // dacƒÉ trebuie mai pu»õine: »ôtergem surplus
        for (let i=current-1; i>=n; i--) {
          const el = host.querySelector('[data-clause-index="' + i + '"]');
          if (el) el.remove();
        }
      }
    }

    // =========================
    // E) Citire / scriere celule
    // =========================
    function applySlotsToClause(idx, slots) {
      const tableId = "tableP" + (idx + 1);
      const table = document.getElementById(tableId);
      if (!table || !slots) return;

      const keys = ["subject","time","place","mod","object","numeral","counter","verb"];
      for (const k of keys) {
        if (!slots[k]) continue;
        const cell = table.querySelector('.col[data-key="' + k + '"] .col-body-main');
        if (cell) cell.textContent = slots[k];
      }
    }

    function setConjForClause(idx, conjValue) {
      const tableId = "tableP" + (idx + 1);
      const table = document.getElementById(tableId);
      if (!table) return;
      const cell = table.querySelector('.col[data-key="conj"] .col-body-main');
      if (cell) cell.textContent = conjValue || "";
    }

    function readCell(tableId, key) {
      const cell = document.querySelector("#" + tableId + ' .col[data-key="' + key + '"] .col-body-main');
      return cell ? cell.textContent.trim() : "";
    }

    // =========================
    // F) Logic: lipire ending la verb
    // =========================
    function normalizeEnding(x) {
      let t = (x || "").trim();
      // acceptƒÉm "-Í≥†", "~Í≥†", "Í≥†" etc.
      t = t.replace(/^[-~]/, "").trim();
      return t;
    }

    function isStandaloneConnector(x) {
      const t = (x || "").trim();
      // aici sunt cuvinte care rƒÉm√¢n SEPARATE (nu se lipesc de verb)
      return ["Í∑∏Î¶¨Í≥†","Í∑∏ÎûòÏÑú","ÌïòÏßÄÎßå","Îòê","ÎòêÎäî","Í∑∏ÎûòÎèÑ","Í∑∏Îü¨Î©¥"].includes(t);
    }

    function attachEndingToVerb(verbInf, endingRaw) {
      const v = (verbInf || "").trim();
      if (!v) return "";
      const e = normalizeEnding(endingRaw);
      if (!e) return v;

      // conector separat => NU lipim
      if (isStandaloneConnector(e)) return v;

      // endings tipice pe care le lipim
      // - Í≥† / -ÏßÄÎßå / -ÏïÑÏÑú / -Ïñ¥ÏÑú / -(Ïúº)Î©¥ / -(Ïúº)„Ñπ Îïå / -(Ïúº)Î†§Í≥†
      // IMPORTANT: verbul trebuie sƒÉ fie infinitiv cu Îã§ ca sƒÉ lipim corect
      if (!v.endsWith("Îã§")) return v;

      // stem fƒÉrƒÉ "Îã§"
      const stem = v.slice(0, -1);

      // mici excep»õii utile
      if (v === "ÌïòÎã§" && (e === "ÏïÑÏÑú" || e === "Ïñ¥ÏÑú")) return "Ìï¥ÏÑú";
      if (v === "ÌïòÎã§" && e === "Í≥†") return "ÌïòÍ≥†";
      if (v === "ÌïòÎã§" && e === "(Ïúº)Î©¥") return "ÌïòÎ©¥";
      if (v === "ÌïòÎã§" && e === "(Ïúº)Î†§Í≥†") return "ÌïòÎ†§Í≥†";
      if (v === "ÌïòÎã§" && e === "(Ïúº)„Ñπ Îïå") return "Ìï† Îïå";

      // endings cu paranteze: -(Ïúº)Î©¥, -(Ïúº)„Ñπ Îïå, -(Ïúº)Î†§Í≥†
      if (e === "(Ïúº)Î©¥") return stem + "Î©¥";
      if (e === "(Ïúº)„Ñπ Îïå") return stem + "„Ñπ Îïå";
      if (e === "(Ïúº)Î†§Í≥†") return stem + "Î†§Í≥†";

      // ending simplu
      return stem + e;
    }

    // construie»ôte o clauzƒÉ KO dintr-un tabel
    function buildClauseFromTable(idx) {
      const tableId = "tableP" + (idx + 1);

      const subject = readCell(tableId, "subject");
      const time    = readCell(tableId, "time");
      const place   = readCell(tableId, "place");
      const mod     = readCell(tableId, "mod");
      const object  = readCell(tableId, "object");
      const numeral = readCell(tableId, "numeral");
      const counter = readCell(tableId, "counter");
      const verbInf = readCell(tableId, "verb");
      const conjRaw = readCell(tableId, "conj");

      let obj = "";
      if (object && numeral && counter) obj = object + " " + numeral + " " + counter;
      else if (object) obj = object;

      const verbOut = attachEndingToVerb(verbInf, conjRaw);

      // dacƒÉ conj este conector separat (Í∑∏Î¶¨Í≥† etc.) √Æl returnƒÉm separat ca "mid"
      const conjNorm = normalizeEnding(conjRaw);
      const mid = isStandaloneConnector(conjNorm) ? conjNorm : "";

      const pieces = [subject, time, place, mod, obj, verbOut].filter(Boolean);
      const clause = pieces.join(" ").trim();

      return { clause, mid, hasAny: clause.length > 0 || mid.length > 0 };
    }

    function rebuildPreview() {
      const blocks = host.querySelectorAll("[data-clause-index]");
      const n = blocks.length;

      const chunks = [];
      for (let i=0; i<n; i++) {
        const c = buildClauseFromTable(i);
        if (!c.hasAny) continue;

        chunks.push(c.clause);

        // mid √Æntre i »ôi i+1 (doar dacƒÉ e conector separat)
        if (c.mid && i < n-1) chunks.push(c.mid);
      }

      const out = document.getElementById("previewSentence");
      const info = document.getElementById("previewInfo");

      const sentence = (chunks.join(" ").replace(/\s+/g," ").trim()) || "Ï†Ä Í∞ÄÏöî";
      out.textContent = sentence;

      info.textContent =
        "NotƒÉ: Ending-urile (ex: -Í≥†, -ÏßÄÎßå, -Ïñ¥ÏÑú, -(Ïúº)Î©¥, -(Ïúº)„Ñπ Îïå, -(Ïúº)Î†§Í≥†) se lipesc de verb doar dacƒÉ verbul este infinitiv (‚Ä¶Îã§). " +
        "Conectorii separa»õi (ex: Í∑∏Î¶¨Í≥†/Í∑∏ÎûòÏÑú/ÌïòÏßÄÎßå) rƒÉm√¢n ca »ôi cuvinte √Æntre clauze.";
    }

    // =========================
    // G) Auto-fill din input (RO/EN) + multi split
    // =========================
    function autoFillFromInput() {
      const input = document.getElementById("inputText");
      const lang = (document.getElementById("langSelect") || {}).value || "ro";
      const raw = (input && input.value) ? input.value : "";
      const chain = splitIntoChain(raw, lang); // {clauses[], links[]}
      const clauses = chain.clauses;
      const links = chain.links; // link[i] √Æntre clauses[i] »ôi clauses[i+1]

      if (!clauses.length) {
        ensureClauseCount(1);
        rebuildPreview();
        return;
      }

      // avem N clauze -> N blocuri
      ensureClauseCount(clauses.length);

      // umple sloturi
      for (let i=0; i<clauses.length; i++) {
        const slots = parseToSlots(clauses[i], lang);
        applySlotsToClause(i, slots);
      }

      // conectorii se pun √Æn celula CONJ a clauzei anterioare (i)
      // ex: "merg »ôi citesc" -> la P1.conj = "-Í≥†"
      for (let i=0; i<links.length; i++) {
        const l = links[i]; // {raw, type, ko}
        setConjForClause(i, l.ko); // ending recomandat
      }

      // ultima clauzƒÉ: dacƒÉ are conj vechi dinainte, √Æl lƒÉsƒÉm cum e; dar pentru auto-fill √Æl golim ca sƒÉ nu fie confuz
      setConjForClause(clauses.length - 1, "");

      rebuildPreview();
    }
    function reWords(arr) {
  // face un regex cu word boundaries, safe pt. spatii
  const escaped = arr.map(x => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
  return new RegExp(`\\b(${escaped.join("|")})\\b`, "i");
}
    // ================================
// CONFIG: ai pana la 4 clauze
// ================================
const TABLE_IDS = ["tableP1", "tableP2", "tableP3", "tableP4"];

// ce consideram conectori in input (RO + EN)
// (ordinea conteaza: expresiile mai lungi primele)
const CONNECTORS = [
  { re: /\b(atunci\s+c√¢nd|atunci\s+cand)\b/gi, type: "when" },
  { re: /\b(pentru\s+cƒÉ|pentru\s+ca)\b/gi, type: "because" },
  { re: /\b(ca\s+sƒÉ|ca\s+sa)\b/gi, type: "in_order_to" },
  { re: /\b(de»ôi|desi)\b/gi, type: "although" },
  { re: /\b(dacƒÉ|daca)\b/gi, type: "if" },
  { re: /\b(c√¢nd|cand|when)\b/gi, type: "when" },
  { re: /\b(dar|but)\b/gi, type: "but" },
  { re: /\b(»ôi|si|and)\b/gi, type: "and" },
  { re: /\b(iar|apoi|then)\b/gi, type: "and" }, // simplificat
];

// mapare conector -> ending coreean (defaulturi simple)
function connectorToEnding(type) {
  switch (type) {
    case "and": return "-Í≥†";
    case "but": return "-ÏßÄÎßå";
    case "because": return "-Ïñ¥ÏÑú";     // (mai tarziu faci -ÏïÑÏÑú/-Ïñ¥ÏÑú inteligent)
    case "if": return "-(Ïúº)Î©¥";
    case "when": return "-(Ïúº)„Ñπ Îïå";
    case "in_order_to": return "-(Ïúº)Î†§Í≥†";
    case "although": return "-ÏßÄÎßå";    // simplificat (mai tarziu rafinezi)
    default: return "-Í≥†";
  }
}

// ================================
// Split multi: produce clauze + conectorii dintre ele
// Ex: "A and B and C" => clauses:[A,B,C], conns:[and,and]
// ================================
function splitMultiSentence(raw) {
  const text = (raw || "").replace(/\s+/g, " ").trim();
  if (!text) return { clauses: [""], conns: [] };

  // gasim toate potrivirile cu index, ca sa split-uim stabil
  const hits = [];
  for (const c of CONNECTORS) {
    let m;
    while ((m = c.re.exec(text)) !== null) {
      hits.push({ index: m.index, len: m[0].length, type: c.type });
      // evita bucle infinite la regex global
      if (m.index === c.re.lastIndex) c.re.lastIndex++;
    }
    c.re.lastIndex = 0; // reset
  }

  // sortam si eliminam suprapuneri (pastram match-ul cel mai lung / primul)
  hits.sort((a, b) => a.index - b.index || b.len - a.len);
  const filtered = [];
  let lastEnd = -1;
  for (const h of hits) {
    if (h.index >= lastEnd) {
      filtered.push(h);
      lastEnd = h.index + h.len;
    }
  }

  if (filtered.length === 0) return { clauses: [text], conns: [] };

  const clauses = [];
  const conns = [];

  let start = 0;
  for (const h of filtered) {
    const left = text.slice(start, h.index).trim();
    if (left) clauses.push(left);

    conns.push(h.type);
    start = h.index + h.len;
  }

  const tail = text.slice(start).trim();
  if (tail) clauses.push(tail);

  // daca avem mai multi conectori decat clauze-1 (din cauza spatiilor/punctuatiei), normalizam
  while (conns.length > Math.max(0, clauses.length - 1)) conns.pop();

  return { clauses, conns };
}

// ================================
// Clear strict (ca sa nu ramana "Ïûò" etc.)
// ================================
function clearTable(tableId) {
  const table = document.getElementById(tableId);
  if (!table) return;
  table.querySelectorAll(".col-body-main").forEach(el => (el.textContent = ""));
}

// seteaza text in celula data-key
function setCell(tableId, key, value) {
  const table = document.getElementById(tableId);
  if (!table) return;
  const cell = table.querySelector(`.col[data-key="${key}"] .col-body-main`);
  if (cell) cell.textContent = value || "";
}

// citeste text din celula data-key
function readCell(tableId, key) {
  const table = document.getElementById(tableId);
  if (!table) return "";
  const cell = table.querySelector(`.col[data-key="${key}"] .col-body-main`);
  return cell ? cell.textContent.trim() : "";
}

// "are continut" (folosit ca sa nu lipim -Í≥† daca urmatoarea clauza e goala)
function tableHasAny(tableId) {
  const keys = ["subject","time","place","mod","object","numeral","counter","verb","conj"];
  return keys.some(k => !!readCell(tableId, k));
}
    // =========================
    // H) Clear
    // =========================
    function clearAll() {
      const input = document.getElementById("inputText");
      if (input) input.value = "";

      ensureClauseCount(1);
      const tableId = "tableP1";
      const table = document.getElementById(tableId);
      if (table) {
        table.querySelectorAll(".col-body-main").forEach(el => el.textContent = "");
      }
      // un default minim
      const v = document.querySelector('#tableP1 .col[data-key="verb"] .col-body-main');
      const s = document.querySelector('#tableP1 .col[data-key="subject"] .col-body-main');
      if (s) s.textContent = "Ï†Ä";
      if (v) v.textContent = "Í∞ÄÎã§";

      rebuildPreview();
    }

    // =========================
    // I) Init + live preview la editare
    // =========================
    function wireLivePreview() {
      document.addEventListener("input", function(e){
        const target = e.target;
        if (!target) return;
        // dacƒÉ editezi orice celulƒÉ din builder, actualizƒÉm preview
        if (target.classList && target.classList.contains("col-body-main")) {
          rebuildPreview();
        }
      });
    }

    function init() {
      ensureClauseCount(1);

      // default ini»õial
      const s = document.querySelector('#tableP1 .col[data-key="subject"] .col-body-main');
      const v = document.querySelector('#tableP1 .col[data-key="verb"] .col-body-main');
      if (s) s.textContent = "Ï†Ä";
      if (v) v.textContent = "Í∞ÄÎã§";

      document.getElementById("autoFillBtn").addEventListener("click", autoFillFromInput);
      document.getElementById("clearBtn").addEventListener("click", clearAll);

      wireLivePreview();
      rebuildPreview();
    }
function hangulCode(ch){ return ch.charCodeAt(0); }
function isHangulSyllable(ch){
  const c = hangulCode(ch);
  return c >= 0xAC00 && c <= 0xD7A3;
}
function lastHangulSyllable(str){
  for (let i=str.length-1;i>=0;i--){
    const ch = str[i];
    if (isHangulSyllable(ch)) return ch;
  }
  return null;
}
function hasFinalConsonant(syll){
  const code = hangulCode(syll) - 0xAC00;
  const jong = code % 28;
  return jong !== 0;
}
function vowelIndex(syll){
  const code = hangulCode(syll) - 0xAC00;
  const jung = Math.floor((code % (28*21)) / 28);
  return jung; // 0..20
}

// reguli minimaliste, fara pretentia ca acopera TOT, dar suficient pt builder basic
function toPoliteAyoEoyo(verbInf) {
  const v = (verbInf || "").trim();
  if (!v) return "";

  // accepta doar infinitiv (...Îã§)
  if (!v.endsWith("Îã§")) return v;

  // exceptii de baza
  if (v === "ÌïòÎã§") return "Ìï¥Ïöî";
  if (v === "ÎêòÎã§") return "ÎèºÏöî";

  const stem = v.slice(0, -1); // scoatem doar "Îã§"
  const last = lastHangulSyllable(stem);
  if (!last) return stem + "Ïöî";

  const jong = hasFinalConsonant(last);
  const jung = vowelIndex(last);

  // jung indices: 0 „Öè, 2 „Öë, 8 „Öó, 12 „Öõ etc.
  // simplificare: daca ultima vocala e „Öè/„Öó -> ÏïÑÏöî, altfel -> Ïñ¥Ïöî
  const useA = (jung === 0 || jung === 2 || jung === 8 || jung === 12); // „Öè,„Öë,„Öó,„Öõ

  // caz special: stem se termina in „Öè/„Öó => contractie (Í∞Ä + ÏïÑÏöî = Í∞ÄÏöî, Ïò§ + ÏïÑÏöî = ÏôÄÏöî)
  // detectam last vowel „Öè sau „Öó
  const endsWithAorO = (jung === 0 || jung === 8);

  if (!jong && endsWithAorO) {
    // in practica: Í∞ÄÎã§->Í∞ÄÏöî, Ïò§Îã§->ÏôÄÏöî (asta ar necesita „Öó->„Öò; facem hack pt. Ïò§Îã§)
    if (v === "Ïò§Îã§") return "ÏôÄÏöî";
    return stem + "Ïöî";
  }

  return stem + (useA ? "ÏïÑÏöî" : "Ïñ¥Ïöî");
}
    window.addEventListener("DOMContentLoaded", init);
  })();
  </script>
</body>
</html>
