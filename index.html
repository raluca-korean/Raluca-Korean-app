<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sentence Builder ‚Äî Build & Extend Korean Sentences</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#121c38;
      --card2:#0f1833;
      --text:#eaf0ff;
      --muted:#a8b3d6;
      --muted2:#7f8ab4;
      --line:#22305a;
      --chip:#1a2750;
      --chip2:#162243;
      --ok:#23c483;
      --warn:#ffcc66;
      --bad:#ff5c7a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --radius2: 12px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 10% 10%, rgba(35,196,131,.12), transparent 55%),
        radial-gradient(900px 700px at 90% 10%, rgba(255,92,122,.10), transparent 55%),
        radial-gradient(800px 600px at 50% 100%, rgba(120,160,255,.10), transparent 60%),
        var(--bg);
    }

    .wrap{max-width:1100px;margin:0 auto;padding:22px 16px 40px}
    .top{
      display:flex;gap:16px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;
      margin-bottom:16px;
    }
    .brand{
      display:flex;flex-direction:column;gap:6px;
      padding:14px 16px;border:1px solid var(--line);border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(18,28,56,.9), rgba(15,23,48,.9));
      box-shadow:var(--shadow);
      min-width:min(640px,100%);
    }
    .brand h1{
      margin:0;
      font-size:18px;
      letter-spacing:.2px;
    }
    .brand .sub{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
    }
    .controls{
      display:flex;flex-direction:column;gap:10px;
      padding:14px 16px;border:1px solid var(--line);border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(18,28,56,.85), rgba(15,23,48,.85));
      box-shadow:var(--shadow);
      min-width:260px;
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .label{
      font-size:12px;color:var(--muted);
      display:flex;align-items:center;gap:8px;
    }
    select, button, input[type="text"]{
      font:inherit;
      color:var(--text);
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 12px;
      outline:none;
      transition:.15s ease;
    }
    select{padding-right:34px}
    button{
      cursor:pointer;
      background:linear-gradient(180deg, rgba(26,39,80,.95), rgba(15,23,48,.95));
    }
    button:hover{transform:translateY(-1px);border-color:#30437a}
    button:active{transform:translateY(0px)}
    button.primary{
      border-color:rgba(35,196,131,.55);
      background:linear-gradient(180deg, rgba(35,196,131,.18), rgba(26,39,80,.95));
    }
    button.danger{
      border-color:rgba(255,92,122,.55);
      background:linear-gradient(180deg, rgba(255,92,122,.12), rgba(26,39,80,.95));
    }
    button.ghost{
      background:transparent;
    }
    .tiny{font-size:12px;padding:8px 10px;border-radius:10px}

    .layout{
      display:grid;
      grid-template-columns: 1.4fr .8fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 960px){
      .layout{grid-template-columns:1fr}
      .brand{min-width:100%}
    }

    .panel{
      border:1px solid var(--line);
      border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(18,28,56,.8), rgba(15,23,48,.8));
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .panel h2{
      margin:0;
      padding:14px 16px;
      font-size:13px;
      letter-spacing:.6px;
      text-transform:uppercase;
      border-bottom:1px solid var(--line);
      color:var(--muted);
      display:flex;align-items:center;justify-content:space-between;gap:10px;
    }
    .panel .body{padding:14px 16px}
    .muted{color:var(--muted)}
    .hint{font-size:12px;color:var(--muted2);line-height:1.45}

    /* Timeline */
    .timeline{
      position:relative;
      padding-left:22px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .timeline:before{
      content:"";
      position:absolute;
      left:10px; top:4px; bottom:4px;
      width:2px;
      background:linear-gradient(180deg, rgba(120,160,255,.22), rgba(35,196,131,.22));
      border-radius:2px;
    }
    .step{
      position:relative;
      border:1px solid var(--line);
      border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(18,28,56,.92), rgba(15,23,48,.92));
      box-shadow: 0 8px 22px rgba(0,0,0,.28);
      overflow:hidden;
    }
    .dot{
      position:absolute;
      left:-22px; top:14px;
      width:14px;height:14px;border-radius:50%;
      background:rgba(120,160,255,.35);
      border:1px solid rgba(120,160,255,.55);
      box-shadow:0 0 0 5px rgba(120,160,255,.09);
    }
    .stepHeader{
      padding:12px 14px;
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      border-bottom:1px solid var(--line);
      background:rgba(0,0,0,.08);
    }
    .stepHeader .title{
      display:flex;flex-direction:column;gap:2px;
    }
    .stepHeader .title b{font-size:13px;letter-spacing:.3px}
    .stepHeader .title span{font-size:12px;color:var(--muted)}
    .stepBody{padding:12px 14px;display:flex;flex-direction:column;gap:10px}
    .sentence{
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px 12px;
      background:linear-gradient(180deg, rgba(15,24,51,.95), rgba(18,28,56,.85));
    }
    .ko{
      font-size:20px;
      letter-spacing:.2px;
      line-height:1.25;
      margin:0;
    }
    .tr{
      margin:6px 0 0 0;
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
    }
    .actions{
      display:flex;gap:8px;flex-wrap:wrap;align-items:center;
    }

    /* Chips */
    .chips{display:flex;flex-wrap:wrap;gap:8px}
    .chip{
      border:1px solid var(--line);
      border-radius:999px;
      padding:8px 10px;
      font-size:12px;
      background:linear-gradient(180deg, rgba(26,39,80,.75), rgba(15,23,48,.75));
      cursor:pointer;
      user-select:none;
      display:flex;gap:8px;align-items:center;
      transition:.14s ease;
    }
    .chip:hover{transform:translateY(-1px);border-color:#30437a}
    .chip.active{
      border-color:rgba(35,196,131,.55);
      box-shadow:0 0 0 4px rgba(35,196,131,.10);
    }
    .chip small{color:var(--muted2);font-size:11px}
    .chip .tag{
      font-family:var(--mono);
      font-size:11px;
      color:#cfe0ff;
      padding:2px 7px;
      border-radius:999px;
      background:rgba(120,160,255,.16);
      border:1px solid rgba(120,160,255,.22);
    }

    /* Builder side */
    .stack{display:flex;flex-direction:column;gap:12px}
    .block{
      border:1px solid var(--line);
      border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(18,28,56,.72), rgba(15,23,48,.72));
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .block .bh{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      background:rgba(0,0,0,.06);
    }
    .block .bh b{font-size:13px}
    .block .bb{padding:12px 14px;display:flex;flex-direction:column;gap:10px}
    .kv{display:grid;grid-template-columns: 1fr auto;gap:10px;align-items:center}
    .mono{font-family:var(--mono)}
    .pill{
      font-size:11px;color:var(--muted);
      padding:4px 8px;border:1px solid var(--line);
      border-radius:999px;background:rgba(0,0,0,.12)
    }
    .out{
      border:1px dashed rgba(120,160,255,.35);
      border-radius:14px;
      padding:12px;
      background:rgba(0,0,0,.12);
    }
    .out .ko{font-size:18px}
    .out .tr{font-size:12px}
    .sep{height:1px;background:var(--line);margin:6px 0}
    .kbd{
      font-family:var(--mono);
      font-size:11px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.14);
      color:var(--muted);
    }
    .toast{
      position:fixed;
      bottom:16px;left:50%;
      transform:translateX(-50%);
      background:rgba(18,28,56,.95);
      border:1px solid var(--line);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      box-shadow:var(--shadow);
      font-size:13px;
      opacity:0;pointer-events:none;
      transition:.18s ease;
      max-width:min(740px, calc(100% - 30px));
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.show{opacity:1;transform:translateX(-50%) translateY(-6px)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="brand">
        <h1>Sentence Builder ‚Äî Build & Extend Korean Sentences</h1>
        <p class="sub">
          Modul static, extensibil, ‚Äûpremium‚Äù: porne»ôti de la propozi»õii simple »ôi le construie»ôti √Æn lan»õ (ADD / MODIFY / COMBINE).
          Traduce RO‚ÜîKO (»ôi EN), are audio, copy, reset, export JSON. Gata de lipit √Æn aplica»õia ta mare.
        </p>
      </div>

      <div class="controls">
        <div class="row">
          <span class="label">Scenariu</span>
          <select id="scenarioSelect"></select>
        </div>
        <div class="row">
          <span class="label">LimbƒÉ traducere</span>
          <select id="langSelect">
            <option value="ro">RO</option>
            <option value="en">EN</option>
          </select>
        </div>
        <div class="row">
          <button class="primary" id="btnRebuild">Rebuild</button>
          <button class="ghost" id="btnAuto">Auto-build</button>
          <button class="danger" id="btnReset">Reset</button>
        </div>
        <div class="hint">
          Tips: click pe chips ca sƒÉ activezi/dezactivezi. <span class="kbd">Rebuild</span> actualizeazƒÉ timeline-ul final.
        </div>
      </div>
    </div>

    <div class="layout">
      <!-- LEFT: Timeline -->
      <div class="panel">
        <h2>
          Flow (timeline)
          <span class="pill" id="statusPill">ready</span>
        </h2>
        <div class="body">
          <div class="timeline" id="timeline"></div>
        </div>
      </div>

      <!-- RIGHT: Builder -->
      <div class="stack">
        <div class="block">
          <div class="bh">
            <b>1) BASE</b>
            <span class="pill">seed</span>
          </div>
          <div class="bb">
            <div class="out" id="baseOut"></div>
            <div class="actions">
              <button class="tiny" id="btnSpeakBase">üîä Audio</button>
              <button class="tiny" id="btnCopyBase">Copy</button>
            </div>
          </div>
        </div>

        <div class="block">
          <div class="bh">
            <b>2) EXTEND</b>
            <span class="pill">ADD / MODIFY</span>
          </div>
          <div class="bb">
            <div class="hint">ADD = adaugi un element (loc/adverb/extra). MODIFY = schimbi o proprietate (ex: ‚ÄûÎ¨º‚Äù ‚Üí ‚ÄûÎú®Í±∞Ïö¥ Î¨º‚Äù).</div>

            <div class="sep"></div>
            <div class="kv">
              <div class="muted">ADD (chips)</div>
              <span class="pill" id="countAdd">0 selected</span>
            </div>
            <div class="chips" id="addChips"></div>

            <div class="sep"></div>
            <div class="kv">
              <div class="muted">MODIFY (choose one)</div>
              <span class="pill" id="countMod">none</span>
            </div>
            <div class="chips" id="modChips"></div>
          </div>
        </div>

        <div class="block">
          <div class="bh">
            <b>3) COMBINE</b>
            <span class="pill">clause builder</span>
          </div>
          <div class="bb">
            <div class="hint">
              Alegi conectorii dintre propozi»õii. Aplica»õia ta mare poate extinde lista fƒÉrƒÉ sƒÉ schimbi logica.
            </div>

            <div class="row">
              <span class="label">Connector 1 (A ‚Üí B)</span>
              <select id="c1"></select>
            </div>
            <div class="row">
              <span class="label">Connector 2 (B ‚Üí C)</span>
              <select id="c2"></select>
            </div>

            <div class="sep"></div>
            <div class="out" id="finalOut"></div>
            <div class="actions">
              <button class="tiny primary" id="btnSpeakFinal">üîä Audio</button>
              <button class="tiny" id="btnCopyFinal">Copy</button>
              <button class="tiny" id="btnExport">Export JSON</button>
            </div>
          </div>
        </div>

        <div class="block">
          <div class="bh">
            <b>Integrare √Æn aplica»õia mare</b>
            <span class="pill">safe</span>
          </div>
          <div class="bb">
            <div class="hint">
              Recomandat: pƒÉstrezi fi»ôierul ca modul separat. √én aplica»õia mare √Æl √Æncarci ca paginƒÉ nouƒÉ sau √Æl incluzi √Æntr-un container.
              Nu atinge paginile existente care func»õioneazƒÉ.
            </div>
            <div class="hint mono">
              - Variante: /modules/sentence-builder.html<br/>
              - Link: &lt;a href="modules/sentence-builder.html"&gt;Sentence Builder&lt;/a&gt;<br/>
              - Sau iframe: &lt;iframe src="modules/sentence-builder.html"&gt;&lt;/iframe&gt;
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="toast" id="toast"></div>
  </div>

  <script>
    /* =========================================================
       Sentence Builder ‚Äî Static, extensible, "premium"
       ========================================================= */

    // 1) SCENARIOS (inspirat din pozele tale) ‚Äî extensibil
    // A: inten»õie / ac»õiune
    // B: eveniment / rezultat
    // C: reac»õie / emo»õie
    const SCENARIOS = [
      {
        id: "ch13_tooth",
        name: "Cap. 13 ‚Äî Din»õi / apƒÉ fierbinte / surprins",
        base: {
          A: { ko: "ÏñëÏπòÌïòÎ†§Í≥† ÏªµÏóê Î¨ºÏùÑ Î∞õÏïòÏñ¥Ïöî.", ro: "Am umplut un pahar cu apƒÉ ca sƒÉ mƒÉ spƒÉl pe din»õi.", en: "I filled a cup with water to brush my teeth." },
          B: { ko: "Î¨ºÏù¥ ÎÇòÏôîÏñ¥Ïöî.", ro: "A ie»ôit apƒÉ.", en: "Water came out." },
          C: { ko: "ÎÜÄÎûêÏñ¥Ïöî.", ro: "Am fost surprins(ƒÉ).", en: "I was surprised." }
        },
        add: [
          { id:"add_place_cup", tag:"+LOC", ko:"ÏªµÏóê", ro:"√Æn canƒÉ/pahar", en:"in a cup" },
          { id:"add_adv_really", tag:"+ADV", ko:"Ï†ïÎßê", ro:"chiar / foarte", en:"really" },
          { id:"add_adv_suddenly", tag:"+ADV", ko:"Í∞ëÏûêÍ∏∞", ro:"dintr-odatƒÉ", en:"suddenly" },
          { id:"add_reason_because", tag:"+INFO", ko:"Í∑∏ÎûòÏÑú", ro:"de aceea", en:"so" }
        ],
        modify: [
          // MOD pentru B: "water" -> "hot water"
          { id:"mod_hot_water", tag:"MOD", target:"B", koReplace: { from:"Î¨º", to:"Îú®Í±∞Ïö¥ Î¨º" }, ro:"(modificƒÉ: apƒÉ ‚Üí apƒÉ fierbinte)", en:"(modify: water ‚Üí hot water)" },
          // MOD pentru C: "surprised" -> "really surprised"
          { id:"mod_really_surprised", tag:"MOD", target:"C", koWrap: { prefix:"Ï†ïÎßê ", suffix:"" }, ro:"(modificƒÉ: surprins ‚Üí foarte surprins)", en:"(modify: surprised ‚Üí really surprised)" }
        ],
        connectors: [
          { id:"c_intent", label:"-(Ïúº)Î†§Í≥† (inten»õie)", apply:(A,B)=> A.replace("Ïöî.","") + " " + B },
          { id:"c_but", label:"-(Ïúº)„Ñ¥Îç∞ (dar/√ÆnsƒÉ)", apply:(A,B)=> A.replace("Ïöî.","") + "ÎäîÎç∞, " + B },
          { id:"c_reason", label:"-ÏïÑ/Ïñ¥/Ïó¨ÏÑú (cauzƒÉ)", apply:(A,B)=> A.replace("Ïöî.","") + "ÏÑú " + B },
          { id:"c_then", label:"Í∑∏Î¶¨Í≥† (»ôi apoi)", apply:(A,B)=> A + " Í∑∏Î¶¨Í≥† " + B },
        ],
        defaults: { c1:"c_but", c2:"c_reason" }
      }
    ];

    // 2) UI refs
    const $ = (s)=>document.querySelector(s);
    const timeline = $("#timeline");
    const scenarioSelect = $("#scenarioSelect");
    const langSelect = $("#langSelect");
    const addChips = $("#addChips");
    const modChips = $("#modChips");
    const baseOut = $("#baseOut");
    const finalOut = $("#finalOut");
    const c1 = $("#c1");
    const c2 = $("#c2");
    const statusPill = $("#statusPill");
    const toast = $("#toast");

    const btnRebuild = $("#btnRebuild");
    const btnReset = $("#btnReset");
    const btnAuto = $("#btnAuto");
    const btnSpeakBase = $("#btnSpeakBase");
    const btnCopyBase = $("#btnCopyBase");
    const btnSpeakFinal = $("#btnSpeakFinal");
    const btnCopyFinal = $("#btnCopyFinal");
    const btnExport = $("#btnExport");

    const countAdd = $("#countAdd");
    const countMod = $("#countMod");

    // 3) state
    const state = {
      scenarioId: SCENARIOS[0].id,
      lang: "ro",
      selectedAdd: new Set(),
      selectedMod: null, // only one at a time (premium clarity)
      c1: null,
      c2: null
    };

    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      setTimeout(()=>toast.classList.remove("show"), 1400);
    }

    // 4) helpers
    function esc(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

    function getScenario(){
      return SCENARIOS.find(x=>x.id===state.scenarioId) || SCENARIOS[0];
    }

    function trText(obj){
      return state.lang === "ro" ? obj.ro : obj.en;
    }

    // Apply MODIFY rules to base clauses
    function applyModifyToClause(koText, mod){
      if(!mod) return koText;
      let out = koText;

      if(mod.koReplace){
        // replace only first occurrence for safety
        const {from,to} = mod.koReplace;
        out = out.replace(from, to);
      }
      if(mod.koWrap){
        out = (mod.koWrap.prefix || "") + out + (mod.koWrap.suffix || "");
      }
      return out;
    }

    // Apply ADD chips (lightweight, safe): we either prefix certain tokens
    // For this demo:
    // - "ÏªµÏóê" should be present in A already; if user adds it, we ensure it exists.
    // - "Ï†ïÎßê" can prefix C, or also before ÎÜÄÎûêÏñ¥Ïöî.
    // - "Í∞ëÏûêÍ∏∞" can prefix B
    // - "Í∑∏ÎûòÏÑú" can prefix final C clause or between B->C (we'll use it as prefix for C if connector isn't causal)
    function applyAdds(clauses, addIds){
      let A = clauses.A;
      let B = clauses.B;
      let C = clauses.C;

      const has = (id)=> addIds.has(id);

      if(has("add_place_cup")){
        // ensure "ÏªµÏóê" exists in A near the object (simple heuristic)
        if(!A.includes("ÏªµÏóê")){
          // insert after "ÏñëÏπòÌïòÎ†§Í≥†"
          A = A.replace("ÏñëÏπòÌïòÎ†§Í≥† ", "ÏñëÏπòÌïòÎ†§Í≥† ÏªµÏóê ");
        }
      }

      if(has("add_adv_suddenly")){
        if(!B.trim().startsWith("Í∞ëÏûêÍ∏∞")){
          B = "Í∞ëÏûêÍ∏∞ " + B;
        }
      }

      if(has("add_adv_really")){
        // if no MOD already adds "Ï†ïÎßê" to C, add it
        if(!C.trim().startsWith("Ï†ïÎßê")){
          C = "Ï†ïÎßê " + C;
        }
      }

      if(has("add_reason_because")){
        // "Í∑∏ÎûòÏÑú" makes sense at start of C
        if(!C.trim().startsWith("Í∑∏ÎûòÏÑú")){
          C = "Í∑∏ÎûòÏÑú " + C;
        }
      }

      return {A,B,C};
    }

    // Combine clauses with connectors
    function combineTwo(text1, text2, connector){
      return connector.apply(text1, text2);
    }

    // 5) render
    function renderScenarioOptions(){
      scenarioSelect.innerHTML = SCENARIOS.map(s=>`<option value="${esc(s.id)}">${esc(s.name)}</option>`).join("");
      scenarioSelect.value = state.scenarioId;
    }

    function renderConnectors(){
      const s = getScenario();
      const opts = s.connectors.map(c=>`<option value="${esc(c.id)}">${esc(c.label)}</option>`).join("");
      c1.innerHTML = opts;
      c2.innerHTML = opts;

      state.c1 = state.c1 || s.defaults.c1;
      state.c2 = state.c2 || s.defaults.c2;
      c1.value = state.c1;
      c2.value = state.c2;
    }

    function renderChips(){
      const s = getScenario();

      addChips.innerHTML = s.add.map(item=>{
        const active = state.selectedAdd.has(item.id) ? "active" : "";
        return `
          <div class="chip ${active}" data-add="${esc(item.id)}">
            <span class="tag">${esc(item.tag)}</span>
            <span>${esc(item.ko)}</span>
            <small>${esc(state.lang==="ro"?item.ro:item.en)}</small>
          </div>
        `;
      }).join("");

      modChips.innerHTML = s.modify.map(item=>{
        const active = state.selectedMod === item.id ? "active" : "";
        return `
          <div class="chip ${active}" data-mod="${esc(item.id)}">
            <span class="tag">${esc(item.tag)}</span>
            <span>${esc(item.id==="mod_hot_water" ? "Î¨º ‚Üí Îú®Í±∞Ïö¥ Î¨º" : "ÎÜÄÎûêÏñ¥Ïöî ‚Üí Ï†ïÎßê ÎÜÄÎûêÏñ¥Ïöî")}</span>
            <small>${esc(state.lang==="ro"?item.ro:item.en)}</small>
          </div>
        `;
      }).join("");

      countAdd.textContent = `${state.selectedAdd.size} selected`;
      countMod.textContent = state.selectedMod ? "1 selected" : "none";
    }

    function renderOutputsAndTimeline(){
      const s = getScenario();
      statusPill.textContent = "building‚Ä¶";

      // Base clauses
      let A = s.base.A.ko;
      let B = s.base.B.ko;
      let C = s.base.C.ko;

      // MOD (one choice)
      const mod = s.modify.find(m=>m.id===state.selectedMod) || null;
      if(mod){
        if(mod.target === "A") A = applyModifyToClause(A, mod);
        if(mod.target === "B") B = applyModifyToClause(B, mod);
        if(mod.target === "C") C = applyModifyToClause(C, mod);
      }

      // ADD chips
      ({A,B,C} = applyAdds({A,B,C}, state.selectedAdd));

      // Connectors
      const conn1 = s.connectors.find(c=>c.id===state.c1) || s.connectors[0];
      const conn2 = s.connectors.find(c=>c.id===state.c2) || s.connectors[0];

      // Final combined: (A -> B) -> C
      const AB = combineTwo(A, B, conn1);
      const ABC = combineTwo(AB, C, conn2);

      // BASE OUT (show A only as seed, like TTMIK)
      baseOut.innerHTML = `
        <div class="sentence">
          <p class="ko">${esc(s.base.A.ko)}</p>
          <p class="tr">${esc(trText(s.base.A))}</p>
        </div>
      `;

      // FINAL OUT
      finalOut.innerHTML = `
        <div class="sentence">
          <p class="ko">${esc(ABC)}</p>
          <p class="tr">${esc(buildTranslationPreview(s, A, B, C, conn1, conn2))}</p>
        </div>
      `;

      // TIMELINE (premium flow)
      timeline.innerHTML = "";

      // Step 1: Base
      addStep({
        title:"BASE (Seed)",
        subtitle:"Propozi»õie de pornire",
        ko:s.base.A.ko,
        tr:trText(s.base.A),
        buttons:[
          {label:"üîä Audio", onClick:()=>speakKo(s.base.A.ko)},
          {label:"Copy", onClick:()=>copyText(s.base.A.ko)}
        ]
      });

      // Step 2: Conjugation / Components view (like TTMIK table, but condensed)
      addStep({
        title:"COMPONENTS",
        subtitle:"A / B / C (building blocks)",
        ko: `${A}\n${B}\n${C}`,
        tr: `${buildClauseTr(s, "A")}\n${buildClauseTr(s, "B")}\n${buildClauseTr(s, "C")}`,
        buttons:[
          {label:"Copy blocks", onClick:()=>copyText(`${A}\n${B}\n${C}`)}
        ]
      });

      // Step 3: Combine 1
      addStep({
        title:"COMBINE 1",
        subtitle:`A ‚Üí B using ${conn1.label}`,
        ko: AB,
        tr: buildTranslationPreview(s, A, B, null, conn1, null),
        buttons:[
          {label:"üîä Audio", onClick:()=>speakKo(AB)},
          {label:"Copy", onClick:()=>copyText(AB)}
        ]
      });

      // Step 4: Combine 2 (Final)
      addStep({
        title:"COMBINE 2 (Final)",
        subtitle:`(A‚ÜíB) ‚Üí C using ${conn2.label}`,
        ko: ABC,
        tr: buildTranslationPreview(s, A, B, C, conn1, conn2),
        buttons:[
          {label:"üîä Audio", onClick:()=>speakKo(ABC)},
          {label:"Copy", onClick:()=>copyText(ABC)}
        ]
      });

      statusPill.textContent = "ready";
    }

    function addStep({title, subtitle, ko, tr, buttons=[]}){
      const step = document.createElement("div");
      step.className = "step";
      step.innerHTML = `
        <div class="dot"></div>
        <div class="stepHeader">
          <div class="title">
            <b>${esc(title)}</b>
            <span>${esc(subtitle)}</span>
          </div>
          <div class="actions"></div>
        </div>
        <div class="stepBody">
          <div class="sentence">
            <p class="ko">${esc(ko).replace(/\n/g,"<br/>")}</p>
            <p class="tr">${esc(tr).replace(/\n/g,"<br/>")}</p>
          </div>
        </div>
      `;
      const act = step.querySelector(".actions");
      buttons.forEach(b=>{
        const btn = document.createElement("button");
        btn.className = "tiny";
        btn.textContent = b.label;
        btn.addEventListener("click", b.onClick);
        act.appendChild(btn);
      });
      timeline.appendChild(step);
    }

    function buildClauseTr(s, key){
      // Use original base translations; builder is for Korean logic primarily.
      // For preview: use base translations as reference.
      return trText(s.base[key]);
    }

    function buildTranslationPreview(s, A, B, C, conn1, conn2){
      // High-quality approach: not perfect MT; gives a clean ‚Äúmeaning preview‚Äù.
      // We use base translations, then reflect connectors semantically.
      const tA = trText(s.base.A);
      const tB = trText(s.base.B);
      const tC = C ? trText(s.base.C) : "";

      const label = (conn)=> conn ? conn.label : "";

      if(!C && conn1){
        return `${tA}  [${label(conn1)}]  ${tB}`;
      }
      if(C && conn1 && conn2){
        return `${tA}  [${label(conn1)}]  ${tB}  [${label(conn2)}]  ${tC}`;
      }
      // fallback
      return [tA,tB,tC].filter(Boolean).join(" / ");
    }

    // 6) interactions
    function bindChipEvents(){
      addChips.addEventListener("click", (e)=>{
        const chip = e.target.closest(".chip[data-add]");
        if(!chip) return;
        const id = chip.getAttribute("data-add");
        if(state.selectedAdd.has(id)) state.selectedAdd.delete(id);
        else state.selectedAdd.add(id);
        renderChips();
        renderOutputsAndTimeline();
      });

      modChips.addEventListener("click", (e)=>{
        const chip = e.target.closest(".chip[data-mod]");
        if(!chip) return;
        const id = chip.getAttribute("data-mod");
        state.selectedMod = (state.selectedMod === id) ? null : id;
        renderChips();
        renderOutputsAndTimeline();
      });
    }

    scenarioSelect.addEventListener("change", ()=>{
      state.scenarioId = scenarioSelect.value;
      // reset state for scenario
      state.selectedAdd.clear();
      state.selectedMod = null;
      const s = getScenario();
      state.c1 = s.defaults.c1;
      state.c2 = s.defaults.c2;
      renderConnectors();
      renderChips();
      renderOutputsAndTimeline();
      showToast("Scenario changed.");
    });

    langSelect.addEventListener("change", ()=>{
      state.lang = langSelect.value;
      renderChips();
      renderOutputsAndTimeline();
      showToast("Language updated.");
    });

    c1.addEventListener("change", ()=>{
      state.c1 = c1.value;
      renderOutputsAndTimeline();
    });
    c2.addEventListener("change", ()=>{
      state.c2 = c2.value;
      renderOutputsAndTimeline();
    });

    btnReset.addEventListener("click", ()=>{
      state.selectedAdd.clear();
      state.selectedMod = null;
      const s = getScenario();
      state.c1 = s.defaults.c1;
      state.c2 = s.defaults.c2;
      renderConnectors();
      renderChips();
      renderOutputsAndTimeline();
      showToast("Reset done.");
    });

    btnRebuild.addEventListener("click", ()=>{
      renderOutputsAndTimeline();
      showToast("Rebuilt.");
    });

    btnAuto.addEventListener("click", ()=>{
      // ‚Äúwow‚Äù demo: choose best TTMIK-like chain
      state.selectedAdd.add("add_place_cup");
      state.selectedMod = "mod_hot_water";
      state.selectedAdd.add("add_adv_really");
      state.c1 = "c_but";
      state.c2 = "c_reason";
      renderConnectors();
      renderChips();
      renderOutputsAndTimeline();
      showToast("Auto-build applied.");
    });

    btnSpeakBase.addEventListener("click", ()=>{
      const s = getScenario();
      speakKo(s.base.A.ko);
    });

    btnCopyBase.addEventListener("click", ()=>{
      const s = getScenario();
      copyText(s.base.A.ko);
    });

    btnSpeakFinal.addEventListener("click", ()=>{
      const ko = finalOut.querySelector(".ko")?.textContent || "";
      speakKo(ko);
    });

    btnCopyFinal.addEventListener("click", ()=>{
      const ko = finalOut.querySelector(".ko")?.textContent || "";
      copyText(ko);
    });

    btnExport.addEventListener("click", ()=>{
      const s = getScenario();
      const koFinal = finalOut.querySelector(".ko")?.textContent || "";
      const payload = {
        module: "sentence-builder",
        scenario: { id: s.id, name: s.name },
        lang: state.lang,
        selectedAdd: [...state.selectedAdd],
        selectedMod: state.selectedMod,
        connectors: { c1: state.c1, c2: state.c2 },
        output: { ko: koFinal }
      };
      copyText(JSON.stringify(payload, null, 2));
      showToast("Export JSON copied to clipboard.");
    });

    // 7) utilities: copy + speech
    async function copyText(txt){
      try{
        await navigator.clipboard.writeText(txt);
        showToast("Copied.");
      }catch{
        // fallback
        const ta = document.createElement("textarea");
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
        showToast("Copied (fallback).");
      }
    }

    function speakKo(text){
      if(!("speechSynthesis" in window)){
        showToast("Speech not supported in this browser.");
        return;
      }
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "ko-KR";

      // attempt to pick a Korean voice if available
      const voices = window.speechSynthesis.getVoices?.() || [];
      const koVoice = voices.find(v => (v.lang||"").toLowerCase().startsWith("ko"));
      if(koVoice) u.voice = koVoice;

      u.rate = 1.0;
      u.pitch = 1.0;
      u.volume = 1.0;

      window.speechSynthesis.speak(u);
    }

    // 8) init
    function init(){
      renderScenarioOptions();
      renderConnectors();
      renderChips();
      bindChipEvents();
      renderOutputsAndTimeline();

      // iOS/Safari sometimes needs voices loaded after a user gesture; still ok.
      if("speechSynthesis" in window){
        window.speechSynthesis.onvoiceschanged = ()=>{};
      }
    }
    init();
  </script>
</body>
</html>
