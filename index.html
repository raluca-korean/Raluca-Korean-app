<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Raluca Korean â€“ Builder P2 Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    /* ===== Pastel simplu â€“ doar pentru test ===== */
    :root{
      --bg1:#dff3ff;
      --bg2:#ffe9ff;
      --bg3:#f4fffc;
      --bg4:#e8f0ff;

      --accent:#7b5dff;
      --accent-soft:#f6b5ff;
      --card-bg:#ffffffcc;
      --text-main:#2f343b;
      --text-soft:#7a8088;
      --border:#e1d7c7;
    }

    *{box-sizing:border-box;}

    body{
      margin:0;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      color:var(--text-main);
      background:linear-gradient(120deg,var(--bg1),var(--bg2),var(--bg3),var(--bg4));
      background-size:380% 380%;
      animation:bgFlow 28s ease-in-out infinite;
    }
    @keyframes bgFlow{
      0%{background-position:0% 50%;}
      50%{background-position:100% 50%;}
      100%{background-position:0% 50%;}
    }

    .app{
      max-width:1040px;
      margin:0 auto;
      padding:18px 14px 80px;
    }

    .rk-header{
      position:relative;
      padding:12px 16px 16px;
      border-radius:26px;
      background:linear-gradient(120deg,#6fb8ff,#a774ff,#ff7fd1);
      color:#fff;
      box-shadow:0 18px 45px rgba(77,93,255,0.4);
    }
    .rk-header-main{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .rk-header-main h1{
      margin:0;
      font-size:20px;
      font-weight:900;
      letter-spacing:0.06em;
      text-transform:uppercase;
    }
    .rk-badge{
      font-size:11px;
      font-weight:600;
      padding:4px 9px;
      border-radius:999px;
      background:rgba(255,255,255,0.18);
      border:1px solid rgba(255,255,255,0.4);
    }
    #subtitle{
      margin:8px 0 0;
      font-size:12px;
    }

    .card{
      margin-top:16px;
      padding:16px 18px 18px;
      border-radius:22px;
      background:var(--card-bg);
      backdrop-filter:blur(16px);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 18px 40px rgba(0,0,0,0.12);
    }
    .card h2{
      margin:0 0 8px;
      font-size:16px;
      font-weight:800;
      letter-spacing:0.03em;
    }

    textarea{
      width:100%;
      border-radius:16px;
      border:1px solid var(--border);
      padding:10px 12px;
      font-size:14px;
      resize:vertical;
      min-height:70px;
      color:var(--text-main);
      background:#fff;
    }
    textarea:focus{
      outline:none;
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.9),
        0 0 0 3px rgba(149,120,255,0.5);
      border-color:rgba(149,120,255,0.7);
    }

    .btn-row{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    button{
      border:none;
      border-radius:999px;
      padding:8px 16px;
      font-size:12px;
      font-weight:700;
      cursor:pointer;
      color:#fff;
      background:linear-gradient(135deg,#6b8cff,#9b6bff);
      box-shadow:
        0 10px 24px rgba(108,110,210,0.4),
        0 0 0 1px rgba(255,255,255,0.7) inset;
      transition:transform .12s ease, box-shadow .12s ease, filter .12s ease;
    }
    button.secondary{
      background:linear-gradient(135deg,#ff9a6c,#ff5f8c);
    }
    button:hover{
      transform:translateY(-1px);
      box-shadow:0 12px 26px rgba(0,0,0,0.18);
      filter:brightness(1.03);
    }
    button:active{
      transform:translateY(1px) scale(0.98);
      box-shadow:0 6px 16px rgba(0,0,0,0.25);
      filter:brightness(0.97);
    }

    .section-title{
      margin-top:18px;
      margin-bottom:6px;
      font-size:13px;
      font-weight:700;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:#4b607d;
    }

    .table-block{
      margin-top:6px;
      padding:10px 10px 12px;
      border-radius:20px;
      background:var(--card-bg);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 14px 30px rgba(0,0,0,0.1);
    }
    .table-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:12px;
      font-weight:700;
      color:var(--text-soft);
      margin-bottom:6px;
    }
    .table-horizontal{
      display:flex;
      gap:8px;
      overflow-x:auto;
      padding-bottom:4px;
    }

    .col{
      min-width:110px;
      max-width:140px;
      flex:0 0 auto;
      border-radius:16px;
      padding:7px 7px 9px;
      background:radial-gradient(circle at top left,#fdfbf7,#f2ebde);
      border:1px solid #e2d7c8;
      box-shadow:0 10px 22px rgba(95,78,58,0.16);
    }
    .col-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:4px;
      font-size:10px;
      font-weight:700;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:#7b5dff;
      border-bottom:1px solid rgba(208,196,255,0.8);
      padding-bottom:2px;
      margin-bottom:3px;
    }
    .col-header::before{
      content:"";
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:16px;
      height:16px;
      border-radius:6px;
      background:#fff;
      font-size:11px;
      box-shadow:0 1px 3px rgba(0,0,0,0.06);
    }
    .col[data-key="subject"] .col-header::before{content:"ğŸ‘¤";}
    .col[data-key="time"]    .col-header::before{content:"â°";}
    .col[data-key="place"]   .col-header::before{content:"ğŸ“";}
    .col[data-key="mod"]     .col-header::before{content:"âœ¨";}
    .col[data-key="object"]  .col-header::before{content:"ğŸ¯";}
    .col[data-key="numeral"] .col-header::before{content:"#ï¸âƒ£";}
    .col[data-key="counter"] .col-header::before{content:"ğŸ”¢";}
    .col[data-key="verb"]    .col-header::before{content:"ğŸš€";}

    .col-body-label{
      font-size:10px;
      color:#938777;
      margin-bottom:1px;
    }
    .col-body-main{
      font-size:15px;
      font-weight:700;
      min-height:1.4em;
    }
    .col-body-main[contenteditable="true"]{
      outline:none;
      cursor:text;
    }
    .col-body-main:focus{
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.8),
        0 0 0 2px rgba(149,120,255,0.7);
      border-radius:6px;
    }

    .builder-enable-p2{
      margin-top:6px;
      padding-top:6px;
      border-top:1px dashed var(--border);
      font-size:11px;
      display:flex;
      justify-content:flex-end;
      color:var(--text-soft);
    }
    .builder-enable-p2 label{
      display:flex;
      align-items:center;
      gap:4px;
    }

    .hidden{display:none !important;}

    .preview-card{
      margin-top:14px;
      padding:12px 14px;
      border-radius:20px;
      background:var(--card-bg);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 16px 32px rgba(0,0,0,0.12);
    }
    .preview-title{
      font-size:12px;
      font-weight:700;
      color:#4b607d;
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:6px;
    }
    .preview-sentence{
      font-size:22px;
      font-weight:800;
      line-height:1.6;
      margin-bottom:4px;
    }
    .preview-ro{
      font-size:12px;
      color:var(--text-soft);
    }

    @media (max-width:600px){
      .rk-header-main h1{font-size:17px;}
      .col{min-width:95px;}
    }
  </style>
</head>

<body>
  <div class="app">
    <header class="rk-header">
      <div class="rk-header-main">
        <h1>RALUCA KOREAN</h1>
        <span class="rk-badge">Builder P2 â€“ test</span>
      </div>
      <p id="subtitle">
        Versiune micÄƒ de test pentru PropoziÈ›ia 2, fraze lungi È™i RomÃ¢nÄƒ â†’ CoreeanÄƒ.
      </p>
    </header>

    <!-- RomÃ¢nÄƒ â†’ CoreeanÄƒ (builder automat) -->
    <section class="card" id="roCard">
      <h2>RomÃ¢nÄƒ â†’ CoreeanÄƒ (Builder automat)</h2>
      <p style="font-size:12px;color:var(--text-soft);margin-top:0;margin-bottom:6px;">
        Scrie o propoziÈ›ie simplÄƒ Ã®n romÃ¢nÄƒ (ex: <em>AstÄƒzi merg la cafenea È™i beau o cafea.</em>), apoi apasÄƒ pe buton.
      </p>
      <textarea id="roInput" placeholder="Scrie aici propoziÈ›ia ta Ã®n romÃ¢nÄƒâ€¦"></textarea>

      <div class="btn-row">
        <button id="autoFillBtn">CompleteazÄƒ automat builder-ul</button>
        <button id="clearBtn" class="secondary">CurÄƒÈ›Äƒ tot</button>
      </div>
    </section>

    <!-- PROPOZIÈšIA 1 -->
    <h3 class="section-title">PropoziÈ›ia 1 â€“ pÄƒrÈ›i de vorbire</h3>
    <section class="table-block">
      <div class="table-title">
        <span>PropoziÈ›ia 1 (clauza principalÄƒ)</span>
        <span style="font-size:11px;color:var(--text-soft);">Se poate edita manual</span>
      </div>

      <div id="tableP1" class="table-horizontal">
        <div class="col" data-key="subject">
          <div class="col-header">SUBJECT</div>
          <div class="col-body-label">eu, tu, el/eaâ€¦</div>
          <div class="col-body-main" contenteditable="true">ì €</div>
        </div>

        <div class="col" data-key="time">
          <div class="col-header">TIME</div>
          <div class="col-body-label">azi, mÃ¢ineâ€¦</div>
          <div class="col-body-main" contenteditable="true"></div>
        </div>

        <div class="col" data-key="place">
          <div class="col-header">PLACE</div>
          <div class="col-body-label">acasÄƒ, la È™coalÄƒâ€¦</div>
          <div class="col-body-main" contenteditable="true"></div>
        </div>

        <div class="col" data-key="mod">
          <div class="col-header">MOD</div>
          <div class="col-body-label">cum? (bine, Ã®ncetâ€¦)</div>
          <div class="col-body-main" contenteditable="true"></div>
        </div>

        <div class="col" data-key="object">
          <div class="col-header">OBJECT</div>
          <div class="col-body-label">ce? (cafea, carteâ€¦)</div>
          <div class="col-body-main" contenteditable="true"></div>
        </div>

        <div class="col" data-key="numeral">
          <div class="col-header">NUMERAL</div>
          <div class="col-body-label">una, douÄƒ, treiâ€¦</div>
          <div class="col-body-main" contenteditable="true"></div>
        </div>

        <div class="col" data-key="counter">
          <div class="col-header">COUNTER</div>
          <div class="col-body-label">ê°œ, ê¶Œâ€¦</div>
          <div class="col-body-main" contenteditable="true"></div>
        </div>

        <div class="col" data-key="verb">
          <div class="col-header">VERB</div>
          <div class="col-body-label">ê°€ìš”, ë§ˆì…”ìš”â€¦</div>
          <div class="col-body-main" contenteditable="true">ê°€ìš”</div>
        </div>
              <!-- CONJ / ENDING (P1) -->
      <div class="col" data-key="conjug">
        <div class="col-header">CONJ / ENDING</div>
        <div class="col-body-label">conector, terminaÈ›ie...</div>
        <div class="col-body-main" contenteditable="true">ê·¸ë¦¬ê³ </div>
        <div class="col-body-extra example">ex: ê·¸ë¦¬ê³ , ê·¸ë˜ì„œ, ~ê³ , ~ì•„ì„œ...</div>
      </div>
      </div>
<!-- ===================================================== -->
<!-- PROPOZIÈšIA 2 â€“ CONTINUARE                            -->
<!-- ===================================================== -->
<div class="table-block" id="p2Block">
  <div class="table-title">
    <span>PROPOZIÈšIA 2 â€“ CONTINUARE</span>

    <div class="builder-enable-p2">
      <label>
        <input type="checkbox" id="enableP2" checked />
        <span>ActiveazÄƒ PropoziÈ›ia 2 (continuare / frazÄƒ)</span>
      </label>
    </div>
  </div>

  <!-- Subtitlu mic pentru P2 -->
  <div id="titleP2">
    <span>PropoziÈ›ia 2 (clauza secundarÄƒ)</span>
  </div>

  <!-- TABEL P2 â€“ se completeazÄƒ manual (deocamdatÄƒ) -->
  <div id="tableP2" class="table-horizontal">
    <!-- SUBJECT -->
    <div class="col" data-key="subject">
      <div class="col-header">SUBJECT</div>
      <div class="col-body-label">eu, tu, el/ea...</div>
      <div class="col-body-main"></div>
      <div class="col-body-extra example">ex: ì €, ë‚˜...</div>
    </div>

    <!-- TIME -->
    <div class="col" data-key="time">
      <div class="col-header">TIME</div>
      <div class="col-body-label">azi, mÃ¢ine...</div>
      <div class="col-body-main"></div>
      <div class="col-body-extra example">ex: ì§€ê¸ˆ, ì˜¤ëŠ˜...</div>
    </div>

    <!-- PLACE -->
    <div class="col" data-key="place">
      <div class="col-header">PLACE</div>
      <div class="col-body-label">acasÄƒ, la È™coalÄƒ...</div>
      <div class="col-body-main"></div>
      <div class="col-body-extra example">ex: ì§‘ì—, í•™êµì—...</div>
    </div>

    <!-- MOD -->
    <div class="col" data-key="mod">
      <div class="col-header">MOD</div>
      <div class="col-body-label">cum? (bine, Ã®ncet...)</div>
      <div class="col-body-main"></div>
      <div class="col-body-extra example">ex: ì²œì²œíˆ, ë¹¨ë¦¬...</div>
    </div>

    <!-- OBJECT -->
    <div class="col" data-key="object">
      <div class="col-header">OBJECT</div>
      <div class="col-body-label">ce? (cafea, carte...)</div>
      <div class="col-body-main"></div>
      <div class="col-body-extra example">ex: ì±…, ì»¤í”¼...</div>
    </div>

    <!-- NUMERAL -->
    <div class="col" data-key="numeral">
      <div class="col-header">NUMERAL</div>
      <div class="col-body-label">una, douÄƒ, trei...</div>
      <div class="col-body-main"></div>
      <div class="col-body-extra example">ex: í•œ, ë‘, ì„¸...</div>
    </div>

    <!-- COUNTER -->
    <div class="col" data-key="counter">
      <div class="col-header">COUNTER</div>
      <div class="col-body-label">ê°œ, ê¶Œ...</div>
      <div class="col-body-main"></div>
      <div class="col-body-extra example">ex: ê¶Œ, ê°œ...</div>
    </div>

    <!-- VERB -->
    <div class="col" data-key="verb">
      <div class="col-header">VERB</div>
      <div class="col-body-label">ê°€ìš”, ì™€ìš”...</div>
      <div class="col-body-main"></div>
      <div class="col-body-extra example">ex: ì½ì–´ìš”, ë¨¹ì–´ìš”...</div>
    </div>
          <!-- CONJ / ENDING (P2 â€“ dacÄƒ vrei sÄƒ continui mai departe) -->
      <div class="col" data-key="conjug">
        <div class="col-header">CONJ / ENDING</div>
        <div class="col-body-label">conector, terminaÈ›ie...</div>
        <div class="col-body-main" contenteditable="true"></div>
        <div class="col-body-extra example">ex: ê·¸ë¦¬ê³ , ê·¸ë˜ì„œ, ~ê³ ...</div>
      </div>
  </div>
    <!-- PREVIEW FINAL â€“ FRAZÄ‚ LUNGÄ‚ -->
    <section class="preview-card">
      <div class="preview-title">
        <span>PropoziÈ›ia finalÄƒ Ã®n coreeanÄƒ (P1 + ê·¸ë¦¬ê³  + P2)</span>
      </div>
      <div id="previewSentence" class="preview-sentence">ì € ê°€ìš”</div>
      <div id="previewRo" class="preview-ro">
        (Aici vei vedea propoziÈ›ia finalÄƒ Ã®n coreeanÄƒ, generatÄƒ din sloturi.)
      </div>
    </section>
  </div>
      <script>
(function () {
  // ==============================
  // 0. ELEMENTE DE BAZÄ‚
  // ==============================
  const roInput      = document.getElementById("roInput");
  const autoFillBtn  = document.getElementById("autoFillBtn");
  const clearBtn     = document.getElementById("clearBtn");

  const tableP1      = document.getElementById("tableP1");
  const tableP2      = document.getElementById("tableP2");
  const enableP2Cb   = document.getElementById("enableP2");

  const previewOut   = document.getElementById("previewSentence");

  // pentru nav (Builder / ExerciÈ›ii / LecÈ›ii / Glosar) â€“ simplu
  const screenIds = ["screen-builder", "screen-exercises", "screen-lessons", "screen-glossary"];
  const navIds    = ["navBuilder", "navExercises", "navLessons", "navGlossary"];

  // connectorul curent detectat din propoziÈ›ia romÃ¢neascÄƒ
  let currentConnector = null; // {id, roLabel, koWord, koEnding}


  // ==============================
  // 1. HELPER â€“ normalizare romÃ¢nÄƒ
  // ==============================
  function normalizeRo(text) {
    if (!text) return "";
    let t = text.toLowerCase();

    t = t.replace(/ÅŸ/g, "È™").replace(/Å£/g, "È›");
    t = t.replace(/ÃƒÂ¢/g, "Ã¢").replace(/ÃƒÂ®/g, "Ã®");
    t = t.replace(/[.,!?;:]/g, " ");
    t = t.replace(/\s+/g, " ").trim();
    return t;
  }

  // ==============================
  // 2. DETECTARE CONECTOR (â€È™iâ€, â€iarâ€, â€apoiâ€â€¦)
  // ==============================
  const CONNECTORS = [
    {
      id: "si",
      roRe: /\b(È™i|si)\b/,
      roLabel: "È™i",
      koWord: "ê·¸ë¦¬ê³ ",
      koEnding: "ê³ "       // pentru â€merg È™i citescâ€ â†’ stem + ê³ 
    },
    {
      id: "iar",
      roRe: /\biar\b/,
      roLabel: "iar",
      koWord: "ê·¸ë¦¬ê³ ",
      koEnding: "ê³ "
    },
    {
      id: "apoi",
      roRe: /\bapoi\b/,
      roLabel: "apoi",
      koWord: "ê·¸ë¦¬ê³  ë‚˜ì„œ",
      koEnding: "ê³  ë‚˜ì„œ"
    },
    {
      id: "dupaAceea",
      roRe: /\bdup[Äƒa]\s+aceea\b/,
      roLabel: "dupÄƒ aceea",
      koWord: "ê·¸ ë‹¤ìŒì—",
      koEnding: "ê³  ë‚˜ì„œ"
    },
    {
      id: "dar",
      roRe: /\bdar\b/,
      roLabel: "dar",
      koWord: "í•˜ì§€ë§Œ",
      koEnding: null
    },
    {
      id: "insa",
      roRe: /\bÃ®ns[Äƒa]\b|\binsa\b/,
      roLabel: "Ã®nsÄƒ",
      koWord: "í•˜ì§€ë§Œ",
      koEnding: null
    }
  ];

  function detectConnector(fullTextNorm) {
    for (const c of CONNECTORS) {
      if (c.roRe.test(fullTextNorm)) return c;
    }
    return null;
  }

  // ==============================
  // 3. SPLIT: RO â†’ P1 + P2
  // ==============================
  function splitRomanianSentence(fullText) {
    const norm = normalizeRo(fullText);
    if (!norm) {
      return { p1: "", connector: null, p2: "" };
    }

    const connector = detectConnector(norm);
    if (!connector) {
      return { p1: fullText.trim(), connector: null, p2: "" };
    }

    // tÄƒiem dupÄƒ primul cuvÃ¢nt-cheie (È™i / iar / etc.)
    const idx = norm.search(connector.roRe);
    if (idx === -1) {
      return { p1: fullText.trim(), connector: null, p2: "" };
    }

    // reconstruim P1 / P2 aproximativ dupÄƒ poziÈ›ii
    const raw = fullText.replace(/\s+/g, " ");
    // simplu: folosim regex Ã®ncÄƒ o datÄƒ pe textul original
    const re = connector.roRe;
    const match = raw.toLowerCase().match(re);
    if (!match) {
      return { p1: fullText.trim(), connector, p2: "" };
    }

    const cutIndex = raw.toLowerCase().indexOf(match[0]);
    const before   = raw.slice(0, cutIndex).trim();
    const after    = raw.slice(cutIndex + match[0].length).trim();

    return {
      p1: before || fullText.trim(),
      connector,
      p2: after
    };
  }

  // ==============================
  // 4. REGULI RO â†’ SLOTURI (SUBJECT / TIME / PLACE / â€¦ / VERB)
  // ==============================
  const RO_RULES = {
    subject: [
      { re: /\beu\b/, value: "ì €" },
      { re: /\btu\b/, value: "ë„ˆ" }
    ],
    time: [
      { re: /\bazi\b|astÄƒzi\b/, value: "ì˜¤ëŠ˜" },
      { re: /\bmÃ¢ine\b/, value: "ë‚´ì¼" },
      { re: /\bieri\b/, value: "ì–´ì œ" },
      { re: /\bacum\b/, value: "ì§€ê¸ˆ" }
    ],
    place: [
      { re: /\bacas[Äƒa]\b/, value: "ì§‘" },
      { re: /la\s+piaÈ›[Äƒa]|piat[Äƒa]\b/, value: "ì‹œì¥" },
      { re: /cafenea|cafene[al]/, value: "ì¹´í˜" },
      { re: /la\s+È™coal[Äƒa]|la\s+scoala|È™coal[Äƒa]\b|scoala\b/, value: "í•™êµ" }
    ],
    mod: [
      { re: /\bbine\b|frumos\b|ok\b/, value: "ì˜" },
      { re: /Ã®ncet|incet/, value: "ì²œì²œíˆ" },
      { re: /repede|rapid/, value: "ë¹¨ë¦¬" }
    ],
    object: [
      { re: /cafea/, value: "ì»¤í”¼" },
      { re: /carte|c[Äƒa]rÈ›i|c[Äƒa]rti\b/, value: "ì±…" },
      { re: /\bap[Äƒa]\b/, value: "ë¬¼" }
    ],
    numeral: [
      { re: /\bo\s+carte\b|\bo\s+cafenea\b|\bo\s+cafea\b/, value: "í•œ" },
      { re: /\bdou[Äƒa]\s+carÈ›i|dou[Äƒa]\s+cafele/, value: "ë‘" },
      { re: /\btrei\s+carÈ›i|trei\s+cafele/, value: "ì„¸" }
    ],
    counter: [
      { re: /carte|c[Äƒa]rÈ›i|c[Äƒa]rti\b/, value: "ê¶Œ" },
      { re: /cafea|ap[Äƒa]\b|ceai|m[Äƒa]ncare/, value: "ê°œ" }
    ],
    // VERB â€“ base form (infinitiv coreean)
    verb: [
      { re: /merg\b|a merge|sÄƒ merg|sa merg/, value: "ê°€ë‹¤" },
      { re: /citesc|a citi|sÄƒ citesc|sa citesc/, value: "ì½ë‹¤" },
      { re: /beau\b|a bea|sÄƒ beau|sa beau/, value: "ë§ˆì‹œë‹¤" },
      { re: /m[Äƒa]nÃ¢nc|mananc|a m[Äƒa]nca/, value: "ë¨¹ë‹¤" }
    ]
  };

  function matchSlot(rules, textNorm) {
    if (!rules) return "";
    for (const rule of rules) {
      if (rule.re.test(textNorm)) return rule.value;
    }
    return "";
  }

  function parseRomanianToSlots(text) {
    const n = normalizeRo(text);
    if (!n) {
      return {
        subject: "", time: "", place: "", mod: "",
        object: "", numeral: "", counter: "", verb: ""
      };
    }
    return {
      subject: matchSlot(RO_RULES.subject, n),
      time:    matchSlot(RO_RULES.time,    n),
      place:   matchSlot(RO_RULES.place,   n),
      mod:     matchSlot(RO_RULES.mod,     n),
      object:  matchSlot(RO_RULES.object,  n),
      numeral: matchSlot(RO_RULES.numeral, n),
      counter: matchSlot(RO_RULES.counter, n),
      verb:    matchSlot(RO_RULES.verb,    n)
    };
  }

  // ==============================
  // 5. VERBE: bazÄƒ â†’ prezent politicos
  // ==============================
  const VERB_INFO = {
    "ê°€ë‹¤":  { stem: "ê°€",  polite: "ê°€ìš”" },
    "ì½ë‹¤":  { stem: "ì½", polite: "ì½ì–´ìš”" },
    "ë§ˆì‹œë‹¤":{ stem: "ë§ˆì‹œ", polite: "ë§ˆì…”ìš”" },
    "ë¨¹ë‹¤":  { stem: "ë¨¹", polite: "ë¨¹ì–´ìš”" }
  };

  function getVerbInfo(base) {
    if (!base) return null;
    if (VERB_INFO[base]) return VERB_INFO[base];

    // fallback foarte simplu: scoatem â€ë‹¤â€ È™i adÄƒugÄƒm â€ì–´ìš”â€
    if (base.endsWith("ë‹¤")) {
      const stem = base.slice(0, -1);
      return { stem, polite: stem + "ì–´ìš”" };
    }
    return { stem: base, polite: base };
  }

  // ==============================
  // 6. APLICÄ‚ SLOTURI ÃN TABELE
  // ==============================
  function setCol(tableEl, key, value) {
    if (!tableEl || !value) return;
    const cell = tableEl.querySelector('.col[data-key="' + key + '"] .col-body-main');
    if (cell) cell.textContent = value;
  }

  function clearTable(tableEl) {
    if (!tableEl) return;
    tableEl.querySelectorAll(".col-body-main").forEach(el => {
      el.textContent = "";
    });
  }

  function applySlotsToTable(tableEl, slots) {
    if (!tableEl || !slots) return;
    setCol(tableEl, "subject", slots.subject);
    setCol(tableEl, "time",    slots.time);
    setCol(tableEl, "place",   slots.place);
    setCol(tableEl, "mod",     slots.mod);
    setCol(tableEl, "object",  slots.object);
    setCol(tableEl, "numeral", slots.numeral);
    setCol(tableEl, "counter", slots.counter);
    setCol(tableEl, "verb",    slots.verb); // infinitiv (ê°€ë‹¤, ì½ë‹¤â€¦)
  }

  // ==============================
  // 7. CONSTRUIRE PROPOZIÈšIE DIN TABEL
  // ==============================
  function pick(tableEl, key) {
    if (!tableEl) return "";
    const cell = tableEl.querySelector('.col[data-key="' + key + '"] .col-body-main');
    return cell ? cell.textContent.trim() : "";
  }

  function buildObjectChunk(obj, numeral, counter) {
    if (obj && numeral && counter) return obj + " " + numeral + " " + counter;
    return obj || "";
  }

  function buildClauseFromTable(tableEl, options) {
    if (!tableEl) return "";

    const subject = pick(tableEl, "subject");
    const time    = pick(tableEl, "time");
    const place   = pick(tableEl, "place");
    const mod     = pick(tableEl, "mod");
    const object  = pick(tableEl, "object");
    const numeral = pick(tableEl, "numeral");
    const counter = pick(tableEl, "counter");
    const verbBase= pick(tableEl, "verb");

    const objChunk = buildObjectChunk(object, numeral, counter);

    const vInfo = getVerbInfo(verbBase);
    let verbForm = "";
    if (vInfo) {
      if (options && options.ending) {
        // ex: stem + "ê³ "
        const end = options.ending.replace(/^~/, "");
        verbForm = vInfo.stem + end;
      } else {
        verbForm = vInfo.polite;
      }
    }

    const parts = [subject, time, place, mod, objChunk, verbForm].filter(Boolean);
    return parts.join(" ");
  }

  function rebuildFinalSentence() {
    if (!tableP1) return;
    const useP2 = enableP2Cb && enableP2Cb.checked && tableP2;

    let clause1 = "";
    let clause2 = "";

    if (currentConnector && currentConnector.koEnding) {
      // tip â€È™iâ€ â†’ stem + ê³  Ã®n P1
      clause1 = buildClauseFromTable(tableP1, { ending: currentConnector.koEnding });
    } else {
      clause1 = buildClauseFromTable(tableP1, null);
    }

    if (useP2) {
      clause2 = buildClauseFromTable(tableP2, null);
    }

    let sentence = clause1;

    if (useP2 && clause2) {
      if (currentConnector) {
        if (currentConnector.koEnding) {
          // ending deja lipit de verb1: â€ê°€ê³  ì½ì–´ìš”â€
          sentence = clause1 + " " + clause2;
        } else if (currentConnector.koWord) {
          // conector de tip cuvÃ¢nt: â€ê°€ìš” í•˜ì§€ë§Œ â€¦â€
          sentence = clause1 + " " + currentConnector.koWord + " " + clause2;
        } else {
          sentence = clause1 + " " + clause2;
        }
      } else {
        sentence = clause1 + " " + clause2;
      }
    }

    if (previewOut) {
      previewOut.textContent = sentence.trim();
    }
  }

  // ==============================
  // 8. AUTOFILL DIN TEXTUL ROMÃ‚NESC
  // ==============================
  function handleAutoFill() {
    const text = roInput ? roInput.value.trim() : "";
    if (!text) {
      clearTable(tableP1);
      clearTable(tableP2);
      currentConnector = null;
      rebuildFinalSentence();
      return;
    }

    // 1) split P1 / P2 + connector
    const split = splitRomanianSentence(text);
    currentConnector = split.connector;

    // 2) parse pentru P1 / P2
    const slots1 = parseRomanianToSlots(split.p1);
    const slots2 = split.p2 ? parseRomanianToSlots(split.p2) : null;

    clearTable(tableP1);
    clearTable(tableP2);

    applySlotsToTable(tableP1, slots1);
    if (slots2 && enableP2Cb && enableP2Cb.checked) {
      applySlotsToTable(tableP2, slots2);
    }

    // 3) conector Ã®n cÄƒsuÈ›a â€CONJ / ENDINGâ€
    const conjCell = tableP1
      ? tableP1.querySelector('.col[data-key="conj"] .col-body-main')
      : null;

    if (conjCell) {
      if (currentConnector) {
        if (currentConnector.koEnding) {
          // ex: â€ê·¸ë¦¬ê³  / ~ê³ â€
          const end = currentConnector.koEnding.replace(/^~/, "");
          conjCell.textContent = (currentConnector.koWord || "") +
            (end ? " / ~" + end : "");
        } else if (currentConnector.koWord) {
          conjCell.textContent = currentConnector.koWord;
        } else {
          conjCell.textContent = "";
        }
      } else {
        conjCell.textContent = "";
      }
    }

    // 4) reconstruim propoziÈ›ia finalÄƒ
    rebuildFinalSentence();
  }

  function handleClear() {
    if (roInput) roInput.value = "";
    clearTable(tableP1);
    clearTable(tableP2);
    currentConnector = null;
    if (previewOut) previewOut.textContent = "";
  }

  // ==============================
  // 9. NAV â€“ schimbare ecrane
  // ==============================
  function showScreen(screenId) {
    screenIds.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      el.classList.toggle("active", id === screenId);
    });

    navIds.forEach(id => {
      const btn = document.getElementById(id);
      if (!btn) return;
      btn.classList.toggle("active", ("screen-" + id.slice(3).toLowerCase()) === screenId);
    });
  }

  // ==============================
  // 10. INIT
  // ==============================
  document.addEventListener("DOMContentLoaded", () => {
    // butoane autofill / clear
    if (autoFillBtn) autoFillBtn.addEventListener("click", handleAutoFill);
    if (clearBtn)    clearBtn.addEventListener("click", handleClear);

    // checkbox PropoziÈ›ia 2
    if (enableP2Cb && tableP2) {
      enableP2Cb.addEventListener("change", () => {
        const block = document.getElementById("blockP2") || tableP2.closest("section");
        if (block) {
          if (enableP2Cb.checked) block.classList.remove("hidden");
          else block.classList.add("hidden");
        }
        rebuildFinalSentence();
      });
    }

    // nav bottom (dacÄƒ existÄƒ)
    const builderBtn   = document.getElementById("navBuilder");
    const exBtn        = document.getElementById("navExercises");
    const lessonsBtn   = document.getElementById("navLessons");
    const glossBtn     = document.getElementById("navGlossary");

    if (builderBtn)  builderBtn.addEventListener("click", () => showScreen("screen-builder"));
    if (exBtn)       exBtn.addEventListener("click", () => showScreen("screen-exercises"));
    if (lessonsBtn)  lessonsBtn.addEventListener("click", () => showScreen("screen-lessons"));
    if (glossBtn)    glossBtn.addEventListener("click", () => showScreen("screen-glossary"));

    // implicit: Builder
    showScreen("screen-builder");
  });
})();
</script>
</body>
</html>
      
