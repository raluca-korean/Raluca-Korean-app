<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Raluca Korean â€“ Builder Multi-Clause Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root{
      --bg1:#dff3ff;
      --bg2:#ffe9ff;
      --bg3:#f4fffc;
      --bg4:#e8f0ff;

      --accent:#7b5dff;
      --card-bg:#ffffffcc;
      --text-main:#2f343b;
      --text-soft:#7a8088;
      --border:#e1d7c7;
    }

    *{box-sizing:border-box;}

    body{
      margin:0;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      color:var(--text-main);
      background:linear-gradient(120deg,var(--bg1),var(--bg2),var(--bg3),var(--bg4));
      background-size:380% 380%;
      animation:bgFlow 28s ease-in-out infinite;
    }
    @keyframes bgFlow{
      0%{background-position:0% 50%;}
      50%{background-position:100% 50%;}
      100%{background-position:0% 50%;}
    }

    .app{
      max-width:1040px;
      margin:0 auto;
      padding:18px 14px 80px;
    }

    .rk-header{
      position:relative;
      padding:12px 16px 16px;
      border-radius:26px;
      background:linear-gradient(120deg,#6fb8ff,#a774ff,#ff7fd1);
      color:#fff;
      box-shadow:0 18px 45px rgba(77,93,255,0.4);
    }
    .rk-header-main{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .rk-header-main h1{
      margin:0;
      font-size:20px;
      font-weight:900;
      letter-spacing:0.06em;
      text-transform:uppercase;
    }
    .rk-badge{
      font-size:11px;
      font-weight:600;
      padding:4px 9px;
      border-radius:999px;
      background:rgba(255,255,255,0.18);
      border:1px solid rgba(255,255,255,0.4);
    }
    #subtitle{
      margin:8px 0 0;
      font-size:12px;
      opacity:0.95;
    }

    .card{
      margin-top:16px;
      padding:16px 18px 18px;
      border-radius:22px;
      background:var(--card-bg);
      backdrop-filter:blur(16px);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 18px 40px rgba(0,0,0,0.12);
    }
    .card h2{
      margin:0 0 8px;
      font-size:16px;
      font-weight:800;
      letter-spacing:0.03em;
    }

    textarea{
      width:100%;
      border-radius:16px;
      border:1px solid var(--border);
      padding:10px 12px;
      font-size:14px;
      resize:vertical;
      min-height:70px;
      color:var(--text-main);
      background:#fff;
    }
    textarea:focus{
      outline:none;
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.9),
        0 0 0 3px rgba(149,120,255,0.5);
      border-color:rgba(149,120,255,0.7);
    }

    .btn-row{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    button{
      border:none;
      border-radius:999px;
      padding:8px 16px;
      font-size:12px;
      font-weight:800;
      cursor:pointer;
      color:#fff;
      background:linear-gradient(135deg,#6b8cff,#9b6bff);
      box-shadow:
        0 10px 24px rgba(108,110,210,0.4),
        0 0 0 1px rgba(255,255,255,0.7) inset;
      transition:transform .12s ease, box-shadow .12s ease, filter .12s ease;
    }
    button.secondary{
      background:linear-gradient(135deg,#ff9a6c,#ff5f8c);
    }
    button:hover{
      transform:translateY(-1px);
      box-shadow:0 12px 26px rgba(0,0,0,0.18);
      filter:brightness(1.03);
    }
    button:active{
      transform:translateY(1px) scale(0.98);
      box-shadow:0 6px 16px rgba(0,0,0,0.25);
      filter:brightness(0.97);
    }

    .section-title{
      margin-top:18px;
      margin-bottom:6px;
      font-size:13px;
      font-weight:800;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:#4b607d;
    }

    .table-block{
      margin-top:10px;
      padding:10px 10px 12px;
      border-radius:20px;
      background:var(--card-bg);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 14px 30px rgba(0,0,0,0.1);
    }
    .table-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:12px;
      font-weight:800;
      color:var(--text-soft);
      margin-bottom:6px;
    }
    .table-horizontal{
      display:flex;
      gap:8px;
      overflow-x:auto;
      padding-bottom:4px;
    }

    .col{
      min-width:110px;
      max-width:150px;
      flex:0 0 auto;
      border-radius:16px;
      padding:7px 7px 9px;
      background:radial-gradient(circle at top left,#fdfbf7,#f2ebde);
      border:1px solid #e2d7c8;
      box-shadow:0 10px 22px rgba(95,78,58,0.16);
    }
    .col-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:4px;
      font-size:10px;
      font-weight:900;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:#7b5dff;
      border-bottom:1px solid rgba(208,196,255,0.8);
      padding-bottom:2px;
      margin-bottom:3px;
    }
    .col-header::before{
      content:"";
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:16px;
      height:16px;
      border-radius:6px;
      background:#fff;
      font-size:11px;
      box-shadow:0 1px 3px rgba(0,0,0,0.06);
    }
    .col[data-key="subject"] .col-header::before{content:"ğŸ‘¤";}
    .col[data-key="time"]    .col-header::before{content:"â°";}
    .col[data-key="place"]   .col-header::before{content:"ğŸ“";}
    .col[data-key="mod"]     .col-header::before{content:"âœ¨";}
    .col[data-key="object"]  .col-header::before{content:"ğŸ¯";}
    .col[data-key="numeral"] .col-header::before{content:"#ï¸âƒ£";}
    .col[data-key="counter"] .col-header::before{content:"ğŸ”¢";}
    .col[data-key="verb"]    .col-header::before{content:"ğŸš€";}
    .col[data-key="conj"]    .col-header::before{content:"ğŸ”—";}

    .col-body-label{
      font-size:10px;
      color:#938777;
      margin-bottom:1px;
    }
    .col-body-main{
      font-size:15px;
      font-weight:900;
      min-height:1.4em;
    }
    .col-body-main[contenteditable="true"]{
      outline:none;
      cursor:text;
    }
    .col-body-main:focus{
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.8),
        0 0 0 2px rgba(149,120,255,0.7);
      border-radius:6px;
    }

    .col-body-extra.example{
      margin-top:2px;
      font-size:10px;
      color:#b09b83;
    }

    .preview-card{
      margin-top:14px;
      padding:12px 14px;
      border-radius:20px;
      background:var(--card-bg);
      border:1px solid rgba(255,255,255,0.7);
      box-shadow:0 16px 32px rgba(0,0,0,0.12);
    }
    .preview-title{
      font-size:12px;
      font-weight:900;
      color:#4b607d;
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:6px;
    }
    .preview-sentence{
      font-size:22px;
      font-weight:900;
      line-height:1.6;
      margin-bottom:4px;
      word-break:keep-all;
    }
    .preview-ro{
      font-size:12px;
      color:var(--text-soft);
    }

    .hint{
      margin-top:6px;
      font-size:11px;
      color:var(--text-soft);
      line-height:1.4;
    }
    code.k{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      background: rgba(255,255,255,0.7);
      border: 1px solid rgba(0,0,0,0.06);
      padding: 1px 6px;
      border-radius: 999px;
    }

    @media (max-width:600px){
      .rk-header-main h1{font-size:17px;}
      .col{min-width:95px;}
    }
  </style>
</head>

<body>
  <div class="app">
    <header class="rk-header">
      <div class="rk-header-main">
        <h1>RALUCA KOREAN</h1>
        <span class="rk-badge">Builder â€“ Multi Clause</span>
      </div>
      <p id="subtitle">
        Split pe conectori multipli + P2/P3/P4â€¦ + endings lipite de verb (infinitiv Ã®n tabel).
      </p>
    </header>

    <!-- Input -->
    <section class="card" id="roCard">
      <h2>RomÃ¢nÄƒ / English â†’ CoreeanÄƒ (auto-fill)</h2>
      <div style="margin-bottom:6px;font-size:11px;color:var(--text-soft);display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
        <span>Limba propoziÈ›iei:</span>
        <select id="langSelect" style="padding:2px 8px;border-radius:999px;border:1px solid var(--border);font-size:11px;">
          <option value="ro" selected>RomÃ¢nÄƒ</option>
          <option value="en">English</option>
        </select>
      </div>

      <textarea id="inputText" placeholder="Ex: AstÄƒzi merg la cafenea È™i citesc o carte È™i beau o cafea.
Today I go to the cafe and read a book and drink a coffee."></textarea>

      <div class="btn-row">
        <button id="autoFillBtn">CompleteazÄƒ automat builder-ul</button>
        <button id="clearBtn" class="secondary">CurÄƒÈ›Äƒ tot</button>
      </div>

      <div class="hint">
        Reguli de bazÄƒ:
        <br>â€¢ <b>È™i / and</b> â†’ <code class="k">-ê³ </code> (lipit de verbul dinainte).
        <br>â€¢ <b>dar / but</b> â†’ <code class="k">-ì§€ë§Œ</code>
        <br>â€¢ <b>pentru cÄƒ / because</b> â†’ <code class="k">-ì–´ì„œ</code> (poÈ›i schimba manual la <code class="k">-ì•„ì„œ</code>)
        <br>â€¢ <b>dacÄƒ / if</b> â†’ <code class="k">-(ìœ¼)ë©´</code>
        <br>â€¢ <b>cÃ¢nd / atunci cÃ¢nd / when</b> â†’ <code class="k">-(ìœ¼)ã„¹ ë•Œ</code>
        <br>â€¢ <b>ca sÄƒ / in order to / to</b> â†’ <code class="k">-(ìœ¼)ë ¤ê³ </code>
      </div>
    </section>

    <h3 class="section-title">Builder (clauze)</h3>
    <div id="clausesHost"></div>

    <!-- Preview -->
    <section class="preview-card">
      <div class="preview-title">
        <span>PropoziÈ›ia finalÄƒ Ã®n coreeanÄƒ</span>
      </div>
      <div id="previewSentence" class="preview-sentence">ì € ê°€ìš”</div>
      <div id="previewInfo" class="preview-ro"></div>
    </section>
  </div>

  <script>
  (function () {

    // =========================
    // A) Normalizare text
    // =========================
    function normalizeText(text) {
      if (!text) return "";
      let t = text.toLowerCase();
      t = t.replace(/ÅŸ/g, "È™").replace(/Å£/g, "È›");
      t = t.replace(/[.,!?;:]/g, " ");
      t = t.replace(/\s+/g, " ").trim();
      return t;
    }

    // =========================
    // B) Conectori RO/EN -> KO
    // (IMPORTANT: aici avem ending-uri vs conectori separaÈ›i)
    // =========================
    const CONNECTOR_MAP = [
      // RO (mai lungi primele)
      { keys: ["atunci cÃ¢nd", "cand", "cÃ¢nd"], type: "ending", ko: "-(ìœ¼)ã„¹ ë•Œ" },
      { keys: ["deÈ™i", "desi", "although", "even though"], type: "ending", ko: "-ì§€ë§Œ" }, // simplificat
      { keys: ["pentru cÄƒ", "pentru ca", "fiindcÄƒ", "fiindca", "because"], type: "ending", ko: "-ì–´ì„œ" },
      { keys: ["ca sÄƒ", "ca sa", "pentru a", "in order to", "to"], type: "ending", ko: "-(ìœ¼)ë ¤ê³ " },
      { keys: ["dacÄƒ", "daca", "if"], type: "ending", ko: "-(ìœ¼)ë©´" },
      { keys: ["dar", "but"], type: "ending", ko: "-ì§€ë§Œ" },
      { keys: ["È™i", "si", "and"], type: "ending", ko: "-ê³ " },

      // conectori separaÈ›i (dacÄƒ user vrea sÄƒ-i scrie manual Ã®n celulÄƒ)
      // (nu Ã®i punem automat din text, ca sÄƒ nu stricÄƒm sensul)
    ];

    function findConnectorToken(textNorm) {
      // returneazÄƒ match-ul cel mai lung posibil
      for (const item of CONNECTOR_MAP) {
        for (const k of item.keys) {
          // conector ca "word boundary" aproximativ
          // ex: " È™i " / " and "
          const re = new RegExp("(^|\\s)" + escapeRegExp(k) + "(\\s|$)", "i");
          const m = textNorm.match(re);
          if (m) return { token: k, ...item };
        }
      }
      return null;
    }

    function escapeRegExp(s) {
      return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    // Split pe MULTIPLE conectori: produce array de clauze + conectori Ã®ntre ele
    function splitIntoChain(raw, lang) {
      const original = (raw || "").replace(/\s+/g, " ").trim();
      const t = normalizeText(original);
      if (!t) return { clauses: [], links: [] };

      // Construim o regex care prinde ORICE conector relevant.
      // Important: ordonÄƒm cheile descrescÄƒtor ca lungime, ca sÄƒ prindÄƒ "atunci cÃ¢nd" Ã®nainte de "cÃ¢nd".
      const allKeys = CONNECTOR_MAP.flatMap(x => x.keys);
      const uniq = Array.from(new Set(allKeys));
      uniq.sort((a,b) => b.length - a.length);

      const alternation = uniq.map(escapeRegExp).join("|");
      const re = new RegExp("\\s(" + alternation + ")\\s", "ig");

      // Split pÄƒstrÃ¢nd delimiter-ul
      const parts = [];
      let lastIndex = 0;
      let m;
      while ((m = re.exec(t)) !== null) {
        const before = t.slice(lastIndex, m.index).trim();
        const token  = (m[1] || "").trim();
        if (before) parts.push({ kind: "clause", text: before });
        parts.push({ kind: "conn", text: token });
        lastIndex = m.index + m[0].length;
      }
      const tail = t.slice(lastIndex).trim();
      if (tail) parts.push({ kind: "clause", text: tail });

      // Acum transformÄƒm Ã®n chain: clauses[] È™i links[] (link[i] este conector Ã®ntre clause[i] È™i clause[i+1])
      const clauses = [];
      const links = [];
      for (let i=0; i<parts.length; i++) {
        if (parts[i].kind === "clause") clauses.push(parts[i].text);
        if (parts[i].kind === "conn")   links.push(parts[i].text);
      }

      // DacÄƒ avem conectori dar clauze lipsÄƒ (edge case), curÄƒÈ›Äƒm
      while (links.length >= clauses.length) links.pop();

      // MapÄƒm fiecare link la KO recomandat
      const linkObjs = links.map(tok => {
        const mapped = CONNECTOR_MAP.find(x => x.keys.includes(tok));
        if (!mapped) return { raw: tok, type: "ending", ko: "-ê³ " };
        return { raw: tok, type: mapped.type, ko: mapped.ko };
      });

      return { clauses, links: linkObjs };
    }

    // =========================
    // C) Reguli minime RO/EN -> sloturi
    // (extensibile)
    // =========================
    const RO_RULES = {
      subject: [
        { re: /\beu\b/, value: "ì €" },
        { re: /\btu\b/, value: "ë„ˆ" },
        { re: /\bnoi\b/, value: "ìš°ë¦¬" },
      ],
      time: [
        { re: /\bazi\b|\bastÄƒzi\b/, value: "ì˜¤ëŠ˜" },
        { re: /\bmÃ¢ine\b/, value: "ë‚´ì¼" },
        { re: /\bieri\b/, value: "ì–´ì œ" },
        { re: /\bacum\b/, value: "ì§€ê¸ˆ" },
      ],
      place: [
        { re: /\bacas[Äƒa]\b/, value: "ì§‘" },
        { re: /pia[tÈ›]Äƒ/, value: "ì‹œì¥" },
        { re: /È™coal[Äƒa]|scoala/, value: "í•™êµ" },
        { re: /firm[Äƒa]|serviciu|companie/, value: "íšŒì‚¬" },
        { re: /cafenea/, value: "ì¹´í˜" },
      ],
      mod: [
        { re: /\bbine\b|ok\b/, value: "ì˜" },
        { re: /Ã®ncet|incet/, value: "ì²œì²œíˆ" },
        { re: /repede|rapid/, value: "ë¹¨ë¦¬" },
        { re: /mult/, value: "ë§ì´" },
      ],
      object: [
        { re: /cafea/, value: "ì»¤í”¼" },
        { re: /\bap[Äƒa]\b/, value: "ë¬¼" },
        { re: /carte|c[Äƒa]rÈ›/, value: "ì±…" },
        { re: /m[Äƒa]ncare|pr[Äƒa]n|cina|mic\s+dejun/, value: "ìŒì‹" },
        { re: /ceai/, value: "ì°¨" },
      ],
      numeral: [
        { re: /\bo\s+(carte|cafea)\b/, value: "í•œ" },
        { re: /\bdou[Äƒa]\s+/, value: "ë‘" },
        { re: /\btrei\s+/, value: "ì„¸" },
      ],
      counter: [
        { re: /carte|c[Äƒa]rÈ›/, value: "ê¶Œ" },
        { re: /cafea|ap[Äƒa]\b|ceai|m[Äƒa]ncare/, value: "ê°œ" },
      ],
      verb: [
        { re: /merg|a\s+merge|sa\s+merg|sÄƒ\s+merg/, value: "ê°€ë‹¤" },
        { re: /vin|a\s+veni|sa\s+vin|sÄƒ\s+vin/, value: "ì˜¤ë‹¤" },
        { re: /beau|a\s+bea|sa\s+beau|sÄƒ\s+beau/, value: "ë§ˆì‹œë‹¤" },
        { re: /m[Ã¢Äƒ]n[Ã¢a]nc|mananc|a\s+m[Ã¢Äƒ]nca/, value: "ë¨¹ë‹¤" },
        { re: /citesc|a\s+citi|sa\s+citesc|sÄƒ\s+citesc/, value: "ì½ë‹¤" },
        { re: /lucrez|a\s+lucra/, value: "ì¼í•˜ë‹¤" },
      ],
    };

    const EN_RULES = {
      subject: [
        { re: /\bi\b/, value: "ì €" },
        { re: /\byou\b/, value: "ë„ˆ" },
        { re: /\bwe\b/, value: "ìš°ë¦¬" },
      ],
      time: [
        { re: /\btoday\b/, value: "ì˜¤ëŠ˜" },
        { re: /\btomorrow\b/, value: "ë‚´ì¼" },
        { re: /\byesterday\b/, value: "ì–´ì œ" },
        { re: /\bnow\b/, value: "ì§€ê¸ˆ" },
      ],
      place: [
        { re: /\bhome\b|house\b/, value: "ì§‘" },
        { re: /\bmarket\b|mart\b|grocery\b/, value: "ì‹œì¥" },
        { re: /\bschool\b/, value: "í•™êµ" },
        { re: /\bwork\b|company\b|office\b/, value: "íšŒì‚¬" },
        { re: /\bcafe\b|coffee\s+shop\b/, value: "ì¹´í˜" },
      ],
      mod: [
        { re: /\bwell\b|okay\b/, value: "ì˜" },
        { re: /\bslowly\b/, value: "ì²œì²œíˆ" },
        { re: /\bfast\b|quickly\b/, value: "ë¹¨ë¦¬" },
        { re: /\ba lot\b|\bmuch\b/, value: "ë§ì´" },
      ],
      object: [
        { re: /\bcoffee\b/, value: "ì»¤í”¼" },
        { re: /\bwater\b/, value: "ë¬¼" },
        { re: /\bbook\b|books\b/, value: "ì±…" },
        { re: /\bfood\b|meal\b|lunch\b|dinner\b|breakfast\b/, value: "ìŒì‹" },
        { re: /\btea\b/, value: "ì°¨" },
      ],
      numeral: [
        { re: /\ba\s+(book|coffee)\b|\bone\s+/, value: "í•œ" },
        { re: /\btwo\s+/, value: "ë‘" },
        { re: /\bthree\s+/, value: "ì„¸" },
      ],
      counter: [
        { re: /\bbook\b|books\b/, value: "ê¶Œ" },
        { re: /\bcoffee\b|water\b|tea\b|food\b|meal\b/, value: "ê°œ" },
      ],
      verb: [
        { re: /\bgo\b|\bgoing\b/, value: "ê°€ë‹¤" },
        { re: /\bcome\b|\bcoming\b/, value: "ì˜¤ë‹¤" },
        { re: /\bdrink\b|\bdrinking\b/, value: "ë§ˆì‹œë‹¤" },
        { re: /\beat\b|\beating\b/, value: "ë¨¹ë‹¤" },
        { re: /\bread\b|\breading\b/, value: "ì½ë‹¤" },
        { re: /\bwork\b|\bworking\b/, value: "ì¼í•˜ë‹¤" },
      ],
    };

    function matchSlot(rules, textNorm) {
      if (!rules) return "";
      for (const rule of rules) {
        if (rule.re.test(textNorm)) return rule.value;
      }
      return "";
    }

    function parseToSlots(text, lang) {
      const t = normalizeText(text);
      const RULES = (lang === "en") ? EN_RULES : RO_RULES;
      if (!t) return {};

      return {
        subject: matchSlot(RULES.subject, t),
        time:    matchSlot(RULES.time, t),
        place:   matchSlot(RULES.place, t),
        mod:     matchSlot(RULES.mod, t),
        object:  matchSlot(RULES.object, t),
        numeral: matchSlot(RULES.numeral, t),
        counter: matchSlot(RULES.counter, t),
        verb:    matchSlot(RULES.verb, t),
      };
    }

    // =========================
    // D) UI: generare clauze dinamice
    // =========================
    const host = document.getElementById("clausesHost");

    function clauseBlockHTML(idx) {
      const label = (idx === 0) ? "PropoziÈ›ia 1" : ("PropoziÈ›ia " + (idx + 1));
      const id = "tableP" + (idx + 1);

      return `
        <section class="table-block" data-clause-index="${idx}">
          <div class="table-title">
            <span>${label}</span>
            <span style="font-size:11px;color:var(--text-soft);">VERB Ã®n infinitiv â€¢ CONJ = ending sau conector</span>
          </div>

          <div id="${id}" class="table-horizontal">
            ${colHTML("subject","SUBJECT","eu/tu/noiâ€¦", true)}
            ${colHTML("time","TIME","azi/todayâ€¦", true)}
            ${colHTML("place","PLACE","cafenea/cafeâ€¦", true)}
            ${colHTML("mod","MOD","bine/slowlyâ€¦", true)}
            ${colHTML("object","OBJECT","cafea/coffeeâ€¦", true)}
            ${colHTML("numeral","NUMERAL","una/twoâ€¦", true)}
            ${colHTML("counter","COUNTER","ê°œ/ê¶Œâ€¦", true)}
            ${colHTML("verb","VERB","ê°€ë‹¤, ì½ë‹¤â€¦", true)}
            ${colHTML("conj","CONJ / ENDING","-ê³ , -ì§€ë§Œ, -ì–´ì„œ, ê·¸ë¦¬ê³ â€¦", true, "ex: -ê³ , -ì§€ë§Œ, -ì–´ì„œ, -(ìœ¼)ë©´, -(ìœ¼)ã„¹ ë•Œ, -(ìœ¼)ë ¤ê³ , ê·¸ë¦¬ê³ ")}
          </div>
        </section>
      `;
    }

    function colHTML(key, title, hint, editable, example) {
      return `
        <div class="col" data-key="${key}">
          <div class="col-header">${title}</div>
          <div class="col-body-label">${hint}</div>
          <div class="col-body-main" ${editable ? 'contenteditable="true"' : ""}></div>
          ${example ? `<div class="col-body-extra example">${example}</div>` : ""}
        </div>
      `;
    }

    function ensureClauseCount(n) {
      const current = host.querySelectorAll("[data-clause-index]").length;
      if (current === n) return;

      // dacÄƒ trebuie mai multe: adÄƒugÄƒm
      if (current < n) {
        for (let i=current; i<n; i++) {
          host.insertAdjacentHTML("beforeend", clauseBlockHTML(i));
        }
      } else {
        // dacÄƒ trebuie mai puÈ›ine: È™tergem surplus
        for (let i=current-1; i>=n; i--) {
          const el = host.querySelector('[data-clause-index="' + i + '"]');
          if (el) el.remove();
        }
      }
    }

    // =========================
    // E) Citire / scriere celule
    // =========================
    function applySlotsToClause(idx, slots) {
      const tableId = "tableP" + (idx + 1);
      const table = document.getElementById(tableId);
      if (!table || !slots) return;

      const keys = ["subject","time","place","mod","object","numeral","counter","verb"];
      for (const k of keys) {
        if (!slots[k]) continue;
        const cell = table.querySelector('.col[data-key="' + k + '"] .col-body-main');
        if (cell) cell.textContent = slots[k];
      }
    }

    function setConjForClause(idx, conjValue) {
      const tableId = "tableP" + (idx + 1);
      const table = document.getElementById(tableId);
      if (!table) return;
      const cell = table.querySelector('.col[data-key="conj"] .col-body-main');
      if (cell) cell.textContent = conjValue || "";
    }

    function readCell(tableId, key) {
      const cell = document.querySelector("#" + tableId + ' .col[data-key="' + key + '"] .col-body-main');
      return cell ? cell.textContent.trim() : "";
    }

    // =========================
    // F) Logic: lipire ending la verb
    // =========================
    function normalizeEnding(x) {
      let t = (x || "").trim();
      // acceptÄƒm "-ê³ ", "~ê³ ", "ê³ " etc.
      t = t.replace(/^[-~]/, "").trim();
      return t;
    }

    function isStandaloneConnector(x) {
      const t = (x || "").trim();
      // aici sunt cuvinte care rÄƒmÃ¢n SEPARATE (nu se lipesc de verb)
      return ["ê·¸ë¦¬ê³ ","ê·¸ë˜ì„œ","í•˜ì§€ë§Œ","ë˜","ë˜ëŠ”","ê·¸ë˜ë„","ê·¸ëŸ¬ë©´"].includes(t);
    }

    function attachEndingToVerb(verbInf, endingRaw) {
      const v = (verbInf || "").trim();
      if (!v) return "";
      const e = normalizeEnding(endingRaw);
      if (!e) return v;

      // conector separat => NU lipim
      if (isStandaloneConnector(e)) return v;

      // endings tipice pe care le lipim
      // - ê³  / -ì§€ë§Œ / -ì•„ì„œ / -ì–´ì„œ / -(ìœ¼)ë©´ / -(ìœ¼)ã„¹ ë•Œ / -(ìœ¼)ë ¤ê³ 
      // IMPORTANT: verbul trebuie sÄƒ fie infinitiv cu ë‹¤ ca sÄƒ lipim corect
      if (!v.endsWith("ë‹¤")) return v;

      // stem fÄƒrÄƒ "ë‹¤"
      const stem = v.slice(0, -1);

      // mici excepÈ›ii utile
      if (v === "í•˜ë‹¤" && (e === "ì•„ì„œ" || e === "ì–´ì„œ")) return "í•´ì„œ";
      if (v === "í•˜ë‹¤" && e === "ê³ ") return "í•˜ê³ ";
      if (v === "í•˜ë‹¤" && e === "(ìœ¼)ë©´") return "í•˜ë©´";
      if (v === "í•˜ë‹¤" && e === "(ìœ¼)ë ¤ê³ ") return "í•˜ë ¤ê³ ";
      if (v === "í•˜ë‹¤" && e === "(ìœ¼)ã„¹ ë•Œ") return "í•  ë•Œ";

      // endings cu paranteze: -(ìœ¼)ë©´, -(ìœ¼)ã„¹ ë•Œ, -(ìœ¼)ë ¤ê³ 
      if (e === "(ìœ¼)ë©´") return stem + "ë©´";
      if (e === "(ìœ¼)ã„¹ ë•Œ") return stem + "ã„¹ ë•Œ";
      if (e === "(ìœ¼)ë ¤ê³ ") return stem + "ë ¤ê³ ";

      // ending simplu
      return stem + e;
    }

    // construieÈ™te o clauzÄƒ KO dintr-un tabel
    function buildClauseFromTable(idx) {
      const tableId = "tableP" + (idx + 1);

      const subject = readCell(tableId, "subject");
      const time    = readCell(tableId, "time");
      const place   = readCell(tableId, "place");
      const mod     = readCell(tableId, "mod");
      const object  = readCell(tableId, "object");
      const numeral = readCell(tableId, "numeral");
      const counter = readCell(tableId, "counter");
      const verbInf = readCell(tableId, "verb");
      const conjRaw = readCell(tableId, "conj");

      let obj = "";
      if (object && numeral && counter) obj = object + " " + numeral + " " + counter;
      else if (object) obj = object;

      const verbOut = attachEndingToVerb(verbInf, conjRaw);

      // dacÄƒ conj este conector separat (ê·¸ë¦¬ê³  etc.) Ã®l returnÄƒm separat ca "mid"
      const conjNorm = normalizeEnding(conjRaw);
      const mid = isStandaloneConnector(conjNorm) ? conjNorm : "";

      const pieces = [subject, time, place, mod, obj, verbOut].filter(Boolean);
      const clause = pieces.join(" ").trim();

      return { clause, mid, hasAny: clause.length > 0 || mid.length > 0 };
    }

    function rebuildPreview() {
      const blocks = host.querySelectorAll("[data-clause-index]");
      const n = blocks.length;

      const chunks = [];
      for (let i=0; i<n; i++) {
        const c = buildClauseFromTable(i);
        if (!c.hasAny) continue;

        chunks.push(c.clause);

        // mid Ã®ntre i È™i i+1 (doar dacÄƒ e conector separat)
        if (c.mid && i < n-1) chunks.push(c.mid);
      }

      const out = document.getElementById("previewSentence");
      const info = document.getElementById("previewInfo");

      const sentence = (chunks.join(" ").replace(/\s+/g," ").trim()) || "ì € ê°€ìš”";
      out.textContent = sentence;

      info.textContent =
        "NotÄƒ: Ending-urile (ex: -ê³ , -ì§€ë§Œ, -ì–´ì„œ, -(ìœ¼)ë©´, -(ìœ¼)ã„¹ ë•Œ, -(ìœ¼)ë ¤ê³ ) se lipesc de verb doar dacÄƒ verbul este infinitiv (â€¦ë‹¤). " +
        "Conectorii separaÈ›i (ex: ê·¸ë¦¬ê³ /ê·¸ë˜ì„œ/í•˜ì§€ë§Œ) rÄƒmÃ¢n ca È™i cuvinte Ã®ntre clauze.";
    }

    // =========================
    // G) Auto-fill din input (RO/EN) + multi split
    // =========================
    function autoFillFromInput() {
      const input = document.getElementById("inputText");
      const lang = (document.getElementById("langSelect") || {}).value || "ro";
      const raw = (input && input.value) ? input.value : "";
      const chain = splitIntoChain(raw, lang); // {clauses[], links[]}
      const clauses = chain.clauses;
      const links = chain.links; // link[i] Ã®ntre clauses[i] È™i clauses[i+1]

      if (!clauses.length) {
        ensureClauseCount(1);
        rebuildPreview();
        return;
      }

      // avem N clauze -> N blocuri
      ensureClauseCount(clauses.length);

      // umple sloturi
      for (let i=0; i<clauses.length; i++) {
        const slots = parseToSlots(clauses[i], lang);
        applySlotsToClause(i, slots);
      }

      // conectorii se pun Ã®n celula CONJ a clauzei anterioare (i)
      // ex: "merg È™i citesc" -> la P1.conj = "-ê³ "
      for (let i=0; i<links.length; i++) {
        const l = links[i]; // {raw, type, ko}
        setConjForClause(i, l.ko); // ending recomandat
      }

      // ultima clauzÄƒ: dacÄƒ are conj vechi dinainte, Ã®l lÄƒsÄƒm cum e; dar pentru auto-fill Ã®l golim ca sÄƒ nu fie confuz
      setConjForClause(clauses.length - 1, "");

      rebuildPreview();
    }
// ================================
// CONFIG: ai pana la 4 clauze
// ================================
const TABLE_IDS = ["tableP1", "tableP2", "tableP3", "tableP4"];

// ce consideram conectori in input (RO + EN)
// (ordinea conteaza: expresiile mai lungi primele)
const CONNECTORS = [
  { re: /\b(atunci\s+cÃ¢nd|atunci\s+cand)\b/gi, type: "when" },
  { re: /\b(pentru\s+cÄƒ|pentru\s+ca)\b/gi, type: "because" },
  { re: /\b(ca\s+sÄƒ|ca\s+sa)\b/gi, type: "in_order_to" },
  { re: /\b(deÈ™i|desi)\b/gi, type: "although" },
  { re: /\b(dacÄƒ|daca)\b/gi, type: "if" },
  { re: /\b(cÃ¢nd|cand|when)\b/gi, type: "when" },
  { re: /\b(dar|but)\b/gi, type: "but" },
  { re: /\b(È™i|si|and)\b/gi, type: "and" },
  { re: /\b(iar|apoi|then)\b/gi, type: "and" }, // simplificat
];

// mapare conector -> ending coreean (defaulturi simple)
function connectorToEnding(type) {
  switch (type) {
    case "and": return "-ê³ ";
    case "but": return "-ì§€ë§Œ";
    case "because": return "-ì–´ì„œ";     // (mai tarziu faci -ì•„ì„œ/-ì–´ì„œ inteligent)
    case "if": return "-(ìœ¼)ë©´";
    case "when": return "-(ìœ¼)ã„¹ ë•Œ";
    case "in_order_to": return "-(ìœ¼)ë ¤ê³ ";
    case "although": return "-ì§€ë§Œ";    // simplificat (mai tarziu rafinezi)
    default: return "-ê³ ";
  }
}

// ================================
// Split multi: produce clauze + conectorii dintre ele
// Ex: "A and B and C" => clauses:[A,B,C], conns:[and,and]
// ================================
function splitMultiSentence(raw) {
  const text = (raw || "").replace(/\s+/g, " ").trim();
  if (!text) return { clauses: [""], conns: [] };

  // gasim toate potrivirile cu index, ca sa split-uim stabil
  const hits = [];
  for (const c of CONNECTORS) {
    let m;
    while ((m = c.re.exec(text)) !== null) {
      hits.push({ index: m.index, len: m[0].length, type: c.type });
      // evita bucle infinite la regex global
      if (m.index === c.re.lastIndex) c.re.lastIndex++;
    }
    c.re.lastIndex = 0; // reset
  }

  // sortam si eliminam suprapuneri (pastram match-ul cel mai lung / primul)
  hits.sort((a, b) => a.index - b.index || b.len - a.len);
  const filtered = [];
  let lastEnd = -1;
  for (const h of hits) {
    if (h.index >= lastEnd) {
      filtered.push(h);
      lastEnd = h.index + h.len;
    }
  }

  if (filtered.length === 0) return { clauses: [text], conns: [] };

  const clauses = [];
  const conns = [];

  let start = 0;
  for (const h of filtered) {
    const left = text.slice(start, h.index).trim();
    if (left) clauses.push(left);

    conns.push(h.type);
    start = h.index + h.len;
  }

  const tail = text.slice(start).trim();
  if (tail) clauses.push(tail);

  // daca avem mai multi conectori decat clauze-1 (din cauza spatiilor/punctuatiei), normalizam
  while (conns.length > Math.max(0, clauses.length - 1)) conns.pop();

  return { clauses, conns };
}

// ================================
// Clear strict (ca sa nu ramana "ì˜" etc.)
// ================================
function clearTable(tableId) {
  const table = document.getElementById(tableId);
  if (!table) return;
  table.querySelectorAll(".col-body-main").forEach(el => (el.textContent = ""));
}

// seteaza text in celula data-key
function setCell(tableId, key, value) {
  const table = document.getElementById(tableId);
  if (!table) return;
  const cell = table.querySelector(`.col[data-key="${key}"] .col-body-main`);
  if (cell) cell.textContent = value || "";
}

// citeste text din celula data-key
function readCell(tableId, key) {
  const table = document.getElementById(tableId);
  if (!table) return "";
  const cell = table.querySelector(`.col[data-key="${key}"] .col-body-main`);
  return cell ? cell.textContent.trim() : "";
}

// "are continut" (folosit ca sa nu lipim -ê³  daca urmatoarea clauza e goala)
function tableHasAny(tableId) {
  const keys = ["subject","time","place","mod","object","numeral","counter","verb","conj"];
  return keys.some(k => !!readCell(tableId, k));
}
    // =========================
    // H) Clear
    // =========================
    function clearAll() {
      const input = document.getElementById("inputText");
      if (input) input.value = "";

      ensureClauseCount(1);
      const tableId = "tableP1";
      const table = document.getElementById(tableId);
      if (table) {
        table.querySelectorAll(".col-body-main").forEach(el => el.textContent = "");
      }
      // un default minim
      const v = document.querySelector('#tableP1 .col[data-key="verb"] .col-body-main');
      const s = document.querySelector('#tableP1 .col[data-key="subject"] .col-body-main');
      if (s) s.textContent = "ì €";
      if (v) v.textContent = "ê°€ë‹¤";

      rebuildPreview();
    }

    // =========================
    // I) Init + live preview la editare
    // =========================
    function wireLivePreview() {
      document.addEventListener("input", function(e){
        const target = e.target;
        if (!target) return;
        // dacÄƒ editezi orice celulÄƒ din builder, actualizÄƒm preview
        if (target.classList && target.classList.contains("col-body-main")) {
          rebuildPreview();
        }
      });
    }

    function init() {
      ensureClauseCount(1);

      // default iniÈ›ial
      const s = document.querySelector('#tableP1 .col[data-key="subject"] .col-body-main');
      const v = document.querySelector('#tableP1 .col[data-key="verb"] .col-body-main');
      if (s) s.textContent = "ì €";
      if (v) v.textContent = "ê°€ë‹¤";

      document.getElementById("autoFillBtn").addEventListener("click", autoFillFromInput);
      document.getElementById("clearBtn").addEventListener("click", clearAll);

      wireLivePreview();
      rebuildPreview();
    }

    window.addEventListener("DOMContentLoaded", init);
  })();
  </script>
</body>
</html>
