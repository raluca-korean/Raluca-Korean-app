<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Extension Practice — 3 propoziții → 1 frază</title>
  <style>
    :root{
      --bg:#f8eef3;
      --panel:#ffffff;
      --card:#fff7fb;
      --text:#3b2f36;
      --muted:#8f6b7b;
      --accent:#e79ab5;
      --line:#f0d7e2;
      --dash:#e7b9cc;
    }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .wrap{ max-width: 1100px; margin: 0 auto; padding: 26px 16px 40px; }
    h1{ margin:0 0 16px; font-size: 26px; letter-spacing:.2px; }
    .sub{ color: var(--muted); font-size: 13px; margin-bottom: 18px; }

    .grid3{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 18px;
    }
    @media (max-width: 980px){ .grid3{ grid-template-columns:1fr; } }

    .card{
      background: var(--panel);
      border: 1px dashed var(--dash);
      border-radius: 18px;
      padding: 18px 16px 14px;
      box-shadow: 0 10px 22px rgba(0,0,0,.05);
    }
    .ko{ font-size: 22px; line-height: 1.25; text-align:center; }
    .ro{ font-size: 13px; color: var(--muted); text-align:center; margin-top: 6px; }

    .editBox{
      margin-top: 12px;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
    }
    .field{
      display:flex;
      gap:10px;
      align-items:center;
      margin-bottom: 10px;
      flex-wrap:wrap;
    }
    .field label{
      font-size: 12px;
      color: var(--muted);
      min-width: 40px;
    }
    input[type="text"]{
      flex: 1 1 260px;
      background:#fff;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      outline:none;
    }

    .controls{
      margin-top: 12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
      align-items:center;
    }
    select, button{
      background: #fff;
      border: 1px solid var(--line);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      outline:none;
    }
    select{ min-width: 210px; }
    button{
      cursor:pointer;
      border-color: rgba(231,154,181,.65);
      background: rgba(231,154,181,.10);
    }
    button:hover{ background: rgba(231,154,181,.16); }
    button.ghost{
      border-color: var(--line);
      background: #fff;
    }
    button.ghost:hover{ background: rgba(231,154,181,.10); }

    .labelRow{
      margin-top: 10px;
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size: 12px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--card);
    }
    .pill strong{ color: var(--accent); }

    .expanded{
      margin-top: 14px;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px 12px;
    }
    .expanded .ko{ font-size: 22px; font-weight: 600; }
    .expanded .ro{ margin-top: 6px; }

    .combineBlock{
      margin-top: 22px;
      padding: 16px;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
    }
    .combineTitle{
      text-align:center;
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 10px;
    }
    .centerRow{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom: 12px;
    }
    .resultBox{
      background: var(--card);
      border: 2px solid rgba(231,154,181,.55);
      border-radius: 18px;
      padding: 16px 14px;
      text-align:center;
    }
    .copyRow{
      margin-top: 10px;
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .status{ font-size:12px; color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Extension Practice</h1>
    <div class="sub">Scrii 3 propoziții → se completează RO↔KO (din dicționarul lecției) → ADD/MODIFY/CHANGE → COMBINE</div>

    <div class="grid3">
      <!-- CARD 1 -->
      <section class="card" data-card="0">
        <div class="ko" id="baseKo0">—</div>
        <div class="ro" id="baseRo0">—</div>

        <div class="editBox">
          <div class="field">
            <label>KO</label>
            <input id="inKo0" type="text" placeholder="Scrie KO (ex: 비누칠했어요.)" />
          </div>
          <div class="field" style="margin-bottom:0;">
            <label>RO</label>
            <input id="inRo0" type="text" placeholder="Scrie RO (ex: M-am săpunit.)" />
          </div>
          <div class="controls" style="margin-top:10px;">
            <button class="ghost" id="setBase0">Setează ca bază</button>
          </div>
        </div>

        <div class="controls">
          <select id="mode0"></select>
          <select id="opt0"></select>
          <button id="apply0">Aplică</button>
          <button class="ghost" id="reset0">Reset</button>
        </div>

        <div class="labelRow" id="tagRow0"></div>

        <div class="expanded">
          <div class="ko" id="outKo0">—</div>
          <div class="ro" id="outRo0">—</div>
        </div>
      </section>

      <!-- CARD 2 -->
      <section class="card" data-card="1">
        <div class="ko" id="baseKo1">—</div>
        <div class="ro" id="baseRo1">—</div>

        <div class="editBox">
          <div class="field">
            <label>KO</label>
            <input id="inKo1" type="text" placeholder="Scrie KO" />
          </div>
          <div class="field" style="margin-bottom:0;">
            <label>RO</label>
            <input id="inRo1" type="text" placeholder="Scrie RO" />
          </div>
          <div class="controls" style="margin-top:10px;">
            <button class="ghost" id="setBase1">Setează ca bază</button>
          </div>
        </div>

        <div class="controls">
          <select id="mode1"></select>
          <select id="opt1"></select>
          <button id="apply1">Aplică</button>
          <button class="ghost" id="reset1">Reset</button>
        </div>

        <div class="labelRow" id="tagRow1"></div>

        <div class="expanded">
          <div class="ko" id="outKo1">—</div>
          <div class="ro" id="outRo1">—</div>
        </div>
      </section>

      <!-- CARD 3 -->
      <section class="card" data-card="2">
        <div class="ko" id="baseKo2">—</div>
        <div class="ro" id="baseRo2">—</div>

        <div class="editBox">
          <div class="field">
            <label>KO</label>
            <input id="inKo2" type="text" placeholder="Scrie KO" />
          </div>
          <div class="field" style="margin-bottom:0;">
            <label>RO</label>
            <input id="inRo2" type="text" placeholder="Scrie RO" />
          </div>
          <div class="controls" style="margin-top:10px;">
            <button class="ghost" id="setBase2">Setează ca bază</button>
          </div>
        </div>

        <div class="controls">
          <select id="mode2"></select>
          <select id="opt2"></select>
          <button id="apply2">Aplică</button>
          <button class="ghost" id="reset2">Reset</button>
        </div>

        <div class="labelRow" id="tagRow2"></div>

        <div class="expanded">
          <div class="ko" id="outKo2">—</div>
          <div class="ro" id="outRo2">—</div>
        </div>
      </section>
    </div>

    <div class="combineBlock">
      <div class="combineTitle">COMBINE 1 (Propoziția 1 + Propoziția 2)</div>
      <div class="centerRow">
        <span class="pill"><strong>Conector</strong></span>
        <select id="c1"></select>
        <button id="gen12">Generează</button>
      </div>
      <div class="resultBox">
        <div class="ko" id="outKo12">—</div>
        <div class="ro" id="outRo12">—</div>
      </div>
    </div>

    <div class="combineBlock">
      <div class="combineTitle">COMBINE 2 (Rezultatul de sus + Propoziția 3)</div>
      <div class="centerRow">
        <span class="pill"><strong>Conector</strong></span>
        <select id="c2"></select>
        <button id="genFinal">Generează</button>
      </div>

      <div class="resultBox">
        <div class="ko" id="finalKo">—</div>
        <div class="ro" id="finalRo">—</div>
      </div>

      <div class="copyRow">
        <button class="ghost" id="copyKo">Copiază KO</button>
        <button class="ghost" id="copyRo">Copiază RO</button>
        <span class="status" id="status"></span>
      </div>
    </div>
  </div>

<script>
/***********************
 * LECȚIE + REGULI (exemplu)
 * IMPORTANT: Dicționarul RO↔KO se construiește automat din aceste propoziții.
 ***********************/
const LESSON = {
  cards: [
    {
      base: { ko:"비누칠했어요.", ro:"M-am săpunit." },
      add: [
        { label:"ADD 몸에", type:"prefix", outKo:"몸에 비누칠했어요.", outRo:"M-am săpunit pe corp." }
      ],
      modify: [],
      change: []
    },
    {
      base: { ko:"물을 틀었어요.", ro:"Am dat drumul la apă." },
      add: [],
      modify: [
        { label:"MODIFY 따뜻한", type:"replace", find:"물을", repl:"따뜻한 물을", roHint:"apă caldă" }
      ],
      change: []
    },
    {
      base: { ko:"놀랐어요.", ro:"Am fost surprins(ă)." },
      add: [
        { label:"ADD 깜짝", type:"prefix", outKo:"깜짝 놀랐어요.", outRo:"Am fost foarte surprins(ă)." }
      ],
      modify: [],
      change: []
    }
  ]
};

const CONNECTORS_1 = [
  { id:"go", label:"-고 (și)", roJoin:"și" }
];
const CONNECTORS_2 = [
  { id:"so", label:"-아/어/여서 (cauză → rezultat)", roJoin:"așa că" },
  { id:"nikka", label:"-(으)니까 (motiv)", roJoin:"pentru că" },
  { id:"neunde", label:"-(으)ㄴ데 / -는데 (contrast/context)", roJoin:"dar" },
  { id:"deoni", label:"-더니 (după ce...)", roJoin:"și apoi" },
  { id:"before", label:"-기 전에 (înainte de)", roJoin:"înainte să" },
  { id:"ryeomyeon", label:"-(으)려면 (dacă vreau să...)", roJoin:"dacă vreau să" }
];

/***********************
 * UTIL
 ***********************/
const el = (id) => document.getElementById(id);
const norm = (s) => (s||"").trim().replace(/\s+/g," ");
const stripPunct = (s) => (s||"").trim().replace(/[.?!]$/,"");
const keyNorm = (s) => stripPunct(norm(s)).toLowerCase(); // pt RO; KO rămâne ok și cu lowerCase

/***********************
 * DICȚIONAR RO↔KO (offline)
 * - se construiește din base + outKo/outRo din reguli
 ***********************/
const DICT = {
  ro2ko: new Map(),
  ko2ro: new Map()
};

function addPair(ko, ro){
  const kKo = keyNorm(ko);
  const kRo = keyNorm(ro);
  if(kKo && ro) DICT.ko2ro.set(kKo, ro);
  if(kRo && ko) DICT.ro2ko.set(kRo, ko);
}

function buildDictFromLesson(){
  DICT.ro2ko.clear(); DICT.ko2ro.clear();
  LESSON.cards.forEach(c=>{
    if(c.base?.ko && c.base?.ro) addPair(c.base.ko, c.base.ro);
    (c.add||[]).forEach(r=>{
      if(r.outKo && r.outRo) addPair(r.outKo, r.outRo);
    });
    (c.modify||[]).forEach(r=>{
      // modify nu are ro complet => nu adăugăm perechi sigure aici
    });
    (c.change||[]).forEach(r=>{
      if(r.outKo && r.outRo) addPair(r.outKo, r.outRo);
    });
  });
}
buildDictFromLesson();
const STORAGE_KEY = "roko_dict_v1";

function serializeDict(){
  return JSON.stringify({
    pairs: Array.from(DICT.ko2ro.entries()).map(([kKo, ro]) => ({ kKo, ro }))
  });
}

function loadDictFromStorage(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;
    const obj = JSON.parse(raw);
    if(!obj?.pairs?.length) return;

    obj.pairs.forEach(p => {
      if(p?.kKo && p?.ro){
        DICT.ko2ro.set(p.kKo, p.ro);
        // reconstruim ro2ko inversând prin "addPair" ca să normalizeze cheile
        const koGuess = p.kKo; // kKo este deja normalizat
        // nu avem exact KO original, dar e suficient pentru lookup KO->RO.
        // pentru RO->KO vom păstra din lecție + ce adaugi cu addPair (mai jos).
      }
    });
  }catch(e){
    // ignore
  }
}

function saveDictToStorage(){
  try{
    localStorage.setItem(STORAGE_KEY, serializeDict());
  }catch(e){
    // ignore
  }
}
  /***********************
 * STATE + AUTO-FILL CONTROL
 ***********************/
const state = {
  cards: LESSON.cards.map(c => ({
    baseKo: c.base.ko || "",
    baseRo: c.base.ro || "",
    ko: c.base.ko || "",
    ro: c.base.ro || "",
    tag: "BASE",
    lastAuto: null // "ko" sau "ro" (ca să nu rescriem agresiv)
  })),
  combined12: { ko:"", ro:"" },
  final: { ko:"", ro:"" }
};

/***********************
 * RULES (ADD/MODIFY/CHANGE)
 ***********************/
function addHint(ro, hint){
  if(!ro) return ro;
  if(ro.includes(hint)) return ro;
  return ro + ` (hint: ${hint})`;
}

function applyRule(rule, ko, ro){
  let newKo = ko, newRo = ro;

  if(rule.type === "prefix"){
    newKo = rule.outKo;
    newRo = rule.outRo ?? ro;
    return { ok:true, ko:norm(newKo), ro:newRo };
  }

  if(rule.type === "replace"){
    if(newKo.includes(rule.find)){
      newKo = newKo.replace(rule.find, rule.repl);
      if(rule.roHint) newRo = addHint(newRo, rule.roHint);
      return { ok:true, ko:norm(newKo), ro:newRo };
    }
    return { ok:false, ko, ro };
  }

  return { ok:false, ko, ro };
}

/***********************
 * CONNECTOR ENGINE (legat de verb)
 ***********************/
function normalizeKoSentence(s){ return norm(s); }
function stripFinalPunct(s){ return normalizeKoSentence(s).replace(/[.?!]$/,"").trim(); }
function ensurePeriod(ko){
  const t = normalizeKoSentence(ko);
  return /[.?!]$/.test(t) ? t : (t + ".");
}
function splitIntoPrefixAndPredicate(sentenceNoPunct){
  const s = normalizeKoSentence(sentenceNoPunct);
  const parts = s.split(" ");
  if(parts.length === 1) return { prefix:"", pred: parts[0] };
  return { prefix: parts.slice(0,-1).join(" "), pred: parts[parts.length-1] };
}
function analyzePredicate(pred){
  if(pred.endsWith("했어요")) return { kind:"ha_past", stem: pred.slice(0,-3) };
  if(pred.endsWith("았어요")) return { kind:"past", stem: pred.slice(0,-3), aeo:"아", past:"았" };
  if(pred.endsWith("었어요")) return { kind:"past", stem: pred.slice(0,-3), aeo:"어", past:"었" };
  if(pred.endsWith("였어요")) return { kind:"past", stem: pred.slice(0,-3), aeo:"여", past:"였" };

  if(pred.endsWith("해요")) return { kind:"ha_pres", stem: pred.slice(0,-2) };
  if(pred.endsWith("아요")) return { kind:"pres", stem: pred.slice(0,-2) };
  if(pred.endsWith("어요")) return { kind:"pres", stem: pred.slice(0,-2) };
  if(pred.endsWith("여요")) return { kind:"pres", stem: pred.slice(0,-2) };

  if(pred.endsWith("이에요")) return { kind:"cop", stem: pred.slice(0,-2) };
  if(pred.endsWith("예요")) return { kind:"cop", stem: pred.slice(0,-2) };
  if(pred.endsWith("세요")) return { kind:"imp", stem: pred.slice(0,-2) };

  return { kind:"unknown", stem: pred };
}
function joinPrefix(prefix, tail){ return prefix ? (prefix + " " + tail) : tail; }

function toConnective(sentence, connectorId){
  const s = stripFinalPunct(sentence);
  const { prefix, pred } = splitIntoPrefixAndPredicate(s);
  const a = analyzePredicate(pred);

  if(connectorId === "go"){
    if(a.kind === "ha_past" || a.kind === "ha_pres"){
      return prefix ? (prefix + "하고") : (a.stem + "하고");
    }
    if(a.kind === "past" || a.kind === "pres" || a.kind === "imp"){
      return joinPrefix(prefix, a.stem) + "고";
    }
    return joinPrefix(prefix, pred) + "고";
  }

  if(connectorId === "so"){
    if(a.kind === "ha_past" || a.kind === "ha_pres"){
      return prefix ? (prefix + "해서") : (a.stem + "해서");
    }
    if(a.kind === "past"){
      return joinPrefix(prefix, a.stem + a.aeo) + "서";
    }
    if(a.kind === "pres"){
      return joinPrefix(prefix, a.stem) + "서";
    }
    return joinPrefix(prefix, pred) + "서";
  }

  if(connectorId === "nikka"){
    if(a.kind === "ha_past") return prefix ? (prefix + "했으니까") : (a.stem + "했으니까");
    if(a.kind === "ha_pres") return joinPrefix(prefix, a.stem + "하") + "니까";
    if(a.kind === "past") return joinPrefix(prefix, a.stem + a.past) + "으니까";
    if(a.kind === "pres") return joinPrefix(prefix, a.stem) + "니까";
    return joinPrefix(prefix, pred) + "니까";
  }

  if(connectorId === "neunde"){
    if(a.kind === "ha_past") return prefix ? (prefix + "했는데") : (a.stem + "했는데");
    if(a.kind === "ha_pres") return joinPrefix(prefix, a.stem + "하") + "는데";
    if(a.kind === "past") return joinPrefix(prefix, a.stem + a.past) + "는데";
    if(a.kind === "pres") return joinPrefix(prefix, a.stem) + "는데";
    return joinPrefix(prefix, pred) + "는데";
  }

  if(connectorId === "deoni"){
    if(a.kind === "ha_past") return prefix ? (prefix + "했더니") : (a.stem + "했더니");
    if(a.kind === "past") return joinPrefix(prefix, a.stem + a.past) + "더니";
    if(a.kind === "pres") return joinPrefix(prefix, a.stem) + "더니";
    return joinPrefix(prefix, pred) + "더니";
  }

  if(connectorId === "before"){
    if(a.kind === "ha_past" || a.kind === "ha_pres"){
      const baseVerb = joinPrefix(prefix, a.stem + "하");
      return baseVerb + "기 전에";
    }
    if(a.kind === "past" || a.kind === "pres" || a.kind === "imp"){
      return joinPrefix(prefix, a.stem) + "기 전에";
    }
    return joinPrefix(prefix, pred) + "기 전에";
  }

  if(connectorId === "ryeomyeon"){
    if(a.kind === "ha_past" || a.kind === "ha_pres"){
      const baseVerb = joinPrefix(prefix, a.stem + "하");
      return baseVerb + "려면";
    }
    if(a.kind === "past" || a.kind === "pres" || a.kind === "imp"){
      return joinPrefix(prefix, a.stem) + "려면";
    }
    return joinPrefix(prefix, pred) + "려면";
  }

  return s;
}

/***********************
 * UI HELPERS
 ***********************/
function fillModeSelect(i){
  const mode = el("mode"+i);
  mode.innerHTML = "";
  [
    { v:"none", t:"NONE" },
    { v:"add", t:"ADD" },
    { v:"modify", t:"MODIFY" },
    { v:"change", t:"CHANGE" }
  ].forEach(o => mode.appendChild(new Option(o.t, o.v)));
  mode.value = "none";
}

function fillOptionSelect(i){
  const modeVal = el("mode"+i).value;
  const optSel = el("opt"+i);
  optSel.innerHTML = "";

  const card = LESSON.cards[i];
  const list = (modeVal==="add") ? card.add
            : (modeVal==="modify") ? card.modify
            : (modeVal==="change") ? card.change
            : [];

  if(!list.length){
    optSel.appendChild(new Option("— nimic disponibil —", ""));
    optSel.disabled = true;
    el("apply"+i).disabled = true;
  }else{
    list.forEach((r,idx)=> optSel.appendChild(new Option(r.label, String(idx))));
    optSel.disabled = false;
    el("apply"+i).disabled = false;
  }
}

function renderCard(i){
  el("baseKo"+i).textContent = state.cards[i].baseKo || "—";
  el("baseRo"+i).textContent = state.cards[i].baseRo || "—";
  el("outKo"+i).textContent = state.cards[i].ko || "—";
  el("outRo"+i).textContent = state.cards[i].ro || "—";

  const tagRow = el("tagRow"+i);
  tagRow.innerHTML = "";
  const pill = document.createElement("span");
  pill.className = "pill";
  pill.innerHTML = `Status: <strong>${state.cards[i].tag}</strong>`;
  tagRow.appendChild(pill);
}

function fillConnectorSelects(){
  const c1 = el("c1");
  c1.innerHTML = "";
  CONNECTORS_1.forEach((c,idx)=> c1.appendChild(new Option(c.label, String(idx))));
  c1.value = "0";

  const c2 = el("c2");
  c2.innerHTML = "";
  CONNECTORS_2.forEach((c,idx)=> c2.appendChild(new Option(c.label, String(idx))));
  c2.value = "0";
}

/***********************
 * AUTO-TRANSLATE (offline, din dicționar)
 * - dacă găsește pereche, completează automat cealaltă limbă
 * - nu rescrie agresiv: rescrie doar dacă celălalt câmp e gol sau a fost autocompletat ultima dată
 ***********************/
function maybeAutofillFromKo(i){
  const ko = norm(el("inKo"+i).value);
  const k = keyNorm(ko);
  if(!k) return;

  const foundRo = DICT.ko2ro.get(k);
  if(!foundRo) return;

  const roEl = el("inRo"+i);
  const roNow = (roEl.value||"").trim();

  if(!roNow || state.cards[i].lastAuto === "ro"){
    roEl.value = foundRo;
    state.cards[i].lastAuto = "ro";
  }

  // update live preview outputs
  state.cards[i].ko = ko;
  state.cards[i].ro = roEl.value.trim();
  state.cards[i].tag = "LIVE";
  renderCard(i);
  combine12(); combineFinal();
}

function maybeAutofillFromRo(i){
  const ro = (el("inRo"+i).value||"").trim();
  const k = keyNorm(ro);
  if(!k) return;

  const foundKo = DICT.ro2ko.get(k);
  if(!foundKo) return;

  const koEl = el("inKo"+i);
  const koNow = norm(koEl.value);

  if(!koNow || state.cards[i].lastAuto === "ko"){
    koEl.value = foundKo;
    state.cards[i].lastAuto = "ko";
  }

  // update live preview outputs
  state.cards[i].ko = norm(koEl.value);
  state.cards[i].ro = ro;
  state.cards[i].tag = "LIVE";
  renderCard(i);
  combine12(); combineFinal();
}

/***********************
 * COMBINE
 ***********************/
function combine12(){
  const rule = CONNECTORS_1[parseInt(el("c1").value,10)];
  const A = state.cards[0].ko;
  const B = state.cards[1].ko;

  if(!A || !B){
    el("outKo12").textContent = "—";
    el("outRo12").textContent = "—";
    state.combined12 = { ko:"", ro:"" };
    return;
  }

  const Aconn = toConnective(A, rule.id);
  state.combined12.ko = norm(Aconn + " " + stripFinalPunct(B) + ".");
  state.combined12.ro = `${stripPunct(state.cards[0].ro)} ${rule.roJoin} ${stripPunct(state.cards[1].ro)}.`;

  el("outKo12").textContent = state.combined12.ko;
  el("outRo12").textContent = state.combined12.ro;
}

function combineFinal(){
  const rule = CONNECTORS_2[parseInt(el("c2").value,10)];
  const X = state.combined12.ko;
  const C = state.cards[2].ko;

  if(!X || !C){
    el("finalKo").textContent = "—";
    el("finalRo").textContent = "—";
    state.final = { ko:"", ro:"" };
    return;
  }

  const Xconn = toConnective(X, rule.id);
  state.final.ko = ensurePeriod(norm(Xconn + " " + stripFinalPunct(C)));
  state.final.ro = `${stripPunct(state.combined12.ro)} ${rule.roJoin} ${stripPunct(state.cards[2].ro)}.`;

  el("finalKo").textContent = state.final.ko;
  el("finalRo").textContent = state.final.ro;
}

/***********************
 * EVENTS
 ***********************/
function init(){
  for(let i=0;i<3;i++){
    // preset base în input (ca să vezi funcția imediat)
    el("inKo"+i).value = state.cards[i].baseKo || "";
    el("inRo"+i).value = state.cards[i].baseRo || "";

    fillModeSelect(i);
    fillOptionSelect(i);
    renderCard(i);

    // LIVE autofill, ambele sensuri
    el("inKo"+i).addEventListener("input", ()=> maybeAutofillFromKo(i));
    el("inRo"+i).addEventListener("input", ()=> maybeAutofillFromRo(i));

    el("setBase"+i).addEventListener("click", ()=>{
      const ko = norm(el("inKo"+i).value);
      const ro = (el("inRo"+i).value||"").trim();

      state.cards[i].baseKo = ko;
      state.cards[i].baseRo = ro;
      state.cards[i].ko = ko;
      state.cards[i].ro = ro;
      state.cards[i].tag = "BASE";
      state.cards[i].lastAuto = null;

      // adăugăm și în dicționar (ca să se știe pe viitor)
      if(ko && ro) addPair(ko, ro);

      renderCard(i);
      combine12(); combineFinal();
    });

    el("mode"+i).addEventListener("change", ()=> fillOptionSelect(i));

    el("apply"+i).addEventListener("click", ()=>{
      const modeVal = el("mode"+i).value;
      const optIdx = parseInt(el("opt"+i).value,10);
      const card = LESSON.cards[i];

      const list = (modeVal==="add") ? card.add
                : (modeVal==="modify") ? card.modify
                : (modeVal==="change") ? card.change
                : null;

      if(!list || !list[optIdx]) return;

      // luăm propoziția curentă din input (ca să fie mereu “ce ai scris tu”)
      const currentKo = norm(el("inKo"+i).value);
      const currentRo = (el("inRo"+i).value||"").trim();
      if(!currentKo) return;

      const rule = list[optIdx];
      const res = applyRule(rule, currentKo, currentRo);
      if(!res.ok) return;

      // setăm rezultatul în input + state
      el("inKo"+i).value = res.ko;
      el("inRo"+i).value = res.ro;

      state.cards[i].ko = res.ko;
      state.cards[i].ro = res.ro;
      state.cards[i].tag = modeVal.toUpperCase();
      state.cards[i].lastAuto = null;

      // adăugăm perechea rezultată în dicționar dacă e completă
      if(res.ko && res.ro) addPair(res.ko, res.ro);

      renderCard(i);
      combine12(); combineFinal();
    });

    el("reset"+i).addEventListener("click", ()=>{
      el("inKo"+i).value = state.cards[i].baseKo || "";
      el("inRo"+i).value = state.cards[i].baseRo || "";

      state.cards[i].ko = state.cards[i].baseKo || "";
      state.cards[i].ro = state.cards[i].baseRo || "";
      state.cards[i].tag = state.cards[i].baseKo ? "BASE" : "—";
      state.cards[i].lastAuto = null;

      renderCard(i);
      combine12(); combineFinal();
    });
  }

  fillConnectorSelects();

  el("gen12").addEventListener("click", ()=>{ combine12(); combineFinal(); });
  el("genFinal").addEventListener("click", ()=>{ combine12(); combineFinal(); });

  el("copyKo").addEventListener("click", ()=> copyText(state.final.ko, "KO copiat."));
  el("copyRo").addEventListener("click", ()=> copyText(state.final.ro, "RO copiat."));

  combine12(); combineFinal();
}

async function copyText(txt, okMsg){
  try{
    await navigator.clipboard.writeText(txt || "");
    el("status").textContent = okMsg;
    setTimeout(()=> el("status").textContent="", 1200);
  }catch{
    el("status").textContent = "Nu pot copia (browser restrictions).";
  }
}

init();
</script>
</body>
</html>
