<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Builder Universal — Interactiv</title>
  <style>
    :root{
      --bg:#0f172a;
      --panel:#111c3a;
      --card:#0b1226;
      --text:#e5e7eb;
      --muted:#a5b4fc;
      --accent:#fbbf24;
      --line:#233055;
      --ok:#22c55e;
      --warn:#f97316;
      --bad:#ef4444;
    }
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 20% 10%, #1e2a6b 0%, var(--bg) 60%);
      color:var(--text);
    }
    .topnav{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      padding:12px 16px; border-bottom:1px solid var(--line);
      background: rgba(15,23,42,.82);
      position: sticky; top:0; backdrop-filter: blur(8px); z-index:20;
    }
    .brand{ display:flex; flex-direction:column; gap:2px; }
    .brand strong{ font-size:14px; letter-spacing:.2px; }
    .brand span{ font-size:12px; color:#c7d2fe; }
    .navlinks{ display:flex; gap:8px; flex-wrap:wrap; }
    .navlinks a{
      text-decoration:none;
      color: var(--text);
      border:1px solid var(--line);
      background: rgba(11,18,38,.55);
      padding:8px 10px;
      border-radius:12px;
      font-size:13px;
    }
    .navlinks a:hover{ background: rgba(165,180,252,.10); }
    .navlinks a.active{
      border-color: rgba(251,191,36,.55);
      background: rgba(251,191,36,.10);
    }

    header{
      padding:14px 16px; border-bottom:1px solid var(--line);
      background: rgba(15,23,42,.45);
    }
    header h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    header p{ margin:6px 0 0; color:#c7d2fe; font-size:13px; }

    .wrap{ max-width:1200px; margin:0 auto; padding:16px; display:grid; gap:14px; }
    .grid{ display:grid; gap:14px; grid-template-columns: 1.05fr .95fr; }
    @media (max-width: 980px){ .grid{ grid-template-columns:1fr; } }

    .panel{
      background: rgba(17,28,58,.68);
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .panel h2{ margin:0 0 10px; font-size:15px; color:#e0e7ff; }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row > *{ flex: 0 0 auto; }

    select, button, input, textarea{
      background: rgba(11,18,38,.8);
      color: var(--text);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
      outline:none;
    }
    textarea{ width:100%; min-height:72px; resize:vertical; }
    select{ min-width: 220px; }
    button{ cursor:pointer; }
    button.primary{ border-color: rgba(251,191,36,.45); }
    button.primary:hover{ background: rgba(251,191,36,.12); }
    button.ghost:hover{ background: rgba(165,180,252,.10); }
    button.danger{ border-color: rgba(239,68,68,.35); }
    button.danger:hover{ background: rgba(239,68,68,.10); }

    .pill{
      display:inline-flex; gap:8px; align-items:center;
      border:1px solid var(--line);
      border-radius:999px;
      padding:6px 10px;
      background: rgba(11,18,38,.6);
      font-size:12px;
      color:#c7d2fe;
    }
    .pill strong{ color: var(--accent); font-weight:700; }

    .cards{ display:grid; gap:10px; }
    .card{
      background: rgba(11,18,38,.75);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
    }
    .card.clickable{ cursor:pointer; }
    .card.clickable:hover{ background: rgba(165,180,252,.08); }

    .korean{ font-size:20px; line-height:1.25; letter-spacing:.2px; }
    .romanian{ margin-top:6px; font-size:13px; color:#c7d2fe; }

    .meta{ margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .tag{
      font-size:12px; padding:4px 8px; border-radius:999px;
      border:1px solid var(--line);
      color:#e0e7ff;
      background: rgba(35,48,85,.35);
    }
    .tag.ok{ border-color: rgba(34,197,94,.35); color:#bbf7d0; }
    .tag.warn{ border-color: rgba(249,115,22,.35); color:#fed7aa; }
    .tag.bad{ border-color: rgba(239,68,68,.35); color:#fecaca; }
    .tag.active{ border-color: rgba(251,191,36,.55); color:#fde68a; }

    .big{
      border:1px dashed rgba(251,191,36,.55);
      background: rgba(251,191,36,.08);
    }
    .big .korean{ font-size:22px; }

    .divider{ height:1px; background: var(--line); margin:12px 0; }
    .help{ font-size:12px; color:#c7d2fe; margin:8px 0 0; }
    .small{ font-size:12px; color:#c7d2fe; }

    /* Workspace list */
    .step{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:start;
    }
    .stepControls{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .mini{ padding:8px 10px; border-radius:10px; font-size:13px; }
    .copyOk{ color:#bbf7d0; }

    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 980px){ .twoCol{ grid-template-columns:1fr; } }
  </style>
</head>
<body>

  <nav class="topnav">
    <div class="brand">
      <strong>Builder Universal — Interactiv</strong>
      <span>Workspace + Combine din pași + Undo real</span>
    </div>
    <div class="navlinks">
      <!-- Ajustează href-urile la paginile tale reale -->
      <a href="index.html">Home</a>
      <a class="active" href="builder-universal.html">Builder</a>
      <a href="exercises.html">Exercises</a>
      <a href="lessons.html">Lessons</a>
      <a href="glossary.html">Glossary</a>
    </div>
  </nav>

  <header>
    <h1>Construiește & Extinde propoziții</h1>
    <p>Click pe propoziții → intră în Workspace → aplică ADD/MODIFY/CHANGE pe pasul activ → COMBINE</p>
  </header>

  <div class="wrap">
    <div class="grid">

      <!-- LEFT -->
      <section class="panel">
        <h2>1) Set</h2>
        <div class="row">
          <select id="setSelect"></select>
          <button class="ghost mini" id="resetBtn">Reset</button>
          <button class="ghost mini" id="randomBtn">Random</button>
          <span class="pill">Nivel: <strong id="levelLabel">A1</strong></span>
        </div>
        <p class="help">
          Click pe o propoziție din “Bază” ca să o adaugi în Workspace.
          Selectează un pas din Workspace ca să devină “activ”.
        </p>

        <div class="divider"></div>

        <div class="twoCol">
          <div>
            <h2>2) Propoziții de bază (click = adaugă)</h2>
            <div class="cards" id="baseCards"></div>
          </div>

          <div>
            <h2>3) Workspace (pași)</h2>
            <div class="cards" id="workspace"></div>

            <div class="divider"></div>

            <h2>4) Editare pas activ</h2>
            <div class="card">
              <div class="meta" style="margin-top:0;">
                <span class="tag active" id="activeStepLabel">Pas activ: —</span>
                <button class="ghost mini" id="undoBtn">Undo</button>
              </div>
              <div class="divider"></div>

              <div class="row">
                <span class="pill"><strong>ADD</strong></span>
                <select id="addSelect"></select>
                <button class="primary mini" id="applyAdd">Aplică</button>
              </div>
              <p class="help">Se aplică pe pasul activ (nu pe tot finalul).</p>

              <div class="divider"></div>

              <div class="row">
                <span class="pill"><strong>MODIFY</strong></span>
                <select id="modifySelect"></select>
                <button class="primary mini" id="applyModify">Aplică</button>
              </div>

              <div class="divider"></div>

              <div class="row">
                <span class="pill"><strong>CHANGE</strong></span>
                <select id="changeSelect"></select>
                <button class="primary mini" id="applyChange">Aplică</button>
              </div>

              <div class="divider"></div>

              <div class="row">
                <span class="pill"><strong>Edit manual</strong></span>
                <button class="ghost mini" id="applyManual">Aplică textul</button>
              </div>
              <textarea id="manualKo" placeholder="KO pentru pasul activ…"></textarea>
              <textarea id="manualRo" placeholder="RO pentru pasul activ…"></textarea>
              <p class="help">Folosește asta dacă vrei să corectezi fin propoziția.</p>
            </div>
          </div>
        </div>

        <div class="divider"></div>

        <h2>5) COMBINE (din Workspace)</h2>
        <div class="card">
          <div class="row">
            <span class="pill"><strong>Conector</strong></span>
            <select id="combineSelect"></select>
            <button class="primary mini" id="buildBtn">Construiește finalul</button>
          </div>
          <p class="help">
            Construiește propoziția finală din toți pașii, în ordinea din Workspace.
            (E “smart join” simplu; dacă vrei conjugare automată corectă, o adăugăm ulterior.)
          </p>
        </div>
      </section>

      <!-- RIGHT -->
      <aside class="panel">
        <h2>Preview (final + pași)</h2>

        <div class="card big">
          <div class="korean" id="previewKo">—</div>
          <div class="romanian" id="previewRo">—</div>
          <div class="meta" id="previewMeta"></div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="ghost mini" id="copyKo">Copiază KO</button>
          <button class="ghost mini" id="copyRo">Copiază RO</button>
          <span class="small" id="copyStatus"></span>
        </div>

        <div class="divider"></div>

        <h2>Istoric (session)</h2>
        <div class="cards" id="history"></div>
        <div class="row" style="margin-top:10px;">
          <button class="ghost mini" id="saveBtn">Salvează finalul</button>
          <button class="danger mini" id="clearHistoryBtn">Șterge istoric</button>
        </div>
      </aside>

    </div>
  </div>

  <script>
    /***********************
     * DATA
     ***********************/
    const SETS = [
      {
        id: "shower",
        title: "Duș (acțiuni + reacție)",
        level: "A1→A2",
        base: [
          { id:"b1", ko:"비누칠했어요.", ro:"M-am săpunit (am făcut spumă)."},
          { id:"b2", ko:"물을 틀었어요.", ro:"Am dat drumul la apă."},
          { id:"b3", ko:"물이 차가웠어요.", ro:"Apa era rece."},
          { id:"b4", ko:"놀랐어요.", ro:"Am fost surprins(ă)."}
        ],
        add: [
          { label:"몸에 (pe corp)", type:"prefixObject", target:"비누칠했어요.", out:"몸에 비누칠했어요.", ro:"M-am săpunit pe corp." },
          { label:"따뜻한 (caldă) + 물", type:"replace", find:"물을", repl:"따뜻한 물을", roHint:"apă caldă" },
          { label:"깜짝 (brusc/foarte)", type:"prefixAdverb", target:"놀랐어요.", out:"깜짝 놀랐어요.", ro:"Am fost foarte surprins(ă)." }
        ],
        modify: [
          { label:"물 → 따뜻한 물", type:"replace", find:"물을", repl:"따뜻한 물을", roHint:"apă caldă" },
          { label:"놀랐어요 → 깜짝 놀랐어요", type:"replaceSentence", from:"놀랐어요.", to:"깜짝 놀랐어요.", roHint:"foarte surprins(ă)" }
        ],
        change: [
          { label:"(Info) Negativ / rezultat", type:"infoOnly", note:"În acest set nu există exemple cu 있다/없다 sau 어지다. Folosește alt set pentru CHANGE real." }
        ],
        combine: [
          { label:"-고 (și)", id:"go", joinKo:"고", joinRo:"și" },
          { label:"-아/어/여서 (cauză)", id:"so", joinKo:"아서/어서", joinRo:"așa că" },
          { label:"-는데 (context/contrast)", id:"neunde", joinKo:"는데", joinRo:"dar/iar" }
        ]
      },

      {
        id: "mascara",
        title: "Mascara & timp (negativ + rezultat)",
        level: "A1→A2",
        base: [
          { id:"m1", ko:"시간이 있었어요.", ro:"Am avut timp."},
          { id:"m2", ko:"마스카라를 발랐어요.", ro:"Am aplicat mascara."},
          { id:"m3", ko:"번졌어요.", ro:"S-a întins (s-a șters)."}
        ],
        add: [
          { label:"오래된 + 마스카라", type:"replace", find:"마스카라를", repl:"오래된 마스카라를", roHint:"mascara veche" },
          { label:"대충 (în grabă)", type:"insertBeforeVerb", verb:"발랐어요.", insert:"대충 ", roHint:"în grabă" },
          { label:"다 (complet)", type:"prefixAdverb", target:"번졌어요.", out:"다 번졌어요.", ro:"S-a întins complet." }
        ],
        modify: [
          { label:"마스카라 → 오래된 마스카라", type:"replace", find:"마스카라를", repl:"오래된 마스카라를", roHint:"mascara veche" }
        ],
        change: [
          { label:"시간이 있었어요 → 시간이 없었어요", type:"replaceSentence", from:"시간이 있었어요.", to:"시간이 없었어요.", roHint:"nu am avut timp" }
        ],
        combine: [
          { label:"-고 (și)", id:"go", joinKo:"고", joinRo:"și" },
          { label:"-아/어/여서 (cauză)", id:"so", joinKo:"아서/어서", joinRo:"așa că" },
          { label:"-더니 (apoi)", id:"deoni", joinKo:"더니", joinRo:"și apoi" }
        ]
      },

      {
        id: "glasses",
        title: "Ochelari (imperativ + motiv)",
        level: "A1→A2",
        base: [
          { id:"g1", ko:"안경이 더러워요.", ro:"Ochelarii sunt murdari."},
          { id:"g2", ko:"써요.", ro:"Îi pun (ochelarii)."},
          { id:"g3", ko:"닦아요.", ro:"Îi șterg / lustruiesc."}
        ],
        add: [
          { label:"제 (ai mei)", type:"replace", find:"안경이", repl:"제 안경이", roHint:"ochelarii mei" },
          { label:"너무 (prea)", type:"insertAfterSubject", subject:"안경이", insert:" 너무", roHint:"prea" }
        ],
        modify: [
          { label:"써요 → 쓰세요 (imperativ)", type:"replaceSentence", from:"써요.", to:"쓰세요.", roHint:"pune-i" },
          { label:"닦아요 → 닦으세요 (imperativ)", type:"replaceSentence", from:"닦아요.", to:"닦으세요.", roHint:"șterge-i" }
        ],
        change: [
          { label:"(Info) -기 전에", type:"infoOnly", note:"Poți crea manual: 쓰기 전에 닦으세요." }
        ],
        combine: [
          { label:"-고 (și)", id:"go", joinKo:"고", joinRo:"și" },
          { label:"-(으)니까 (motiv)", id:"nikka", joinKo:"니까", joinRo:"pentru că" },
          { label:"-기 전에 (înainte)", id:"gijeone", joinKo:"기 전에", joinRo:"înainte să" }
        ]
      },

      {
        id: "alarm",
        title: "Alarmă (timp + rezultat + deja)",
        level: "A1→A2",
        base: [
          { id:"a1", ko:"알람이 울렸어요.", ro:"A sunat alarma."},
          { id:"a2", ko:"일어났어요.", ro:"M-am trezit."},
          { id:"a3", ko:"졸려요.", ro:"Îmi e somn."}
        ],
        add: [
          { label:"시끄러운 (zgomotoasă)", type:"replace", find:"알람이", repl:"시끄러운 알람이", roHint:"alarmă zgomotoasă" },
          { label:"새벽 5시에", type:"prefixTime", target:"알람이 울렸어요.", out:"새벽 5시에 알람이 울렸어요.", ro:"La 5 dimineața a sunat alarma." },
          { label:"너무 일찍", type:"replaceSentence", from:"일어났어요.", to:"너무 일찍 일어났어요.", roHint:"prea devreme" },
          { label:"벌써", type:"replaceSentence", from:"졸려요.", to:"벌써 졸려요.", roHint:"deja" }
        ],
        modify: [],
        change: [],
        combine: [
          { label:"-고 (și)", id:"go", joinKo:"고", joinRo:"și" },
          { label:"-아/어/여서 (cauză)", id:"so", joinKo:"아서/어서", joinRo:"așa că" },
          { label:"-더니 (apoi)", id:"deoni", joinKo:"더니", joinRo:"și acum" }
        ]
      }
    ];

    /***********************
     * STATE
     ***********************/
    let currentSet = SETS[0];
    let workspace = [];      // [{ko, ro, tags:[{kind,label}]}]
    let activeIndex = -1;

    let finalKo = "";
    let finalRo = "";
    let history = [];

    // Undo stack for workspace edits
    let undoStack = []; // each entry: deep copy of {workspace, activeIndex}

    const el = (id) => document.getElementById(id);

    function deepCopy(obj){
      return JSON.parse(JSON.stringify(obj));
    }
    function pushUndo(){
      undoStack.push(deepCopy({workspace, activeIndex}));
      if(undoStack.length > 60) undoStack.shift();
    }
    function undo(){
      const last = undoStack.pop();
      if(!last) return;
      workspace = last.workspace;
      activeIndex = last.activeIndex;
      syncManualEditors();
      renderAll();
    }

    function init(){
      // set dropdown
      const s = el("setSelect");
      s.innerHTML = "";
      SETS.forEach(set=>{
        const opt = document.createElement("option");
        opt.value = set.id;
        opt.textContent = set.title;
        s.appendChild(opt);
      });
      s.value = currentSet.id;

      s.addEventListener("change", ()=>{
        const picked = SETS.find(x=>x.id===s.value);
        if(picked){
          currentSet = picked;
          resetAll();
        }
      });

      el("resetBtn").addEventListener("click", ()=>resetAll());
      el("randomBtn").addEventListener("click", ()=>{
        currentSet = SETS[Math.floor(Math.random()*SETS.length)];
        el("setSelect").value = currentSet.id;
        resetAll(true);
      });

      el("applyAdd").addEventListener("click", ()=>applyRuleToActive("add"));
      el("applyModify").addEventListener("click", ()=>applyRuleToActive("modify"));
      el("applyChange").addEventListener("click", ()=>applyRuleToActive("change"));

      el("applyManual").addEventListener("click", ()=>{
        if(activeIndex < 0 || !workspace[activeIndex]) return;
        pushUndo();
        workspace[activeIndex].ko = (el("manualKo").value || "").trim();
        workspace[activeIndex].ro = (el("manualRo").value || "").trim();
        workspace[activeIndex].tags.push({kind:"MANUAL", label:"Edit manual"});
        renderAll();
      });

      el("undoBtn").addEventListener("click", ()=>undo());

      el("buildBtn").addEventListener("click", ()=>buildFinalFromWorkspace());

      el("copyKo").addEventListener("click", ()=>copyText(finalKo, "KO copiat."));
      el("copyRo").addEventListener("click", ()=>copyText(finalRo, "RO copiat."));

      el("saveBtn").addEventListener("click", ()=>saveToHistory());
      el("clearHistoryBtn").addEventListener("click", ()=>{
        history = [];
        renderHistory();
      });

      resetAll();
    }

    function resetAll(random = false){
      undoStack = [];
      workspace = [];
      activeIndex = -1;

      // preset: pune toate propozițiile base în workspace (mai “interactiv” decât un final preset)
      currentSet.base.forEach(b=>{
        workspace.push({ ko:b.ko, ro:b.ro, tags:[{kind:"BASE", label:"Base"}] });
      });

      // active on first
      activeIndex = workspace.length ? 0 : -1;
      renderAll();
      syncManualEditors();

      // auto-build
      buildFinalFromWorkspace(true);
    }

    function renderAll(){
      el("levelLabel").textContent = currentSet.level || "A1";
      renderBase();
      renderWorkspace();
      renderSelects();
      renderActiveLabel();
      renderPreview();
      renderHistory();
    }

    function renderBase(){
      const wrap = el("baseCards");
      wrap.innerHTML = "";
      currentSet.base.forEach((b)=>{
        const c = document.createElement("div");
        c.className = "card clickable";
        c.innerHTML = `
          <div class="korean">${escapeHtml(b.ko)}</div>
          <div class="romanian">${escapeHtml(b.ro)}</div>
          <div class="meta"><span class="tag">Click → Adaugă</span></div>
        `;
        c.addEventListener("click", ()=>{
          pushUndo();
          workspace.push({ ko:b.ko, ro:b.ro, tags:[{kind:"BASE", label:"Adăugat din bază"}] });
          activeIndex = workspace.length - 1;
          syncManualEditors();
          renderAll();
        });
        wrap.appendChild(c);
      });

      const hint = document.createElement("div");
      hint.className = "card";
      hint.innerHTML = `
        <div class="romanian">
          Tip: poți construi o propoziție lungă adăugând pași extra (click pe bază de mai multe ori),
          apoi reordonezi și combini.
        </div>
      `;
      wrap.appendChild(hint);
    }

    function renderWorkspace(){
      const wrap = el("workspace");
      wrap.innerHTML = "";

      if(!workspace.length){
        const empty = document.createElement("div");
        empty.className = "card";
        empty.innerHTML = `<div class="romanian">Workspace gol. Click pe o propoziție din “Bază”.</div>`;
        wrap.appendChild(empty);
        return;
      }

      workspace.forEach((st, idx)=>{
        const c = document.createElement("div");
        c.className = "card step";
        const activeTag = (idx === activeIndex) ? `<span class="tag active">ACTIV</span>` : "";
        c.innerHTML = `
          <div>
            <div class="korean">${escapeHtml(st.ko)}</div>
            <div class="romanian">${escapeHtml(st.ro)}</div>
            <div class="meta">
              ${activeTag}
              <span class="tag">#${idx+1}</span>
              ${st.tags.slice(-2).map(t=>`<span class="tag">${escapeHtml(t.kind)}</span>`).join("")}
            </div>
          </div>

          <div class="stepControls">
            <button class="ghost mini" data-act="select">Select</button>
            <button class="ghost mini" data-act="up">↑</button>
            <button class="ghost mini" data-act="down">↓</button>
            <button class="danger mini" data-act="del">Șterge</button>
          </div>
        `;

        c.querySelector('[data-act="select"]').addEventListener("click", ()=>{
          activeIndex = idx;
          syncManualEditors();
          renderAll();
        });

        c.querySelector('[data-act="up"]').addEventListener("click", ()=>{
          if(idx === 0) return;
          pushUndo();
          const tmp = workspace[idx-1];
          workspace[idx-1] = workspace[idx];
          workspace[idx] = tmp;
          activeIndex = idx-1;
          syncManualEditors();
          renderAll();
        });

        c.querySelector('[data-act="down"]').addEventListener("click", ()=>{
          if(idx >= workspace.length-1) return;
          pushUndo();
          const tmp = workspace[idx+1];
          workspace[idx+1] = workspace[idx];
          workspace[idx] = tmp;
          activeIndex = idx+1;
          syncManualEditors();
          renderAll();
        });

        c.querySelector('[data-act="del"]').addEventListener("click", ()=>{
          pushUndo();
          workspace.splice(idx,1);
          if(activeIndex >= workspace.length) activeIndex = workspace.length-1;
          syncManualEditors();
          renderAll();
        });

        wrap.appendChild(c);
      });
    }

    function renderSelects(){
      // ADD
      const addSel = el("addSelect");
      addSel.innerHTML = "";
      if(!currentSet.add?.length){
        addSel.appendChild(new Option("— nu există —", ""));
      } else {
        currentSet.add.forEach((a,i)=> addSel.appendChild(new Option(a.label, String(i))) );
      }

      // MODIFY
      const modSel = el("modifySelect");
      modSel.innerHTML = "";
      if(!currentSet.modify?.length){
        modSel.appendChild(new Option("— nu există —", ""));
      } else {
        currentSet.modify.forEach((m,i)=> modSel.appendChild(new Option(m.label, String(i))) );
      }

      // CHANGE
      const chSel = el("changeSelect");
      chSel.innerHTML = "";
      if(!currentSet.change?.length){
        chSel.appendChild(new Option("— nu există —", ""));
      } else {
        currentSet.change.forEach((c,i)=> chSel.appendChild(new Option(c.label, String(i))) );
      }

      // COMBINE
      const combSel = el("combineSelect");
      combSel.innerHTML = "";
      if(!currentSet.combine?.length){
        combSel.appendChild(new Option("— nu există —", ""));
      } else {
        currentSet.combine.forEach((c,i)=> combSel.appendChild(new Option(c.label, String(i))) );
      }
    }

    function renderActiveLabel(){
      el("activeStepLabel").textContent = (activeIndex >= 0)
        ? `Pas activ: #${activeIndex+1}`
        : "Pas activ: —";
    }

    function renderPreview(){
      el("previewKo").textContent = finalKo || "—";
      el("previewRo").textContent = finalRo || "—";

      const meta = el("previewMeta");
      meta.innerHTML = "";
      if(!workspace.length){
        meta.appendChild(tagSpan("WORKSPACE gol", ""));
        return;
      }
      meta.appendChild(tagSpan(`Pași: ${workspace.length}`, "ok"));
      meta.appendChild(tagSpan(`Set: ${currentSet.title}`, ""));
    }

    function renderHistory(){
      const h = el("history");
      h.innerHTML = "";
      if(!history.length){
        const empty = document.createElement("div");
        empty.className = "card";
        empty.innerHTML = `<div class="romanian">Nu ai nimic salvat în sesiunea aceasta.</div>`;
        h.appendChild(empty);
        return;
      }
      history.slice().reverse().forEach(item=>{
        const c = document.createElement("div");
        c.className = "card";
        c.innerHTML = `
          <div class="korean">${escapeHtml(item.ko)}</div>
          <div class="romanian">${escapeHtml(item.ro)}</div>
          <div class="meta">
            <span class="tag">${escapeHtml(item.setTitle)}</span>
            <button class="ghost mini">Reîncarcă</button>
          </div>
        `;
        c.querySelector("button").addEventListener("click", ()=>{
          // reîncarcă doar finalul în preview
          finalKo = item.ko;
          finalRo = item.ro;
          renderPreview();
        });
        h.appendChild(c);
      });
    }

    function syncManualEditors(){
      if(activeIndex < 0 || !workspace[activeIndex]){
        el("manualKo").value = "";
        el("manualRo").value = "";
        return;
      }
      el("manualKo").value = workspace[activeIndex].ko || "";
      el("manualRo").value = workspace[activeIndex].ro || "";
    }

    function applyRuleToActive(listName){
      if(activeIndex < 0 || !workspace[activeIndex]) return;

      const selId = (listName === "add") ? "addSelect"
                  : (listName === "modify") ? "modifySelect"
                  : "changeSelect";

      const idx = parseInt(el(selId).value, 10);
      const rule = currentSet[listName]?.[idx];
      if(!rule) return;

      pushUndo();

      const st = workspace[activeIndex];
      const res = applyRuleToSentence(rule, st.ko, st.ro);
      if(!res.ok){
        // dacă nu se potrivește regula, nu stricăm nimic
        undoStack.pop(); // anulăm pushUndo
        return;
      }

      st.ko = res.ko;
      st.ro = res.ro;
      st.tags.push({kind: listName.toUpperCase(), label: rule.label});

      // sync editor fields
      syncManualEditors();
      renderAll();
    }

    function applyRuleToSentence(rule, ko, ro){
      let newKo = ko || "";
      let newRo = ro || "";

      if(rule.type === "infoOnly"){
        newRo = (newRo || "") + ` (Notă: ${rule.note})`;
        return {ok:true, ko:newKo, ro:newRo};
      }

      if(rule.type === "replace"){
        if(newKo.includes(rule.find)){
          newKo = newKo.replace(rule.find, rule.repl);
          if(rule.roHint) newRo = addHint(newRo, rule.roHint);
          return {ok:true, ko:newKo, ro:newRo};
        }
        return {ok:false, ko, ro};
      }

      if(rule.type === "replaceSentence"){
        if(newKo.includes(rule.from)){
          newKo = newKo.replace(rule.from, rule.to);
          if(rule.roHint) newRo = addHint(newRo, rule.roHint);
          return {ok:true, ko:newKo, ro:newRo};
        }
        return {ok:false, ko, ro};
      }

      if(rule.type === "prefixObject" || rule.type === "prefixAdverb" || rule.type === "prefixTime"){
        if(newKo.includes(rule.target)){
          newKo = newKo.replace(rule.target, rule.out);
          if(rule.ro) newRo = rule.ro;
          return {ok:true, ko:newKo, ro:newRo};
        }
        // fallback: set direct (dar doar dacă are sens)
        newKo = rule.out;
        if(rule.ro) newRo = rule.ro;
        return {ok:true, ko:newKo, ro:newRo};
      }

      if(rule.type === "insertBeforeVerb"){
        if(newKo.includes(rule.verb)){
          newKo = newKo.replace(rule.verb, rule.insert + rule.verb);
          if(rule.roHint) newRo = addHint(newRo, rule.roHint);
          return {ok:true, ko:newKo, ro:newRo};
        }
        return {ok:false, ko, ro};
      }

      if(rule.type === "insertAfterSubject"){
        const token = rule.subject;
        const i = newKo.indexOf(token);
        if(i !== -1){
          const before = newKo.slice(0, i + token.length);
          const after  = newKo.slice(i + token.length);
          newKo = before + rule.insert + after;
          if(rule.roHint) newRo = addHint(newRo, rule.roHint);
          return {ok:true, ko:newKo, ro:newRo};
        }
        return {ok:false, ko, ro};
      }

      return {ok:false, ko, ro};
    }

    function buildFinalFromWorkspace(silent=false){
      if(!workspace.length){
        finalKo = "—";
        finalRo = "—";
        renderPreview();
        return;
      }

      const idx = parseInt(el("combineSelect").value, 10);
      const rule = currentSet.combine?.[idx] || currentSet.combine?.[0];

      // Simplu: concatenăm propozițiile, cu un join “vizibil”.
      // KO: scoatem punctele intermediare și inserăm conectorul ca text (nu conjugăm automat).
      // RO: folosim joinRo.
      const joinKo = rule?.joinKo || "고";
      const joinRo = rule?.joinRo || "și";

      const koParts = workspace.map(x => (x.ko || "").trim().replace(/\s+/g," ").replace(/\.$/,""));
      const roParts = workspace.map(x => (x.ro || "").trim().replace(/\s+/g," ").replace(/\.$/,""));

      if(koParts.length === 1){
        finalKo = koParts[0] + ".";
        finalRo = roParts[0] + ".";
      }else{
        // KO join
        // Exemplu: A + " " + joinKo + " " + B + ", " + C...
        // În practică, utilizatorul poate edita manual pașii pentru naturalețe.
        let ko = koParts[0];
        for(let i=1;i<koParts.length;i++){
          ko = `${ko} ${joinKo} ${koParts[i]}`;
        }
        finalKo = ko + ".";

        // RO join
        let ro = roParts[0];
        for(let i=1;i<roParts.length;i++){
          ro = `${ro} ${joinRo} ${roParts[i]}`;
        }
        finalRo = ro + ".";
      }

      renderPreview();
      if(!silent){
        // opțional: mic feedback
      }
    }

    function saveToHistory(){
      if(!finalKo || finalKo === "—") return;
      history.push({ ko: finalKo, ro: finalRo, setTitle: currentSet.title });
      renderHistory();
    }

    function addHint(ro, hint){
      if(!ro) return ro;
      if(ro.includes(hint)) return ro;
      return ro + ` (hint: ${hint})`;
    }

    function tagSpan(text, kind){
      const span = document.createElement("span");
      span.className = "tag " + (kind || "");
      span.textContent = text;
      return span;
    }

    async function copyText(txt, okMsg){
      try{
        await navigator.clipboard.writeText(txt || "");
        el("copyStatus").textContent = okMsg;
        el("copyStatus").className = "small copyOk";
        setTimeout(()=>{ el("copyStatus").textContent=""; }, 1200);
      }catch(e){
        el("copyStatus").textContent = "Nu pot copia (browser restrictions).";
        el("copyStatus").className = "small";
      }
    }

    function escapeHtml(str){
      return (str ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    init();
  </script>
</body>
</html>
