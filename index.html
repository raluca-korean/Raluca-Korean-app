<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Raluca Korean â€“ Builder Multi-Clause (Clean)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root{
      --bg1:#dff3ff;
      --bg2:#ffe9ff;
      --bg3:#f4fffc;
      --bg4:#e8f0ff;

      --accent:#7b5dff;
      --card-bg:#ffffffcc;
      --text-main:#2f343b;
      --text-soft:#7a8088;
      --border:#e1d7c7;
    }
    *{box-sizing:border-box;}

    body{
      margin:0;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      color:var(--text-main);
      background:linear-gradient(120deg,var(--bg1),var(--bg2),var(--bg3),var(--bg4));
      background-size:380% 380%;
      animation:bgFlow 28s ease-in-out infinite;
    }
    @keyframes bgFlow{
      0%{background-position:0% 50%;}
      50%{background-position:100% 50%;}
      100%{background-position:0% 50%;}
    }

    .app{max-width:1040px;margin:0 auto;padding:18px 14px 80px;}

    .rk-header{
      padding:12px 16px 16px;border-radius:26px;
      background:linear-gradient(120deg,#6fb8ff,#a774ff,#ff7fd1);
      color:#fff; box-shadow:0 18px 45px rgba(77,93,255,0.4);
    }
    .rk-header-main{display:flex;justify-content:space-between;align-items:center;gap:10px;}
    .rk-header-main h1{
      margin:0;font-size:20px;font-weight:900;letter-spacing:0.06em;text-transform:uppercase;
    }
    .rk-badge{
      font-size:11px;font-weight:600;padding:4px 9px;border-radius:999px;
      background:rgba(255,255,255,0.18);border:1px solid rgba(255,255,255,0.4);
    }
    #subtitle{margin:8px 0 0;font-size:12px;opacity:0.95;}

    .card{
      margin-top:16px;padding:16px 18px 18px;border-radius:22px;
      background:var(--card-bg);backdrop-filter:blur(16px);
      border:1px solid rgba(255,255,255,0.7);box-shadow:0 18px 40px rgba(0,0,0,0.12);
    }
    .card h2{margin:0 0 8px;font-size:16px;font-weight:800;letter-spacing:0.03em;}

    textarea{
      width:100%;border-radius:16px;border:1px solid var(--border);
      padding:10px 12px;font-size:14px;resize:vertical;min-height:70px;
      color:var(--text-main);background:#fff;
    }
    textarea:focus{
      outline:none;box-shadow:0 0 0 1px rgba(255,255,255,0.9),0 0 0 3px rgba(149,120,255,0.5);
      border-color:rgba(149,120,255,0.7);
    }

    .btn-row{margin-top:10px;display:flex;flex-wrap:wrap;gap:8px;}
    button{
      border:none;border-radius:999px;padding:8px 16px;font-size:12px;font-weight:800;cursor:pointer;color:#fff;
      background:linear-gradient(135deg,#6b8cff,#9b6bff);
      box-shadow:0 10px 24px rgba(108,110,210,0.4),0 0 0 1px rgba(255,255,255,0.7) inset;
      transition:transform .12s ease, box-shadow .12s ease, filter .12s ease;
    }
    button.secondary{background:linear-gradient(135deg,#ff9a6c,#ff5f8c);}
    button:hover{transform:translateY(-1px);box-shadow:0 12px 26px rgba(0,0,0,0.18);filter:brightness(1.03);}
    button:active{transform:translateY(1px) scale(0.98);box-shadow:0 6px 16px rgba(0,0,0,0.25);filter:brightness(0.97);}

    .section-title{
      margin-top:18px;margin-bottom:6px;font-size:13px;font-weight:800;letter-spacing:0.08em;
      text-transform:uppercase;color:#4b607d;
    }

    .table-block{
      margin-top:10px;padding:10px 10px 12px;border-radius:20px;
      background:var(--card-bg);border:1px solid rgba(255,255,255,0.7);box-shadow:0 14px 30px rgba(0,0,0,0.1);
    }
    .table-title{
      display:flex;justify-content:space-between;align-items:center;
      font-size:12px;font-weight:800;color:var(--text-soft);margin-bottom:6px;
    }
    .table-horizontal{display:flex;gap:8px;overflow-x:auto;padding-bottom:4px;}

    .col{
      min-width:110px;max-width:150px;flex:0 0 auto;border-radius:16px;padding:7px 7px 9px;
      background:radial-gradient(circle at top left,#fdfbf7,#f2ebde);
      border:1px solid #e2d7c8;box-shadow:0 10px 22px rgba(95,78,58,0.16);
    }
    .col-header{
      display:flex;align-items:center;justify-content:space-between;gap:4px;
      font-size:10px;font-weight:900;letter-spacing:0.08em;text-transform:uppercase;
      color:#7b5dff;border-bottom:1px solid rgba(208,196,255,0.8);padding-bottom:2px;margin-bottom:3px;
    }
    .col-header::before{
      content:"";display:inline-flex;align-items:center;justify-content:center;width:16px;height:16px;border-radius:6px;
      background:#fff;font-size:11px;box-shadow:0 1px 3px rgba(0,0,0,0.06);
    }
    .col[data-key="subject"] .col-header::before{content:"ğŸ‘¤";}
    .col[data-key="time"]    .col-header::before{content:"â°";}
    .col[data-key="place"]   .col-header::before{content:"ğŸ“";}
    .col[data-key="mod"]     .col-header::before{content:"âœ¨";}
    .col[data-key="object"]  .col-header::before{content:"ğŸ¯";}
    .col[data-key="numeral"] .col-header::before{content:"#ï¸âƒ£";}
    .col[data-key="counter"] .col-header::before{content:"ğŸ”¢";}
    .col[data-key="verb"]    .col-header::before{content:"ğŸš€";}
    .col[data-key="conj"]    .col-header::before{content:"ğŸ”—";}

    .col-body-label{font-size:10px;color:#938777;margin-bottom:1px;}
    .col-body-main{font-size:15px;font-weight:900;min-height:1.4em;}
    .col-body-main[contenteditable="true"]{outline:none;cursor:text;}
    .col-body-main:focus{
      box-shadow:0 0 0 1px rgba(255,255,255,0.8),0 0 0 2px rgba(149,120,255,0.7);
      border-radius:6px;
    }
    .col-body-extra.example{margin-top:2px;font-size:10px;color:#b09b83;}

    .preview-card{
      margin-top:14px;padding:12px 14px;border-radius:20px;background:var(--card-bg);
      border:1px solid rgba(255,255,255,0.7);box-shadow:0 16px 32px rgba(0,0,0,0.12);
    }
    .preview-title{
      font-size:12px;font-weight:900;color:#4b607d;display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;
      gap:10px;
    }
    .preview-title .right{display:flex;align-items:center;gap:8px;color:var(--text-soft);font-weight:800;}
    .preview-title input{transform:translateY(1px);}
    .preview-sentence{font-size:22px;font-weight:900;line-height:1.6;margin-bottom:4px;word-break:keep-all;}
    .preview-ro{font-size:12px;color:var(--text-soft);}

    .hint{margin-top:6px;font-size:11px;color:var(--text-soft);line-height:1.4;}
    code.k{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;background: rgba(255,255,255,0.7);
      border: 1px solid rgba(0,0,0,0.06);padding: 1px 6px;border-radius: 999px;
    }

    @media (max-width:600px){
      .rk-header-main h1{font-size:17px;}
      .col{min-width:95px;}
    }
  </style>
</head>

<body>
  <div class="app">
    <header class="rk-header">
      <div class="rk-header-main">
        <h1>RALUCA KOREAN</h1>
        <span class="rk-badge">Builder â€“ Clean</span>
      </div>
      <p id="subtitle">Split multi + endings lipite de verb (verb infinitiv Ã®n tabel) + politeÈ›e doar Ã®n preview.</p>
    </header>

    <section class="card" id="roCard">
      <h2>RomÃ¢nÄƒ / English â†’ CoreeanÄƒ (auto-fill)</h2>
      <div style="margin-bottom:6px;font-size:11px;color:var(--text-soft);display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
        <span>Limba propoziÈ›iei:</span>
        <select id="langSelect" style="padding:2px 8px;border-radius:999px;border:1px solid var(--border);font-size:11px;">
          <option value="ro" selected>RomÃ¢nÄƒ</option>
          <option value="en">English</option>
        </select>
      </div>

      <textarea id="inputText" placeholder="Ex: AstÄƒzi merg la cafenea È™i citesc o carte È™i beau o cafea.
Today I go to the cafe and read a book and drink a coffee."></textarea>

      <div class="btn-row">
        <button id="autoFillBtn">CompleteazÄƒ automat builder-ul</button>
        <button id="clearBtn" class="secondary">CurÄƒÈ›Äƒ tot</button>
      </div>

      <div class="hint">
        Reguli (default):
        <br>â€¢ <b>È™i / and</b> â†’ <code class="k">-ê³ </code>
        <br>â€¢ <b>dar / but</b> â†’ <code class="k">-ì§€ë§Œ</code>
        <br>â€¢ <b>pentru cÄƒ / because</b> â†’ <code class="k">-ì–´ì„œ</code>
        <br>â€¢ <b>dacÄƒ / if</b> â†’ <code class="k">-(ìœ¼)ë©´</code>
        <br>â€¢ <b>cÃ¢nd / atunci cÃ¢nd / when</b> â†’ <code class="k">-(ìœ¼)ã„¹ ë•Œ</code>
        <br>â€¢ <b>ca sÄƒ / in order to</b> â†’ <code class="k">-(ìœ¼)ë ¤ê³ </code>
      </div>
    </section>

    <h3 class="section-title">Builder (clauze)</h3>
    <div id="clausesHost"></div>

    <section class="preview-card">
      <div class="preview-title">
        <span>PropoziÈ›ia finalÄƒ Ã®n coreeanÄƒ</span>
        <span class="right">
          <label style="display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="politeToggle" />
            <span>PoliteÈ›e (doar ultima clauzÄƒ)</span>
          </label>
        </span>
      </div>
      <div id="previewSentence" class="preview-sentence"></div>
      <div id="previewInfo" class="preview-ro"></div>
    </section>
  </div>

  <script>
  (function () {
    // =========================
    // 1) Utils
    // =========================
    function normalizeText(text) {
      if (!text) return "";
      let t = text.toLowerCase();
      t = t.replace(/ÅŸ/g, "È™").replace(/Å£/g, "È›");
      t = t.replace(/[.,!?;:]/g, " ");
      t = t.replace(/\s+/g, " ").trim();
      return t;
    }

    function escapeRegExp(s) {
      return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function hasBatchim(koreanSyllable) {
      if (!koreanSyllable) return false;
      const code = koreanSyllable.charCodeAt(koreanSyllable.length - 1);
      if (code < 0xAC00 || code > 0xD7A3) return false;
      const jong = (code - 0xAC00) % 28;
      return jong !== 0;
    }

    function lastHangulChar(str) {
      const s = (str || "").trim();
      if (!s) return "";
      return s[s.length - 1];
    }

    // =========================
    // 2) Conectori (RO/EN) -> ending KO
    // =========================
    const CONNECTORS = [
      { keys: ["atunci cÃ¢nd", "atunci cand", "when"], type: "when", ko: "-(ìœ¼)ã„¹ ë•Œ" },
      { keys: ["pentru cÄƒ", "pentru ca", "fiindcÄƒ", "fiindca", "because"], type: "because", ko: "-ì–´ì„œ" },
      { keys: ["ca sÄƒ", "ca sa", "in order to"], type: "in_order_to", ko: "-(ìœ¼)ë ¤ê³ " },
      { keys: ["deÈ™i", "desi", "although", "even though"], type: "although", ko: "-ì§€ë§Œ" },
      { keys: ["dacÄƒ", "daca", "if"], type: "if", ko: "-(ìœ¼)ë©´" },
      { keys: ["dar", "but"], type: "but", ko: "-ì§€ë§Œ" },
      { keys: ["È™i", "si", "and"], type: "and", ko: "-ê³ " },
      { keys: ["apoi", "then"], type: "and", ko: "-ê³ " },
    ];

    function buildConnectorRegex() {
      const all = CONNECTORS.flatMap(c => c.keys);
      const uniq = Array.from(new Set(all));
      uniq.sort((a,b) => b.length - a.length);
      const alt = uniq.map(escapeRegExp).join("|");
      return new RegExp("\\s(" + alt + ")\\s", "ig");
    }

    function mapConnectorToken(token) {
      const t = (token || "").toLowerCase();
      for (const c of CONNECTORS) {
        if (c.keys.some(k => k.toLowerCase() === t)) return { raw: token, type: c.type, ko: c.ko };
      }
      return { raw: token, type: "and", ko: "-ê³ " };
    }

    function splitIntoChain(raw) {
      const original = (raw || "").replace(/\s+/g, " ").trim();
      const t = normalizeText(original);
      if (!t) return { clauses: [], links: [] };

      const re = buildConnectorRegex();
      const parts = [];
      let lastIndex = 0;
      let m;

      while ((m = re.exec(t)) !== null) {
        const before = t.slice(lastIndex, m.index).trim();
        const token  = (m[1] || "").trim();
        if (before) parts.push({ kind: "clause", text: before });
        parts.push({ kind: "conn", text: token });
        lastIndex = m.index + m[0].length;
      }
      const tail = t.slice(lastIndex).trim();
      if (tail) parts.push({ kind: "clause", text: tail });

      const clauses = [];
      const links = [];
      for (const p of parts) {
        if (p.kind === "clause") clauses.push(p.text);
        if (p.kind === "conn") links.push(mapConnectorToken(p.text));
      }
      while (links.length >= clauses.length) links.pop();
      return { clauses, links };
    }

    // =========================
    // 3) RO/EN -> slot rules (fixe)
    // =========================
    const RO_RULES = {
      subject: [
        { re: /\beu\b/, value: "ì €" },
        { re: /\btu\b/, value: "ë„ˆ" },
        { re: /\bnoi\b/, value: "ìš°ë¦¬" },
      ],
      time: [
        { re: /\bazi\b|\bastÄƒzi\b/, value: "ì˜¤ëŠ˜" },
        { re: /\bmÃ¢ine\b/, value: "ë‚´ì¼" },
        { re: /\bieri\b/, value: "ì–´ì œ" },
        { re: /\bacum\b/, value: "ì§€ê¸ˆ" },
      ],
      place: [
        { re: /\bcafenea\b|cafe\b/, value: "ì¹´í˜" },
        { re: /\bpia[tÈ›]Äƒ\b/, value: "ì‹œì¥" },
        { re: /\bmagazin\b|supermarket\b/, value: "ê°€ê²Œ" },
        { re: /\bacas[Äƒa]\b/, value: "ì§‘" },
        { re: /\bÈ™coal[Äƒa]\b|\bscoala\b/, value: "í•™êµ" },
        { re: /\bserviciu\b|\bfirm[Äƒa]\b|\bcompanie\b/, value: "íšŒì‚¬" },
      ],
      mod: [
        { re: /\bbine\b|\bok\b/, value: "ì˜" },
        { re: /\bÃ®ncet\b|\bincet\b/, value: "ì²œì²œíˆ" },
        { re: /\brepede\b|\brapid\b/, value: "ë¹¨ë¦¬" },
        { re: /\bmult\b/, value: "ë§ì´" },
      ],
      object: [
        { re: /\bcarte\b|c[Äƒa]rÈ›/i, value: "ì±…" },
        { re: /\bcafea\b/, value: "ì»¤í”¼" },
        { re: /\bap[Äƒa]\b/, value: "ë¬¼" },
        { re: /\bceai\b/, value: "ì°¨" },
        { re: /\bm[Äƒa]ncare\b|\bpr[Äƒa]nz\b|\bcin[Äƒa]\b|\bmic\s+dejun\b/i, value: "ìŒì‹" },
      ],
      numeral: [
        { re: /\bo\s+\w+|\buna\b|\bun\b/, value: "í•œ" },
        { re: /\bdou[Äƒa]\b/, value: "ë‘" },
        { re: /\btrei\b/, value: "ì„¸" },
      ],
      counter: [
        { re: /carte|c[Äƒa]rÈ›/i, value: "ê¶Œ" },
        { re: /cafea|ap[Äƒa]|ceai|m[Äƒa]ncare/i, value: "ê°œ" },
      ],
      verb: [
        { re: /\bmerg\b|a\s+merge|sÄƒ\s+merg|sa\s+merg/i, value: "ê°€ë‹¤" },
        { re: /\bvin\b|a\s+veni|sÄƒ\s+vin|sa\s+vin/i, value: "ì˜¤ë‹¤" },
        { re: /\bcitesc\b|a\s+citi|sÄƒ\s+citesc|sa\s+citesc/i, value: "ì½ë‹¤" },
        { re: /\bbeau\b|a\s+bea|sÄƒ\s+beau|sa\s+beau/i, value: "ë§ˆì‹œë‹¤" },
        { re: /\bm[Ã¢Äƒ]n[Ã¢a]nc\b|mananc|a\s+m[Ã¢Äƒ]nca/i, value: "ë¨¹ë‹¤" },
        { re: /\blucrez\b|a\s+lucra/i, value: "ì¼í•˜ë‹¤" },
        { re: /\bÃ®nvÄƒÈ›\b|invata|a\s+Ã®nvÄƒÈ›a|a\s+invata/i, value: "ê³µë¶€í•˜ë‹¤" },
        { re: /\bdorm\b|a\s+dormi/i, value: "ìë‹¤" },
      ],
    };

    const EN_RULES = {
      subject: [
        { re: /\bi\b/, value: "ì €" },
        { re: /\byou\b/, value: "ë„ˆ" },
        { re: /\bwe\b/, value: "ìš°ë¦¬" },
      ],
      time: [
        { re: /\btoday\b/, value: "ì˜¤ëŠ˜" },
        { re: /\btomorrow\b/, value: "ë‚´ì¼" },
        { re: /\byesterday\b/, value: "ì–´ì œ" },
        { re: /\bnow\b/, value: "ì§€ê¸ˆ" },
      ],
      place: [
        { re: /\bcafe\b|coffee\s+shop\b/, value: "ì¹´í˜" },
        { re: /\bmarket\b|mart\b|grocery\b/, value: "ì‹œì¥" },
        { re: /\bstore\b|shop\b/, value: "ê°€ê²Œ" },
        { re: /\bhome\b|house\b/, value: "ì§‘" },
        { re: /\bschool\b/, value: "í•™êµ" },
        { re: /\bwork\b|company\b|office\b/, value: "íšŒì‚¬" },
      ],
      mod: [
        { re: /\bwell\b|okay\b/, value: "ì˜" },
        { re: /\bslowly\b/, value: "ì²œì²œíˆ" },
        { re: /\bfast\b|\bquickly\b/, value: "ë¹¨ë¦¬" },
        { re: /\ba lot\b|\bmuch\b/, value: "ë§ì´" },
      ],
      object: [
        { re: /\bbook\b|books\b/, value: "ì±…" },
        { re: /\bcoffee\b/, value: "ì»¤í”¼" },
        { re: /\bwater\b/, value: "ë¬¼" },
        { re: /\btea\b/, value: "ì°¨" },
        { re: /\bfood\b|meal\b|lunch\b|dinner\b|breakfast\b/, value: "ìŒì‹" },
      ],
      numeral: [
        { re: /\bone\b|\ba\b|\ban\b/, value: "í•œ" },
        { re: /\btwo\b/, value: "ë‘" },
        { re: /\bthree\b/, value: "ì„¸" },
      ],
      counter: [
        { re: /\bbook\b|books\b/, value: "ê¶Œ" },
        { re: /\bcoffee\b|water\b|tea\b|food\b|meal\b/, value: "ê°œ" },
      ],
      verb: [
        { re: /\bgo\b|\bgoing\b/, value: "ê°€ë‹¤" },
        { re: /\bcome\b|\bcoming\b/, value: "ì˜¤ë‹¤" },
        { re: /\bread\b|\breading\b/, value: "ì½ë‹¤" },
        { re: /\bdrink\b|\bdrinking\b/, value: "ë§ˆì‹œë‹¤" },
        { re: /\beat\b|\beating\b/, value: "ë¨¹ë‹¤" },
        { re: /\bwork\b|\bworking\b/, value: "ì¼í•˜ë‹¤" },
        { re: /\bstudy\b|\blearn\b|\blearning\b/, value: "ê³µë¶€í•˜ë‹¤" },
        { re: /\bsleep\b|\bsleeping\b/, value: "ìë‹¤" },
        { re: /\bwrite\b|\bwriting\b/, value: "ì“°ë‹¤" },
        { re: /\bspeak\b|\bspeaking\b/, value: "ë§í•˜ë‹¤" },
        { re: /\bwatch\b|\bwatching\b/, value: "ë³´ë‹¤" },
        { re: /\bbuy\b|\bbuying\b/, value: "ì‚¬ë‹¤" },
      ],
    };

    function matchSlot(rules, textNorm) {
      for (const r of rules) if (r.re.test(textNorm)) return r.value;
      return "";
    }

    function parseToSlots(text, lang) {
      const t = normalizeText(text);
      const RULES = (lang === "en") ? EN_RULES : RO_RULES;
      if (!t) return {};
      return {
        subject: matchSlot(RULES.subject, t),
        time:    matchSlot(RULES.time, t),
        place:   matchSlot(RULES.place, t),
        mod:     matchSlot(RULES.mod, t),
        object:  matchSlot(RULES.object, t),
        numeral: matchSlot(RULES.numeral, t),
        counter: matchSlot(RULES.counter, t),
        verb:    matchSlot(RULES.verb, t),
      };
    }

    // =========================
    // 4) UI: clauze dinamice
    // =========================
    const host = document.getElementById("clausesHost");

    function colHTML(key, title, hint, example) {
      return `
        <div class="col" data-key="${key}">
          <div class="col-header">${title}</div>
          <div class="col-body-label">${hint}</div>
          <div class="col-body-main" contenteditable="true"></div>
          ${example ? `<div class="col-body-extra example">${example}</div>` : ""}
        </div>
      `;
    }

    function clauseBlockHTML(idx) {
      const label = (idx === 0) ? "PropoziÈ›ia 1" : ("PropoziÈ›ia " + (idx + 1));
      const id = "tableP" + (idx + 1);

      return `
        <section class="table-block" data-clause-index="${idx}">
          <div class="table-title">
            <span>${label}</span>
            <span style="font-size:11px;color:var(--text-soft);">VERB infinitiv (â€¦ë‹¤) â€¢ CONJ = ending sau conector</span>
          </div>
          <div id="${id}" class="table-horizontal">
            ${colHTML("subject","SUBJECT","eu/tuâ€¦","ex: ì €, ë‚˜, ë„ˆ")}
            ${colHTML("time","TIME","azi/todayâ€¦","ex: ì˜¤ëŠ˜, ë‚´ì¼")}
            ${colHTML("place","PLACE","loc (bazÄƒ)","ex: ì¹´í˜, ì§‘, í•™êµ")}
            ${colHTML("mod","MOD","bine/slowlyâ€¦","ex: ì˜, ì²œì²œíˆ")}
            ${colHTML("object","OBJECT","obiect","ex: ì±…, ì»¤í”¼")}
            ${colHTML("numeral","NUMERAL","una/twoâ€¦","ex: í•œ, ë‘")}
            ${colHTML("counter","COUNTER","ê¶Œ/ê°œâ€¦","ex: ê¶Œ, ê°œ")}
            ${colHTML("verb","VERB","ê°€ë‹¤, ì½ë‹¤â€¦","IMPORTANT: infinitiv (â€¦ë‹¤)")}
            ${colHTML("conj","CONJ / ENDING","-ê³ , -ì§€ë§Œâ€¦","ex: -ê³ , -ì§€ë§Œ, -ì–´ì„œ, -(ìœ¼)ë©´, -(ìœ¼)ã„¹ ë•Œ, -(ìœ¼)ë ¤ê³ , ê·¸ë¦¬ê³ ")}
          </div>
        </section>
      `;
    }

    function ensureClauseCount(n) {
      const current = host.querySelectorAll("[data-clause-index]").length;
      if (current === n) return;
      if (current < n) {
        for (let i=current; i<n; i++) host.insertAdjacentHTML("beforeend", clauseBlockHTML(i));
      } else {
        for (let i=current-1; i>=n; i--) {
          const el = host.querySelector('[data-clause-index="' + i + '"]');
          if (el) el.remove();
        }
      }
    }

    function getTableId(idx){ return "tableP" + (idx + 1); }

    function setCell(tableId, key, value) {
      const cell = document.querySelector("#" + tableId + ' .col[data-key="' + key + '"] .col-body-main');
      if (cell) cell.textContent = value || "";
    }

    function readCell(tableId, key) {
      const cell = document.querySelector("#" + tableId + ' .col[data-key="' + key + '"] .col-body-main');
      return cell ? cell.textContent.trim() : "";
    }

    function clearClause(tableId) {
      const table = document.getElementById(tableId);
      if (!table) return;
      table.querySelectorAll(".col-body-main").forEach(el => el.textContent = "");
    }

    // =========================
    // 5) Endings lipite + particule PLACE (ì—/ì—ì„œ)
    // =========================
    function normalizeEnding(raw) {
      let t = (raw || "").trim();
      t = t.replace(/^[-~]/, "").trim();
      return t;
    }

    function isStandaloneConnector(x) {
      const t = (x || "").trim();
      return ["ê·¸ë¦¬ê³ ","ê·¸ë˜ì„œ","í•˜ì§€ë§Œ","ë˜","ë˜ëŠ”","ê·¸ë˜ë„","ê·¸ëŸ¬ë©´"].includes(t);
    }

    function attachEndingToVerb(verbInf, endingRaw) {
      const v = (verbInf || "").trim();
      if (!v) return "";
      const e = normalizeEnding(endingRaw);
      if (!e) return v;
      if (isStandaloneConnector(e)) return v;
      if (!v.endsWith("ë‹¤")) return v;

      if (v === "í•˜ë‹¤" && (e === "ì•„ì„œ" || e === "ì–´ì„œ")) return "í•´ì„œ";
      if (v === "í•˜ë‹¤" && e === "ê³ ") return "í•˜ê³ ";
      if (v === "í•˜ë‹¤" && e === "(ìœ¼)ë©´") return "í•˜ë©´";
      if (v === "í•˜ë‹¤" && e === "(ìœ¼)ë ¤ê³ ") return "í•˜ë ¤ê³ ";
      if (v === "í•˜ë‹¤" && e === "(ìœ¼)ã„¹ ë•Œ") return "í•  ë•Œ";

      const stem = v.slice(0, -1);
      const last = lastHangulChar(stem);
      const batchim = hasBatchim(last);

      if (e === "(ìœ¼)ë©´")    return stem + (batchim ? "ìœ¼ë©´" : "ë©´");
      if (e === "(ìœ¼)ã„¹ ë•Œ") return stem + (batchim ? "ì„ ë•Œ" : "ã„¹ ë•Œ");
      if (e === "(ìœ¼)ë ¤ê³ ")  return stem + (batchim ? "ìœ¼ë ¤ê³ " : "ë ¤ê³ ");

      return stem + e;
    }

    function choosePlaceParticle(placeBase, verbInf) {
      const p = (placeBase || "").trim();
      if (!p) return "";
      const v = (verbInf || "").trim();
      if (v === "ê°€ë‹¤" || v === "ì˜¤ë‹¤") return p + "ì—";
      return p + "ì—ì„œ";
    }

    // =========================
    // 6) Polite form (preview only, last clause only)
    // =========================
    function politePresentFromInfinitive(verbInf) {
      const v = (verbInf || "").trim();
      if (!v || !v.endsWith("ë‹¤")) return v;

      const specials = {
        "í•˜ë‹¤": "í•´ìš”",
        "ê³µë¶€í•˜ë‹¤": "ê³µë¶€í•´ìš”",
        "ì¼í•˜ë‹¤": "ì¼í•´ìš”",
      };
      if (specials[v]) return specials[v];

      const stem = v.slice(0, -1);
      const last = stem[stem.length - 1];

      if (last === "í•˜") return stem.slice(0, -1) + "í•´ìš”";

      const code = last.charCodeAt(0);
      if (code < 0xAC00 || code > 0xD7A3) return stem + "ì–´ìš”";

      const sIndex = code - 0xAC00;
      const jung = Math.floor((sIndex % (21 * 28)) / 28);
      const aGroup = [0,2,8,9]; // ã…,ã…‘,ã…—,ã…› -> ì•„ìš”
      const ending = aGroup.includes(jung) ? "ì•„ìš”" : "ì–´ìš”";
      return stem + ending;
    }

    // =========================
    // 7) Build & preview
    // =========================
    function buildClause(idx, isLastClause, politeLastEnabled) {
      const tableId = getTableId(idx);

      const subject = readCell(tableId, "subject");
      const time    = readCell(tableId, "time");
      const placeB  = readCell(tableId, "place");
      const mod     = readCell(tableId, "mod");
      const object  = readCell(tableId, "object");
      const numeral = readCell(tableId, "numeral");
      const counter = readCell(tableId, "counter");
      const verbInf = readCell(tableId, "verb");
      const conjRaw = readCell(tableId, "conj");

      let obj = "";
      if (object && numeral && counter) obj = object + " " + numeral + " " + counter;
      else if (object) obj = object;

      const place = choosePlaceParticle(placeB, verbInf);

      let verbOut = attachEndingToVerb(verbInf, conjRaw);

      if (politeLastEnabled && isLastClause) {
        const conjNorm = normalizeEnding(conjRaw);
        if (!conjNorm && verbInf) verbOut = politePresentFromInfinitive(verbInf);
      }

      const conjNorm = normalizeEnding(conjRaw);
      const mid = isStandaloneConnector(conjNorm) ? conjNorm : "";

      const parts = [subject, time, place, mod, obj, verbOut].filter(Boolean);
      const clause = parts.join(" ").trim();

      return { clause, mid };
    }

    function rebuildPreview() {
      const blocks = host.querySelectorAll("[data-clause-index]");
      const n = blocks.length;
      const polite = !!document.getElementById("politeToggle")?.checked;

      const chunks = [];
      for (let i=0; i<n; i++) {
        const c = buildClause(i, i === n-1, polite);
        // FIX: nu mai sari aiurea pe hasAny; ia doar clauzele non-empty
        if (!c.clause) continue;
        chunks.push(c.clause);
        if (c.mid && i < n-1) chunks.push(c.mid);
      }

      const out = document.getElementById("previewSentence");
      const info = document.getElementById("previewInfo");

      const sentence = chunks.join(" ").replace(/\s+/g," ").trim();
      out.textContent = sentence || "ì € ê°€ìš”";

      info.textContent =
        "PLACE: ê°€ë‹¤/ì˜¤ë‹¤ â†’ ì—, rest â†’ ì—ì„œ. Endings (-ê³ /-ì§€ë§Œ/-ì–´ì„œ/-(ìœ¼)ë©´/-(ìœ¼)ã„¹ ë•Œ/-(ìœ¼)ë ¤ê³ ) se lipesc doar la verb infinitiv (â€¦ë‹¤). " +
        "PoliteÈ›e: schimbÄƒ doar ultimul verb Ã®n preview (tabelul rÄƒmÃ¢ne infinitiv).";
    }

    // =========================
    // 8) Auto-fill
    // =========================
    function applySlotsToClause(idx, slots) {
      const tableId = getTableId(idx);
      if (!slots) return;
      if (slots.subject) setCell(tableId, "subject", slots.subject);
      if (slots.time)    setCell(tableId, "time", slots.time);
      if (slots.place)   setCell(tableId, "place", slots.place);
      if (slots.mod)     setCell(tableId, "mod", slots.mod);
      if (slots.object)  setCell(tableId, "object", slots.object);
      if (slots.numeral) setCell(tableId, "numeral", slots.numeral);
      if (slots.counter) setCell(tableId, "counter", slots.counter);
      if (slots.verb)    setCell(tableId, "verb", slots.verb);
    }

    function autoFillFromInput() {
      const input = document.getElementById("inputText");
      const lang = (document.getElementById("langSelect") || {}).value || "ro";
      const raw = (input && input.value) ? input.value : "";

      const chain = splitIntoChain(raw);
      const clauses = chain.clauses;
      const links = chain.links;

      if (!clauses.length) {
        ensureClauseCount(1);
        clearClause(getTableId(0));
        setCell(getTableId(0), "subject", "ì €");
        setCell(getTableId(0), "verb", "ê°€ë‹¤");
        setCell(getTableId(0), "conj", "");
        rebuildPreview();
        return;
      }

      ensureClauseCount(clauses.length);

      for (let i=0; i<clauses.length; i++) {
        const slots = parseToSlots(clauses[i], lang);
        applySlotsToClause(i, slots);
      }

      for (let i=0; i<links.length; i++) {
        setCell(getTableId(i), "conj", links[i].ko);
      }

      setCell(getTableId(clauses.length - 1), "conj", "");
      rebuildPreview();
    }

    // =========================
    // 9) Clear
    // =========================
    function clearAll() {
      const input = document.getElementById("inputText");
      if (input) input.value = "";

      ensureClauseCount(1);
      clearClause(getTableId(0));
      setCell(getTableId(0), "subject", "ì €");
      setCell(getTableId(0), "verb", "ê°€ë‹¤");
      setCell(getTableId(0), "conj", "");

      const polite = document.getElementById("politeToggle");
      if (polite) polite.checked = false;

      rebuildPreview();
    }

    // =========================
    // 10) Init + live preview
    // =========================
    function wireLivePreview() {
  document.addEventListener("input", function (e) {
    const target = e.target;
    if (target && target.classList && target.classList.contains("col-body-main")) {
      rebuildPreview();
    }
  });

  const polite = document.getElementById("politeToggle");
  if (polite) polite.addEventListener("change", rebuildPreview);
}
    
      });

      // FIX: ID corect
      const polite = document.getElementById("politeToggle");
      if (polite) polite.addEventListener("change", rebuildPreview);
    }

    function init() {
      ensureClauseCount(1);
      setCell("tableP1", "subject", "ì €");
      setCell("tableP1", "verb", "ê°€ë‹¤");
      setCell("tableP1", "conj", "");

      const autoFillBtn = document.getElementById("autoFillBtn");
      const clearBtn = document.getElementById("clearBtn");

      if (autoFillBtn) autoFillBtn.addEventListener("click", autoFillFromInput);
      if (clearBtn) clearBtn.addEventListener("click", clearAll);

      wireLivePreview();
      rebuildPreview();
    }

    window.addEventListener("DOMContentLoaded", init);
  })();
  </script>
</body>
</html>
